(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("___AGENCIA_AMIGA___"));
	else if(typeof define === 'function' && define.amd)
		define(["___AGENCIA_AMIGA___"], factory);
	else if(typeof exports === 'object')
		exports["AgenciaAmiga"] = factory(require("___AGENCIA_AMIGA___"));
	else
		root["AgenciaAmiga"] = factory(root["___AGENCIA_AMIGA___"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdateAgenciaAmiga"];
/******/ 	this["webpackHotUpdateAgenciaAmiga"] = function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "929bfe8bb3e62c2d9624"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "http://localhost:4000/js/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__("./node_modules/react-hot-loader/patch.js");
	__webpack_require__("./node_modules/webpack-dev-server/client/index.js?http:/localhost:4000");
	__webpack_require__("./node_modules/webpack/hot/only-dev-server.js");
	__webpack_require__("./src/overrides.scss");
	module.exports = __webpack_require__("./src/index.jsx");


/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/main.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".main__wrapper__3_tfFMj2MP {\n  background: #f0f0f0;\n  position: absolute;\n  overflow: hidden;\n  font-size: 1rem;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0; }\n\n.main__content__1uha_4FTuL {\n  overflow: auto;\n  padding: .8em; }\n", "", {"version":3,"sources":["/./src/views/containers/src/views/containers/main.scss"],"names":[],"mappings":"AAAA;EACE,oBAAoB;EACpB,mBAAmB;EACnB,iBAAiB;EACjB,gBAAgB;EAChB,OAAO;EACP,QAAQ;EACR,SAAS;EACT,UAAU,EACX;;AAED;EACE,eAAe;EACf,cAAc,EACf","file":"main.scss","sourcesContent":[".wrapper {\n  background: #f0f0f0;\n  position: absolute;\n  overflow: hidden;\n  font-size: 1rem;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.content {\n  overflow: auto;\n  padding: .8em;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "main__wrapper__3_tfFMj2MP",
		"content": "main__content__1uha_4FTuL"
	};

/***/ },

/***/ "./node_modules/react-hot-loader/lib/patch.js":
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable global-require */
	
	'use strict';
	
	if (false) {
	  module.exports = require('./patch.prod');
	} else {
	  module.exports = __webpack_require__("./node_modules/react-hot-loader/lib/patch.dev.js");
	}

/***/ },

/***/ "./node_modules/react-hot-loader/lib/patch.dev.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var React = __webpack_require__(1);
	var createProxy = __webpack_require__("./node_modules/react-proxy/modules/index.js").default;
	var global = __webpack_require__("./node_modules/global/window.js");
	
	var ComponentMap = function () {
	  function ComponentMap(useWeakMap) {
	    _classCallCheck(this, ComponentMap);
	
	    if (useWeakMap) {
	      this.wm = new WeakMap();
	    } else {
	      this.slots = {};
	    }
	  }
	
	  _createClass(ComponentMap, [{
	    key: 'getSlot',
	    value: function getSlot(type) {
	      var key = type.displayName || type.name || 'Unknown';
	      if (!this.slots[key]) {
	        this.slots[key] = [];
	      }
	      return this.slots[key];
	    }
	  }, {
	    key: 'get',
	    value: function get(type) {
	      if (this.wm) {
	        return this.wm.get(type);
	      }
	
	      var slot = this.getSlot(type);
	      for (var i = 0; i < slot.length; i++) {
	        if (slot[i].key === type) {
	          return slot[i].value;
	        }
	      }
	
	      return undefined;
	    }
	  }, {
	    key: 'set',
	    value: function set(type, value) {
	      if (this.wm) {
	        this.wm.set(type, value);
	      } else {
	        var slot = this.getSlot(type);
	        for (var i = 0; i < slot.length; i++) {
	          if (slot[i].key === type) {
	            slot[i].value = value;
	            return;
	          }
	        }
	        slot.push({ key: type, value: value });
	      }
	    }
	  }, {
	    key: 'has',
	    value: function has(type) {
	      if (this.wm) {
	        return this.wm.has(type);
	      }
	
	      var slot = this.getSlot(type);
	      for (var i = 0; i < slot.length; i++) {
	        if (slot[i].key === type) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }]);
	
	  return ComponentMap;
	}();
	
	var proxiesByID = void 0;
	var didWarnAboutID = void 0;
	var hasCreatedElementsByType = void 0;
	var idsByType = void 0;
	
	var hooks = {
	  register: function register(type, uniqueLocalName, fileName) {
	    if (typeof type !== 'function') {
	      return;
	    }
	    if (!uniqueLocalName || !fileName) {
	      return;
	    }
	    if (typeof uniqueLocalName !== 'string' || typeof fileName !== 'string') {
	      return;
	    }
	    var id = fileName + '#' + uniqueLocalName; // eslint-disable-line prefer-template
	    if (!idsByType.has(type) && hasCreatedElementsByType.has(type)) {
	      if (!didWarnAboutID[id]) {
	        didWarnAboutID[id] = true;
	        var baseName = fileName.replace(/^.*[\\\/]/, '');
	        console.error('React Hot Loader: ' + uniqueLocalName + ' in ' + fileName + ' will not hot reload ' + ('correctly because ' + baseName + ' uses <' + uniqueLocalName + ' /> during ') + ('module definition. For hot reloading to work, move ' + uniqueLocalName + ' ') + ('into a separate file and import it from ' + baseName + '.'));
	      }
	      return;
	    }
	
	    // Remember the ID.
	    idsByType.set(type, id);
	
	    // We use React Proxy to generate classes that behave almost
	    // the same way as the original classes but are updatable with
	    // new versions without destroying original instances.
	    if (!proxiesByID[id]) {
	      proxiesByID[id] = createProxy(type);
	    } else {
	      proxiesByID[id].update(type);
	    }
	  },
	  reset: function reset(useWeakMap) {
	    proxiesByID = {};
	    didWarnAboutID = {};
	    hasCreatedElementsByType = new ComponentMap(useWeakMap);
	    idsByType = new ComponentMap(useWeakMap);
	  }
	};
	
	hooks.reset(typeof WeakMap === 'function');
	
	function resolveType(type) {
	  // We only care about composite components
	  if (typeof type !== 'function') {
	    return type;
	  }
	
	  hasCreatedElementsByType.set(type, true);
	
	  // When available, give proxy class to React instead of the real class.
	  var id = idsByType.get(type);
	  if (!id) {
	    return type;
	  }
	
	  var proxy = proxiesByID[id];
	  if (!proxy) {
	    return type;
	  }
	
	  return proxy.get();
	}
	
	var createElement = React.createElement;
	function patchedCreateElement(type) {
	  // Trick React into rendering a proxy so that
	  // its state is preserved when the class changes.
	  // This will update the proxy if it's for a known type.
	  var resolvedType = resolveType(type);
	
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	
	  return createElement.apply(undefined, [resolvedType].concat(args));
	}
	patchedCreateElement.isPatchedByReactHotLoader = true;
	
	function patchedCreateFactory(type) {
	  // Patch React.createFactory to use patched createElement
	  // because the original implementation uses the internal,
	  // unpatched ReactElement.createElement
	  var factory = patchedCreateElement.bind(null, type);
	  factory.type = type;
	  return factory;
	}
	patchedCreateFactory.isPatchedByReactHotLoader = true;
	
	if (typeof global.__REACT_HOT_LOADER__ === 'undefined') {
	  React.createElement = patchedCreateElement;
	  React.createFactory = patchedCreateFactory;
	  global.__REACT_HOT_LOADER__ = hooks;
	}

/***/ },

/***/ 1:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(964);

/***/ },

/***/ 2:
/***/ function(module, exports) {

	module.exports = ___AGENCIA_AMIGA___;

/***/ },

/***/ "./node_modules/react-proxy/modules/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _supportsProtoAssignment = __webpack_require__("./node_modules/react-proxy/modules/supportsProtoAssignment.js");
	
	var _supportsProtoAssignment2 = _interopRequireDefault(_supportsProtoAssignment);
	
	var _createClassProxy = __webpack_require__("./node_modules/react-proxy/modules/createClassProxy.js");
	
	var _createClassProxy2 = _interopRequireDefault(_createClassProxy);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	if (!(0, _supportsProtoAssignment2.default)()) {
	  console.warn('This JavaScript environment does not support __proto__. ' + 'This means that react-proxy is unable to proxy React components. ' + 'Features that rely on react-proxy, such as react-transform-hmr, ' + 'will not function as expected.');
	}
	
	exports.default = _createClassProxy2.default;

/***/ },

/***/ "./node_modules/react-proxy/modules/supportsProtoAssignment.js":
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = supportsProtoAssignment;
	var x = {};
	var y = { supports: true };
	try {
	  x.__proto__ = y;
	} catch (err) {}
	
	function supportsProtoAssignment() {
	  return x.supports || false;
	};

/***/ },

/***/ "./node_modules/react-proxy/modules/createClassProxy.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = createClassProxy;
	
	var _find = __webpack_require__(3);
	
	var _find2 = _interopRequireDefault(_find);
	
	var _createPrototypeProxy = __webpack_require__("./node_modules/react-proxy/modules/createPrototypeProxy.js");
	
	var _createPrototypeProxy2 = _interopRequireDefault(_createPrototypeProxy);
	
	var _bindAutoBindMethods = __webpack_require__("./node_modules/react-proxy/modules/bindAutoBindMethods.js");
	
	var _bindAutoBindMethods2 = _interopRequireDefault(_bindAutoBindMethods);
	
	var _deleteUnknownAutoBindMethods = __webpack_require__("./node_modules/react-proxy/modules/deleteUnknownAutoBindMethods.js");
	
	var _deleteUnknownAutoBindMethods2 = _interopRequireDefault(_deleteUnknownAutoBindMethods);
	
	var _supportsProtoAssignment = __webpack_require__("./node_modules/react-proxy/modules/supportsProtoAssignment.js");
	
	var _supportsProtoAssignment2 = _interopRequireDefault(_supportsProtoAssignment);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var RESERVED_STATICS = ['length', 'displayName', 'name', 'arguments', 'caller', 'prototype', 'toString'];
	
	function isEqualDescriptor(a, b) {
	  if (!a && !b) {
	    return true;
	  }
	  if (!a || !b) {
	    return false;
	  }
	  for (var key in a) {
	    if (a[key] !== b[key]) {
	      return false;
	    }
	  }
	  return true;
	}
	
	function getDisplayName(Component) {
	  var displayName = Component.displayName || Component.name;
	  return displayName && displayName !== 'ReactComponent' ? displayName : 'Unknown';
	}
	
	// This was originally a WeakMap but we had issues with React Native:
	// https://github.com/gaearon/react-proxy/issues/50#issuecomment-192928066
	var allProxies = [];
	function findProxy(Component) {
	  var pair = (0, _find2.default)(allProxies, function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 1);
	
	    var key = _ref2[0];
	    return key === Component;
	  });
	  return pair ? pair[1] : null;
	}
	function addProxy(Component, proxy) {
	  allProxies.push([Component, proxy]);
	}
	
	function proxyClass(InitialComponent) {
	  // Prevent double wrapping.
	  // Given a proxy class, return the existing proxy managing it.
	  var existingProxy = findProxy(InitialComponent);
	  if (existingProxy) {
	    return existingProxy;
	  }
	
	  var CurrentComponent = undefined;
	  var ProxyComponent = undefined;
	  var savedDescriptors = {};
	
	  function instantiate(factory, context, params) {
	    var component = factory();
	
	    try {
	      return component.apply(context, params);
	    } catch (err) {
	      (function () {
	        // Native ES6 class instantiation
	        var instance = new (Function.prototype.bind.apply(component, [null].concat(_toConsumableArray(params))))();
	
	        Object.keys(instance).forEach(function (key) {
	          if (RESERVED_STATICS.indexOf(key) > -1) {
	            return;
	          }
	          context[key] = instance[key];
	        });
	      })();
	    }
	  }
	
	  var displayName = getDisplayName(InitialComponent);
	  try {
	    // Create a proxy constructor with matching name
	    ProxyComponent = new Function('factory', 'instantiate', 'return function ' + displayName + '() {\n         return instantiate(factory, this, arguments);\n      }')(function () {
	      return CurrentComponent;
	    }, instantiate);
	  } catch (err) {
	    // Some environments may forbid dynamic evaluation
	    ProxyComponent = function ProxyComponent() {
	      return instantiate(function () {
	        return CurrentComponent;
	      }, this, arguments);
	    };
	  }
	  try {
	    Object.defineProperty(ProxyComponent, 'name', {
	      value: displayName
	    });
	  } catch (err) {}
	
	  // Proxy toString() to the current constructor
	  ProxyComponent.toString = function toString() {
	    return CurrentComponent.toString();
	  };
	
	  var prototypeProxy = undefined;
	  if (InitialComponent.prototype && InitialComponent.prototype.isReactComponent) {
	    // Point proxy constructor to the proxy prototype
	    prototypeProxy = (0, _createPrototypeProxy2.default)();
	    ProxyComponent.prototype = prototypeProxy.get();
	  }
	
	  function update(NextComponent) {
	    if (typeof NextComponent !== 'function') {
	      throw new Error('Expected a constructor.');
	    }
	    if (NextComponent === CurrentComponent) {
	      return;
	    }
	
	    // Prevent proxy cycles
	    var existingProxy = findProxy(NextComponent);
	    if (existingProxy) {
	      return update(existingProxy.__getCurrent());
	    }
	
	    // Save the next constructor so we call it
	    var PreviousComponent = CurrentComponent;
	    CurrentComponent = NextComponent;
	
	    // Try to infer displayName
	    displayName = getDisplayName(NextComponent);
	    ProxyComponent.displayName = displayName;
	    try {
	      Object.defineProperty(ProxyComponent, 'name', {
	        value: displayName
	      });
	    } catch (err) {}
	
	    // Set up the same prototype for inherited statics
	    ProxyComponent.__proto__ = NextComponent.__proto__;
	
	    // Copy over static methods and properties added at runtime
	    if (PreviousComponent) {
	      Object.getOwnPropertyNames(PreviousComponent).forEach(function (key) {
	        if (RESERVED_STATICS.indexOf(key) > -1) {
	          return;
	        }
	
	        var prevDescriptor = Object.getOwnPropertyDescriptor(PreviousComponent, key);
	        var savedDescriptor = savedDescriptors[key];
	
	        if (!isEqualDescriptor(prevDescriptor, savedDescriptor)) {
	          Object.defineProperty(NextComponent, key, prevDescriptor);
	        }
	      });
	    }
	
	    // Copy newly defined static methods and properties
	    Object.getOwnPropertyNames(NextComponent).forEach(function (key) {
	      if (RESERVED_STATICS.indexOf(key) > -1) {
	        return;
	      }
	
	      var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(PreviousComponent, key);
	      var savedDescriptor = savedDescriptors[key];
	
	      // Skip redefined descriptors
	      if (prevDescriptor && savedDescriptor && !isEqualDescriptor(savedDescriptor, prevDescriptor)) {
	        Object.defineProperty(NextComponent, key, prevDescriptor);
	        Object.defineProperty(ProxyComponent, key, prevDescriptor);
	        return;
	      }
	
	      if (prevDescriptor && !savedDescriptor) {
	        Object.defineProperty(ProxyComponent, key, prevDescriptor);
	        return;
	      }
	
	      var nextDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextComponent, key), {
	        configurable: true
	      });
	      savedDescriptors[key] = nextDescriptor;
	      Object.defineProperty(ProxyComponent, key, nextDescriptor);
	    });
	
	    // Remove static methods and properties that are no longer defined
	    Object.getOwnPropertyNames(ProxyComponent).forEach(function (key) {
	      if (RESERVED_STATICS.indexOf(key) > -1) {
	        return;
	      }
	      // Skip statics that exist on the next class
	      if (NextComponent.hasOwnProperty(key)) {
	        return;
	      }
	      // Skip non-configurable statics
	      var proxyDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);
	      if (proxyDescriptor && !proxyDescriptor.configurable) {
	        return;
	      }
	
	      var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(PreviousComponent, key);
	      var savedDescriptor = savedDescriptors[key];
	
	      // Skip redefined descriptors
	      if (prevDescriptor && savedDescriptor && !isEqualDescriptor(savedDescriptor, prevDescriptor)) {
	        return;
	      }
	
	      delete ProxyComponent[key];
	    });
	
	    if (prototypeProxy) {
	      // Update the prototype proxy with new methods
	      var mountedInstances = prototypeProxy.update(NextComponent.prototype);
	
	      // Set up the constructor property so accessing the statics work
	      ProxyComponent.prototype.constructor = NextComponent;
	
	      // We might have added new methods that need to be auto-bound
	      mountedInstances.forEach(_bindAutoBindMethods2.default);
	      mountedInstances.forEach(_deleteUnknownAutoBindMethods2.default);
	    }
	  };
	
	  function get() {
	    return ProxyComponent;
	  }
	
	  function getCurrent() {
	    return CurrentComponent;
	  }
	
	  update(InitialComponent);
	
	  var proxy = { get: get, update: update };
	  addProxy(ProxyComponent, proxy);
	
	  Object.defineProperty(proxy, '__getCurrent', {
	    configurable: false,
	    writable: false,
	    enumerable: false,
	    value: getCurrent
	  });
	
	  return proxy;
	}
	
	function createFallback(Component) {
	  var CurrentComponent = Component;
	
	  return {
	    get: function get() {
	      return CurrentComponent;
	    },
	    update: function update(NextComponent) {
	      CurrentComponent = NextComponent;
	    }
	  };
	}
	
	function createClassProxy(Component) {
	  return Component.__proto__ && (0, _supportsProtoAssignment2.default)() ? proxyClass(Component) : createFallback(Component);
	}

/***/ },

/***/ 3:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1895);

/***/ },

/***/ "./node_modules/react-proxy/modules/createPrototypeProxy.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createPrototypeProxy;
	
	var _assign = __webpack_require__(4);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	var _difference = __webpack_require__(5);
	
	var _difference2 = _interopRequireDefault(_difference);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createPrototypeProxy() {
	  var proxy = {};
	  var current = null;
	  var mountedInstances = [];
	
	  /**
	   * Creates a proxied toString() method pointing to the current version's toString().
	   */
	  function proxyToString(name) {
	    // Wrap to always call the current version
	    return function toString() {
	      if (typeof current[name] === 'function') {
	        return current[name].toString();
	      } else {
	        return '<method was deleted>';
	      }
	    };
	  }
	
	  /**
	   * Creates a proxied method that calls the current version, whenever available.
	   */
	  function proxyMethod(name) {
	    // Wrap to always call the current version
	    var proxiedMethod = function proxiedMethod() {
	      if (typeof current[name] === 'function') {
	        return current[name].apply(this, arguments);
	      }
	    };
	
	    // Copy properties of the original function, if any
	    (0, _assign2.default)(proxiedMethod, current[name]);
	    proxiedMethod.toString = proxyToString(name);
	    try {
	      Object.defineProperty(proxiedMethod, 'name', {
	        value: name
	      });
	    } catch (err) {}
	
	    return proxiedMethod;
	  }
	
	  /**
	   * Augments the original componentDidMount with instance tracking.
	   */
	  function proxiedComponentDidMount() {
	    mountedInstances.push(this);
	    if (typeof current.componentDidMount === 'function') {
	      return current.componentDidMount.apply(this, arguments);
	    }
	  }
	  proxiedComponentDidMount.toString = proxyToString('componentDidMount');
	
	  /**
	   * Augments the original componentWillUnmount with instance tracking.
	   */
	  function proxiedComponentWillUnmount() {
	    var index = mountedInstances.indexOf(this);
	    // Unless we're in a weird environment without componentDidMount
	    if (index !== -1) {
	      mountedInstances.splice(index, 1);
	    }
	    if (typeof current.componentWillUnmount === 'function') {
	      return current.componentWillUnmount.apply(this, arguments);
	    }
	  }
	  proxiedComponentWillUnmount.toString = proxyToString('componentWillUnmount');
	
	  /**
	   * Defines a property on the proxy.
	   */
	  function defineProxyProperty(name, descriptor) {
	    Object.defineProperty(proxy, name, descriptor);
	  }
	
	  /**
	   * Defines a property, attempting to keep the original descriptor configuration.
	   */
	  function defineProxyPropertyWithValue(name, value) {
	    var _ref = Object.getOwnPropertyDescriptor(current, name) || {};
	
	    var _ref$enumerable = _ref.enumerable;
	    var enumerable = _ref$enumerable === undefined ? false : _ref$enumerable;
	    var _ref$writable = _ref.writable;
	    var writable = _ref$writable === undefined ? true : _ref$writable;
	
	
	    defineProxyProperty(name, {
	      configurable: true,
	      enumerable: enumerable,
	      writable: writable,
	      value: value
	    });
	  }
	
	  /**
	   * Creates an auto-bind map mimicking the original map, but directed at proxy.
	   */
	  function createAutoBindMap() {
	    if (!current.__reactAutoBindMap) {
	      return;
	    }
	
	    var __reactAutoBindMap = {};
	    for (var name in current.__reactAutoBindMap) {
	      if (typeof proxy[name] === 'function' && current.__reactAutoBindMap.hasOwnProperty(name)) {
	        __reactAutoBindMap[name] = proxy[name];
	      }
	    }
	
	    return __reactAutoBindMap;
	  }
	
	  /**
	   * Creates an auto-bind map mimicking the original map, but directed at proxy.
	   */
	  function createAutoBindPairs() {
	    var __reactAutoBindPairs = [];
	
	    for (var i = 0; i < current.__reactAutoBindPairs.length; i += 2) {
	      var name = current.__reactAutoBindPairs[i];
	      var method = proxy[name];
	
	      if (typeof method === 'function') {
	        __reactAutoBindPairs.push(name, method);
	      }
	    }
	
	    return __reactAutoBindPairs;
	  }
	
	  /**
	   * Applies the updated prototype.
	   */
	  function update(next) {
	    // Save current source of truth
	    current = next;
	
	    // Find changed property names
	    var currentNames = Object.getOwnPropertyNames(current);
	    var previousName = Object.getOwnPropertyNames(proxy);
	    var removedNames = (0, _difference2.default)(previousName, currentNames);
	
	    // Remove properties and methods that are no longer there
	    removedNames.forEach(function (name) {
	      delete proxy[name];
	    });
	
	    // Copy every descriptor
	    currentNames.forEach(function (name) {
	      var descriptor = Object.getOwnPropertyDescriptor(current, name);
	      if (typeof descriptor.value === 'function') {
	        // Functions require additional wrapping so they can be bound later
	        defineProxyPropertyWithValue(name, proxyMethod(name));
	      } else {
	        // Other values can be copied directly
	        defineProxyProperty(name, descriptor);
	      }
	    });
	
	    // Track mounting and unmounting
	    defineProxyPropertyWithValue('componentDidMount', proxiedComponentDidMount);
	    defineProxyPropertyWithValue('componentWillUnmount', proxiedComponentWillUnmount);
	
	    if (current.hasOwnProperty('__reactAutoBindMap')) {
	      defineProxyPropertyWithValue('__reactAutoBindMap', createAutoBindMap());
	    }
	
	    if (current.hasOwnProperty('__reactAutoBindPairs')) {
	      defineProxyPropertyWithValue('__reactAutoBindPairs', createAutoBindPairs());
	    }
	
	    // Set up the prototype chain
	    proxy.__proto__ = next;
	
	    return mountedInstances;
	  }
	
	  /**
	   * Returns the up-to-date proxy prototype.
	   */
	  function get() {
	    return proxy;
	  }
	
	  return {
	    update: update,
	    get: get
	  };
	};

/***/ },

/***/ 4:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(2106);

/***/ },

/***/ 5:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1565);

/***/ },

/***/ "./node_modules/react-proxy/modules/bindAutoBindMethods.js":
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = bindAutoBindMethods;
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of React source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Original:
	 * https://github.com/facebook/react/blob/6508b1ad273a6f371e8d90ae676e5390199461b4/src/isomorphic/classic/class/ReactClass.js#L650-L713
	 */
	
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	
	  boundMethod.__reactBoundContext = component;
	  boundMethod.__reactBoundMethod = method;
	  boundMethod.__reactBoundArguments = null;
	
	  var componentName = component.constructor.displayName,
	      _bind = boundMethod.bind;
	
	  boundMethod.bind = function (newThis) {
	    var args = Array.prototype.slice.call(arguments, 1);
	    if (newThis !== component && newThis !== null) {
	      console.warn('bind(): React component methods may only be bound to the ' + 'component instance. See ' + componentName);
	    } else if (!args.length) {
	      console.warn('bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See ' + componentName);
	      return boundMethod;
	    }
	
	    var reboundMethod = _bind.apply(boundMethod, arguments);
	    reboundMethod.__reactBoundContext = component;
	    reboundMethod.__reactBoundMethod = method;
	    reboundMethod.__reactBoundArguments = args;
	
	    return reboundMethod;
	  };
	
	  return boundMethod;
	}
	
	function bindAutoBindMethodsFromMap(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (!component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      return;
	    }
	
	    // Tweak: skip methods that are already bound.
	    // This is to preserve method reference in case it is used
	    // as a subscription handler that needs to be detached later.
	    if (component.hasOwnProperty(autoBindKey) && component[autoBindKey].__reactBoundContext === component) {
	      continue;
	    }
	
	    var method = component.__reactAutoBindMap[autoBindKey];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	function bindAutoBindMethods(component) {
	  if (component.__reactAutoBindPairs) {
	    bindAutoBindMethodsFromArray(component);
	  } else if (component.__reactAutoBindMap) {
	    bindAutoBindMethodsFromMap(component);
	  }
	}
	
	function bindAutoBindMethodsFromArray(component) {
	  var pairs = component.__reactAutoBindPairs;
	
	  if (!pairs) {
	    return;
	  }
	
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	
	    if (component.hasOwnProperty(autoBindKey) && component[autoBindKey].__reactBoundContext === component) {
	      continue;
	    }
	
	    var method = pairs[i + 1];
	
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}

/***/ },

/***/ "./node_modules/react-proxy/modules/deleteUnknownAutoBindMethods.js":
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = deleteUnknownAutoBindMethods;
	function shouldDeleteClassicInstanceMethod(component, name) {
	  if (component.__reactAutoBindMap && component.__reactAutoBindMap.hasOwnProperty(name)) {
	    // It's a known autobound function, keep it
	    return false;
	  }
	
	  if (component.__reactAutoBindPairs && component.__reactAutoBindPairs.indexOf(name) >= 0) {
	    // It's a known autobound function, keep it
	    return false;
	  }
	
	  if (component[name].__reactBoundArguments !== null) {
	    // It's a function bound to specific args, keep it
	    return false;
	  }
	
	  // It's a cached bound method for a function
	  // that was deleted by user, so we delete it from component.
	  return true;
	}
	
	function shouldDeleteModernInstanceMethod(component, name) {
	  var prototype = component.constructor.prototype;
	
	  var prototypeDescriptor = Object.getOwnPropertyDescriptor(prototype, name);
	
	  if (!prototypeDescriptor || !prototypeDescriptor.get) {
	    // This is definitely not an autobinding getter
	    return false;
	  }
	
	  if (prototypeDescriptor.get().length !== component[name].length) {
	    // The length doesn't match, bail out
	    return false;
	  }
	
	  // This seems like a method bound using an autobinding getter on the prototype
	  // Hopefully we won't run into too many false positives.
	  return true;
	}
	
	function shouldDeleteInstanceMethod(component, name) {
	  var descriptor = Object.getOwnPropertyDescriptor(component, name);
	  if (typeof descriptor.value !== 'function') {
	    // Not a function, or something fancy: bail out
	    return;
	  }
	
	  if (component.__reactAutoBindMap || component.__reactAutoBindPairs) {
	    // Classic
	    return shouldDeleteClassicInstanceMethod(component, name);
	  } else {
	    // Modern
	    return shouldDeleteModernInstanceMethod(component, name);
	  }
	}
	
	/**
	 * Deletes autobound methods from the instance.
	 *
	 * For classic React classes, we only delete the methods that no longer exist in map.
	 * This means the user actually deleted them in code.
	 *
	 * For modern classes, we delete methods that exist on prototype with the same length,
	 * and which have getters on prototype, but are normal values on the instance.
	 * This is usually an indication that an autobinding decorator is being used,
	 * and the getter will re-generate the memoized handler on next access.
	 */
	function deleteUnknownAutoBindMethods(component) {
	  var names = Object.getOwnPropertyNames(component);
	
	  names.forEach(function (name) {
	    if (shouldDeleteInstanceMethod(component, name)) {
	      delete component[name];
	    }
	  });
	}

/***/ },

/***/ "./node_modules/global/window.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {if (typeof window !== "undefined") {
	    module.exports = window;
	} else if (typeof global !== "undefined") {
	    module.exports = global;
	} else if (typeof self !== "undefined"){
	    module.exports = self;
	} else {
	    module.exports = {};
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/webpack-dev-server/client/index.js?http:/localhost:4000":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__resourceQuery) {var url = __webpack_require__("./node_modules/url/url.js");
	var stripAnsi = __webpack_require__("./node_modules/strip-ansi/index.js");
	var socket = __webpack_require__("./node_modules/webpack-dev-server/client/socket.js");
	
	function getCurrentScriptSource() {
		// `document.currentScript` is the most accurate way to find the current script,
		// but is not supported in all browsers.
		if(document.currentScript)
			return document.currentScript.getAttribute("src");
		// Fall back to getting all scripts in the document.
		var scriptElements = document.scripts || [];
		var currentScript = scriptElements[scriptElements.length - 1];
		if(currentScript)
			return currentScript.getAttribute("src");
		// Fail as there was no script to use.
		throw new Error("[WDS] Failed to get current script source");
	}
	
	var urlParts;
	if(true) {
		// If this bundle is inlined, use the resource query to get the correct url.
		urlParts = url.parse(__resourceQuery.substr(1));
	} else {
		// Else, get the url from the <script> this file was called with.
		var scriptHost = getCurrentScriptSource();
		scriptHost = scriptHost.replace(/\/[^\/]+$/, "");
		urlParts = url.parse((scriptHost ? scriptHost : "/"), false, true);
	}
	
	var hot = false;
	var initial = true;
	var currentHash = "";
	var logLevel = "info";
	
	function log(level, msg) {
		if(logLevel === "info" && level === "info")
			return console.log(msg);
		if(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning")
			return console.warn(msg);
		if(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error")
			return console.error(msg);
	}
	
	var onSocketMsg = {
		hot: function() {
			hot = true;
			log("info", "[WDS] Hot Module Replacement enabled.");
		},
		invalid: function() {
			log("info", "[WDS] App updated. Recompiling...");
		},
		hash: function(hash) {
			currentHash = hash;
		},
		"still-ok": function() {
			log("info", "[WDS] Nothing changed.")
		},
		"log-level": function(level) {
			logLevel = level;
		},
		ok: function() {
			if(initial) return initial = false;
			reloadApp();
		},
		warnings: function(warnings) {
			log("info", "[WDS] Warnings while compiling.");
			for(var i = 0; i < warnings.length; i++)
				console.warn(stripAnsi(warnings[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		errors: function(errors) {
			log("info", "[WDS] Errors while compiling.");
			for(var i = 0; i < errors.length; i++)
				console.error(stripAnsi(errors[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		"proxy-error": function(errors) {
			log("info", "[WDS] Proxy error.");
			for(var i = 0; i < errors.length; i++)
				log("error", stripAnsi(errors[i]));
			if(initial) return initial = false;
		},
		close: function() {
			log("error", "[WDS] Disconnected!");
		}
	};
	
	var hostname = urlParts.hostname;
	var protocol = urlParts.protocol;
	
	if(urlParts.hostname === '0.0.0.0') {
		// why do we need this check?
		// hostname n/a for file protocol (example, when using electron, ionic)
		// see: https://github.com/webpack/webpack-dev-server/pull/384
		if(window.location.hostname && !!~window.location.protocol.indexOf('http')) {
			hostname = window.location.hostname;
		}
	}
	
	// `hostname` can be empty when the script path is relative. In that case, specifying
	// a protocol would result in an invalid URL.
	// When https is used in the app, secure websockets are always necessary
	// because the browser doesn't accept non-secure websockets.
	if(hostname && (window.location.protocol === "https:" || urlParts.hostname === '0.0.0.0')) {
		protocol = window.location.protocol;
	}
	
	var socketUrl = url.format({
		protocol: protocol,
		auth: urlParts.auth,
		hostname: hostname,
		port: (urlParts.port === '0') ? window.location.port : urlParts.port,
		pathname: urlParts.path == null || urlParts.path === '/' ? "/sockjs-node" : urlParts.path
	});
	
	socket(socketUrl, onSocketMsg);
	
	function reloadApp() {
		if(hot) {
			log("info", "[WDS] App hot update...");
			window.postMessage("webpackHotUpdate" + currentHash, "*");
		} else {
			log("info", "[WDS] App updated. Reloading...");
			window.location.reload();
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "?http://localhost:4000"))

/***/ },

/***/ "./node_modules/url/url.js":
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__("./node_modules/url/node_modules/punycode/punycode.js");
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__("./node_modules/querystring/index.js");
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), (function() { return this; }())))

/***/ },

/***/ 6:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(3);

/***/ },

/***/ "./node_modules/querystring/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__("./node_modules/querystring/decode.js");
	exports.encode = exports.stringify = __webpack_require__("./node_modules/querystring/encode.js");


/***/ },

/***/ "./node_modules/querystring/decode.js":
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },

/***/ "./node_modules/querystring/encode.js":
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },

/***/ "./node_modules/strip-ansi/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__("./node_modules/ansi-regex/index.js")();
	
	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },

/***/ "./node_modules/ansi-regex/index.js":
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
	};


/***/ },

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/***/ function(module, exports, __webpack_require__) {

	var SockJS = __webpack_require__("./node_modules/sockjs-client/lib/entry.js");
	
	var retries = 0;
	var sock = null;
	
	function socket(url, handlers) {
		sock = new SockJS(url);
	
		sock.onopen = function() {
			retries = 0;
		}
	
		sock.onclose = function() {
			if(retries === 0)
				handlers.close();
	
			// Try to reconnect.
			sock = null;
	
			// After 10 retries stop trying, to prevent logspam.
			if(retries <= 10) {
				// Exponentially increase timeout to reconnect.
				// Respectfully copied from the package `got`.
				var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
				retries += 1;
	
				setTimeout(function() {
					socket(url, handlers);
				}, retryInMs);
			}
		};
	
		sock.onmessage = function(e) {
			// This assumes that all data sent via the websocket is JSON.
			var msg = JSON.parse(e.data);
			if(handlers[msg.type])
				handlers[msg.type](msg.data);
		};
	}
	
	module.exports = socket;


/***/ },

/***/ "./node_modules/sockjs-client/lib/entry.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var transportList = __webpack_require__("./node_modules/sockjs-client/lib/transport-list.js");
	
	module.exports = __webpack_require__("./node_modules/sockjs-client/lib/main.js")(transportList);
	
	// TODO can't get rid of this until all servers do
	if ('_sockjs_onload' in global) {
	  setTimeout(global._sockjs_onload, 1);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport-list.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = [
	  // streaming transports
	  __webpack_require__("./node_modules/sockjs-client/lib/transport/websocket.js")
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/xhr-streaming.js")
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/xdr-streaming.js")
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/eventsource.js")
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/iframe-wrap.js")(__webpack_require__("./node_modules/sockjs-client/lib/transport/eventsource.js"))
	
	  // polling transports
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/htmlfile.js")
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/iframe-wrap.js")(__webpack_require__("./node_modules/sockjs-client/lib/transport/htmlfile.js"))
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/xhr-polling.js")
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/xdr-polling.js")
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/iframe-wrap.js")(__webpack_require__("./node_modules/sockjs-client/lib/transport/xhr-polling.js"))
	, __webpack_require__("./node_modules/sockjs-client/lib/transport/jsonp-polling.js")
	];


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/websocket.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , WebsocketDriver = __webpack_require__("./node_modules/sockjs-client/lib/transport/browser/websocket.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:websocket');
	}
	
	function WebSocketTransport(transUrl, ignore, options) {
	  if (!WebSocketTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  EventEmitter.call(this);
	  debug('constructor', transUrl);
	
	  var self = this;
	  var url = urlUtils.addPath(transUrl, '/websocket');
	  if (url.slice(0, 5) === 'https') {
	    url = 'wss' + url.slice(5);
	  } else {
	    url = 'ws' + url.slice(4);
	  }
	  this.url = url;
	
	  this.ws = new WebsocketDriver(this.url, [], options);
	  this.ws.onmessage = function(e) {
	    debug('message event', e.data);
	    self.emit('message', e.data);
	  };
	  // Firefox has an interesting bug. If a websocket connection is
	  // created after onunload, it stays alive even when user
	  // navigates away from the page. In such situation let's lie -
	  // let's not open the ws connection at all. See:
	  // https://github.com/sockjs/sockjs-client/issues/28
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
	  this.unloadRef = utils.unloadAdd(function() {
	    debug('unload');
	    self.ws.close();
	  });
	  this.ws.onclose = function(e) {
	    debug('close event', e.code, e.reason);
	    self.emit('close', e.code, e.reason);
	    self._cleanup();
	  };
	  this.ws.onerror = function(e) {
	    debug('error event', e);
	    self.emit('close', 1006, 'WebSocket connection broken');
	    self._cleanup();
	  };
	}
	
	inherits(WebSocketTransport, EventEmitter);
	
	WebSocketTransport.prototype.send = function(data) {
	  var msg = '[' + data + ']';
	  debug('send', msg);
	  this.ws.send(msg);
	};
	
	WebSocketTransport.prototype.close = function() {
	  debug('close');
	  if (this.ws) {
	    this.ws.close();
	  }
	  this._cleanup();
	};
	
	WebSocketTransport.prototype._cleanup = function() {
	  debug('_cleanup');
	  var ws = this.ws;
	  if (ws) {
	    ws.onmessage = ws.onclose = ws.onerror = null;
	  }
	  utils.unloadDel(this.unloadRef);
	  this.unloadRef = this.ws = null;
	  this.removeAllListeners();
	};
	
	WebSocketTransport.enabled = function() {
	  debug('enabled');
	  return !!WebsocketDriver;
	};
	WebSocketTransport.transportName = 'websocket';
	
	// In theory, ws should require 1 round trip. But in chrome, this is
	// not very stable over SSL. Most likely a ws connection requires a
	// separate SSL connection, in which case 2 round trips are an
	// absolute minumum.
	WebSocketTransport.roundTrips = 2;
	
	module.exports = WebSocketTransport;


/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/event.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var random = __webpack_require__("./node_modules/sockjs-client/lib/utils/random.js");
	
	var onUnload = {}
	  , afterUnload = false
	    // detect google chrome packaged apps because they don't allow the 'unload' event
	  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
	  ;
	
	module.exports = {
	  attachEvent: function(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.addEventListener(event, listener, false);
	    } else if (global.document && global.attachEvent) {
	      // IE quirks.
	      // According to: http://stevesouders.com/misc/test-postmessage.php
	      // the message gets delivered only to 'document', not 'window'.
	      global.document.attachEvent('on' + event, listener);
	      // I get 'window' for ie8.
	      global.attachEvent('on' + event, listener);
	    }
	  }
	
	, detachEvent: function(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.removeEventListener(event, listener, false);
	    } else if (global.document && global.detachEvent) {
	      global.document.detachEvent('on' + event, listener);
	      global.detachEvent('on' + event, listener);
	    }
	  }
	
	, unloadAdd: function(listener) {
	    if (isChromePackagedApp) {
	      return null;
	    }
	
	    var ref = random.string(8);
	    onUnload[ref] = listener;
	    if (afterUnload) {
	      setTimeout(this.triggerUnloadCallbacks, 0);
	    }
	    return ref;
	  }
	
	, unloadDel: function(ref) {
	    if (ref in onUnload) {
	      delete onUnload[ref];
	    }
	  }
	
	, triggerUnloadCallbacks: function() {
	    for (var ref in onUnload) {
	      onUnload[ref]();
	      delete onUnload[ref];
	    }
	  }
	};
	
	var unloadTriggered = function() {
	  if (afterUnload) {
	    return;
	  }
	  afterUnload = true;
	  module.exports.triggerUnloadCallbacks();
	};
	
	// 'unload' alone is not reliable in opera within an iframe, but we
	// can't use `beforeunload` as IE fires it on javascript: links.
	if (!isChromePackagedApp) {
	  module.exports.attachEvent('unload', unloadTriggered);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/random.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/* global crypto:true */
	var crypto = __webpack_require__("./node_modules/sockjs-client/lib/utils/browser-crypto.js");
	
	// This string has length 32, a power of 2, so the modulus doesn't introduce a
	// bias.
	var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
	module.exports = {
	  string: function(length) {
	    var max = _randomStringChars.length;
	    var bytes = crypto.randomBytes(length);
	    var ret = [];
	    for (var i = 0; i < length; i++) {
	      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
	    }
	    return ret.join('');
	  }
	
	, number: function(max) {
	    return Math.floor(Math.random() * max);
	  }
	
	, numberString: function(max) {
	    var t = ('' + (max - 1)).length;
	    var p = new Array(t + 1).join('0');
	    return (p + this.number(max)).slice(-t);
	  }
	};


/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/browser-crypto.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	if (global.crypto && global.crypto.getRandomValues) {
	  module.exports.randomBytes = function(length) {
	    var bytes = new Uint8Array(length);
	    global.crypto.getRandomValues(bytes);
	    return bytes;
	  };
	} else {
	  module.exports.randomBytes = function(length) {
	    var bytes = new Array(length);
	    for (var i = 0; i < length; i++) {
	      bytes[i] = Math.floor(Math.random() * 256);
	    }
	    return bytes;
	  };
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/url.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var URL = __webpack_require__("./node_modules/url-parse/index.js");
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:utils:url');
	}
	
	module.exports = {
	  getOrigin: function(url) {
	    if (!url) {
	      return null;
	    }
	
	    var p = new URL(url);
	    if (p.protocol === 'file:') {
	      return null;
	    }
	
	    var port = p.port;
	    if (!port) {
	      port = (p.protocol === 'https:') ? '443' : '80';
	    }
	
	    return p.protocol + '//' + p.hostname + ':' + port;
	  }
	
	, isOriginEqual: function(a, b) {
	    var res = this.getOrigin(a) === this.getOrigin(b);
	    debug('same', a, b, res);
	    return res;
	  }
	
	, isSchemeEqual: function(a, b) {
	    return (a.split(':')[0] === b.split(':')[0]);
	  }
	
	, addPath: function (url, path) {
	    var qs = url.split('?');
	    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
	  }
	
	, addQuery: function (url, q) {
	    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
	  }
	};


/***/ },

/***/ "./node_modules/url-parse/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var required = __webpack_require__("./node_modules/requires-port/index.js")
	  , lolcation = __webpack_require__("./node_modules/url-parse/lolcation.js")
	  , qs = __webpack_require__("./node_modules/querystringify/index.js")
	  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i;
	
	/**
	 * These are the parse rules for the URL parser, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it's a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it's backwards or forward parsing, when set as number it's
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */
	var rules = [
	  ['#', 'hash'],                        // Extract from the back.
	  ['?', 'query'],                       // Extract from the back.
	  ['/', 'pathname'],                    // Extract from the back.
	  ['@', 'auth', 1],                     // Extract from the front.
	  [NaN, 'host', undefined, 1, 1],       // Set left over value.
	  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
	  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
	];
	
	/**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase.
	 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	 * @property {String} rest Rest of the URL that is not part of the protocol.
	 */
	
	/**
	 * Extract protocol information from a URL with/without double slash ("//").
	 *
	 * @param {String} address URL we want to extract from.
	 * @return {ProtocolExtract} Extracted information.
	 * @api private
	 */
	function extractProtocol(address) {
	  var match = protocolre.exec(address);
	
	  return {
	    protocol: match[1] ? match[1].toLowerCase() : '',
	    slashes: !!match[2],
	    rest: match[3]
	  };
	}
	
	/**
	 * Resolve a relative URL pathname against a base URL pathname.
	 *
	 * @param {String} relative Pathname of the relative URL.
	 * @param {String} base Pathname of the base URL.
	 * @return {String} Resolved pathname.
	 * @api private
	 */
	function resolve(relative, base) {
	  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
	    , i = path.length
	    , last = path[i - 1]
	    , unshift = false
	    , up = 0;
	
	  while (i--) {
	    if (path[i] === '.') {
	      path.splice(i, 1);
	    } else if (path[i] === '..') {
	      path.splice(i, 1);
	      up++;
	    } else if (up) {
	      if (i === 0) unshift = true;
	      path.splice(i, 1);
	      up--;
	    }
	  }
	
	  if (unshift) path.unshift('');
	  if (last === '.' || last === '..') path.push('');
	
	  return path.join('/');
	}
	
	/**
	 * The actual URL instance. Instead of returning an object we've opted-in to
	 * create an actual constructor as it's much more memory efficient and
	 * faster and it pleases my OCD.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} location Location defaults for relative paths.
	 * @param {Boolean|Function} parser Parser for the query string.
	 * @api public
	 */
	function URL(address, location, parser) {
	  if (!(this instanceof URL)) {
	    return new URL(address, location, parser);
	  }
	
	  var relative, extracted, parse, instruction, index, key
	    , instructions = rules.slice()
	    , type = typeof location
	    , url = this
	    , i = 0;
	
	  //
	  // The following if statements allows this module two have compatibility with
	  // 2 different API:
	  //
	  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
	  //    where the boolean indicates that the query string should also be parsed.
	  //
	  // 2. The `URL` interface of the browser which accepts a URL, object as
	  //    arguments. The supplied object will be used as default values / fall-back
	  //    for relative paths.
	  //
	  if ('object' !== type && 'string' !== type) {
	    parser = location;
	    location = null;
	  }
	
	  if (parser && 'function' !== typeof parser) parser = qs.parse;
	
	  location = lolcation(location);
	
	  //
	  // Extract protocol information before running the instructions.
	  //
	  extracted = extractProtocol(address || '');
	  relative = !extracted.protocol && !extracted.slashes;
	  url.slashes = extracted.slashes || relative && location.slashes;
	  url.protocol = extracted.protocol || location.protocol || '';
	  address = extracted.rest;
	
	  //
	  // When the authority component is absent the URL starts with a path
	  // component.
	  //
	  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];
	
	  for (; i < instructions.length; i++) {
	    instruction = instructions[i];
	    parse = instruction[0];
	    key = instruction[1];
	
	    if (parse !== parse) {
	      url[key] = address;
	    } else if ('string' === typeof parse) {
	      if (~(index = address.indexOf(parse))) {
	        if ('number' === typeof instruction[2]) {
	          url[key] = address.slice(0, index);
	          address = address.slice(index + instruction[2]);
	        } else {
	          url[key] = address.slice(index);
	          address = address.slice(0, index);
	        }
	      }
	    } else if (index = parse.exec(address)) {
	      url[key] = index[1];
	      address = address.slice(0, index.index);
	    }
	
	    url[key] = url[key] || (
	      relative && instruction[3] ? location[key] || '' : ''
	    );
	
	    //
	    // Hostname, host and protocol should be lowercased so they can be used to
	    // create a proper `origin`.
	    //
	    if (instruction[4]) url[key] = url[key].toLowerCase();
	  }
	
	  //
	  // Also parse the supplied query string in to an object. If we're supplied
	  // with a custom parser as function use that instead of the default build-in
	  // parser.
	  //
	  if (parser) url.query = parser(url.query);
	
	  //
	  // If the URL is relative, resolve the pathname against the base URL.
	  //
	  if (
	      relative
	    && location.slashes
	    && url.pathname.charAt(0) !== '/'
	    && (url.pathname !== '' || location.pathname !== '')
	  ) {
	    url.pathname = resolve(url.pathname, location.pathname);
	  }
	
	  //
	  // We should not add port numbers if they are already the default port number
	  // for a given protocol. As the host also contains the port number we're going
	  // override it with the hostname which contains no port number.
	  //
	  if (!required(url.port, url.protocol)) {
	    url.host = url.hostname;
	    url.port = '';
	  }
	
	  //
	  // Parse down the `auth` for the username and password.
	  //
	  url.username = url.password = '';
	  if (url.auth) {
	    instruction = url.auth.split(':');
	    url.username = instruction[0] || '';
	    url.password = instruction[1] || '';
	  }
	
	  url.origin = url.protocol && url.host && url.protocol !== 'file:'
	    ? url.protocol +'//'+ url.host
	    : 'null';
	
	  //
	  // The href is just the compiled result.
	  //
	  url.href = url.toString();
	}
	
	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} part          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function
	 *                               used to parse the query.
	 *                               When setting the protocol, double slash will be
	 *                               removed from the final url if it is true.
	 * @returns {URL}
	 * @api public
	 */
	URL.prototype.set = function set(part, value, fn) {
	  var url = this;
	
	  switch (part) {
	    case 'query':
	      if ('string' === typeof value && value.length) {
	        value = (fn || qs.parse)(value);
	      }
	
	      url[part] = value;
	      break;
	
	    case 'port':
	      url[part] = value;
	
	      if (!required(value, url.protocol)) {
	        url.host = url.hostname;
	        url[part] = '';
	      } else if (value) {
	        url.host = url.hostname +':'+ value;
	      }
	
	      break;
	
	    case 'hostname':
	      url[part] = value;
	
	      if (url.port) value += ':'+ url.port;
	      url.host = value;
	      break;
	
	    case 'host':
	      url[part] = value;
	
	      if (/:\d+$/.test(value)) {
	        value = value.split(':');
	        url.port = value.pop();
	        url.hostname = value.join(':');
	      } else {
	        url.hostname = value;
	        url.port = '';
	      }
	
	      break;
	
	    case 'protocol':
	      url.protocol = value.toLowerCase();
	      url.slashes = !fn;
	      break;
	
	    case 'pathname':
	      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;
	
	      break;
	
	    default:
	      url[part] = value;
	  }
	
	  for (var i = 0; i < rules.length; i++) {
	    var ins = rules[i];
	
	    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
	  }
	
	  url.origin = url.protocol && url.host && url.protocol !== 'file:'
	    ? url.protocol +'//'+ url.host
	    : 'null';
	
	  url.href = url.toString();
	
	  return url;
	};
	
	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String}
	 * @api public
	 */
	URL.prototype.toString = function toString(stringify) {
	  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
	
	  var query
	    , url = this
	    , protocol = url.protocol;
	
	  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
	
	  var result = protocol + (url.slashes ? '//' : '');
	
	  if (url.username) {
	    result += url.username;
	    if (url.password) result += ':'+ url.password;
	    result += '@';
	  }
	
	  result += url.host + url.pathname;
	
	  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
	  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;
	
	  if (url.hash) result += url.hash;
	
	  return result;
	};
	
	//
	// Expose the URL parser and some additional properties that might be useful for
	// others or testing.
	//
	URL.extractProtocol = extractProtocol;
	URL.location = lolcation;
	URL.qs = qs;
	
	module.exports = URL;


/***/ },

/***/ "./node_modules/requires-port/index.js":
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Check if we're required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */
	module.exports = function required(port, protocol) {
	  protocol = protocol.split(':')[0];
	  port = +port;
	
	  if (!port) return false;
	
	  switch (protocol) {
	    case 'http':
	    case 'ws':
	    return port !== 80;
	
	    case 'https':
	    case 'wss':
	    return port !== 443;
	
	    case 'ftp':
	    return port !== 21;
	
	    case 'gopher':
	    return port !== 70;
	
	    case 'file':
	    return false;
	  }
	
	  return port !== 0;
	};


/***/ },

/***/ "./node_modules/url-parse/lolcation.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
	
	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL's as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */
	var ignore = { hash: 1, query: 1 }
	  , URL;
	
	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good "default"
	 * location from it so we can generate proper relative URL's again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @api public
	 */
	module.exports = function lolcation(loc) {
	  loc = loc || global.location || {};
	  URL = URL || __webpack_require__("./node_modules/url-parse/index.js");
	
	  var finaldestination = {}
	    , type = typeof loc
	    , key;
	
	  if ('blob:' === loc.protocol) {
	    finaldestination = new URL(unescape(loc.pathname), {});
	  } else if ('string' === type) {
	    finaldestination = new URL(loc, {});
	    for (key in ignore) delete finaldestination[key];
	  } else if ('object' === type) {
	    for (key in loc) {
	      if (key in ignore) continue;
	      finaldestination[key] = loc[key];
	    }
	
	    if (finaldestination.slashes === undefined) {
	      finaldestination.slashes = slashes.test(loc.href);
	    }
	  }
	
	  return finaldestination;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/querystringify/index.js":
/***/ function(module, exports) {

	'use strict';
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */
	function querystring(query) {
	  var parser = /([^=?&]+)=?([^&]*)/g
	    , result = {}
	    , part;
	
	  //
	  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
	  // the lastIndex property so we can continue executing this loop until we've
	  // parsed all results.
	  //
	  for (;
	    part = parser.exec(query);
	    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
	  );
	
	  return result;
	}
	
	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */
	function querystringify(obj, prefix) {
	  prefix = prefix || '';
	
	  var pairs = [];
	
	  //
	  // Optionally prefix with a '?' if needed
	  //
	  if ('string' !== typeof prefix) prefix = '?';
	
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
	    }
	  }
	
	  return pairs.length ? prefix + pairs.join('&') : '';
	}
	
	//
	// Expose the module.
	//
	exports.stringify = querystringify;
	exports.parse = querystring;


/***/ },

/***/ "./node_modules/debug/browser.js":
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__("./node_modules/debug/debug.js");
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },

/***/ "./node_modules/debug/debug.js":
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__("./node_modules/ms/index.js");
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },

/***/ "./node_modules/ms/index.js":
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },

/***/ "./node_modules/inherits/inherits_browser.js":
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },

/***/ "./node_modules/sockjs-client/lib/event/emitter.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventTarget = __webpack_require__("./node_modules/sockjs-client/lib/event/eventtarget.js")
	  ;
	
	function EventEmitter() {
	  EventTarget.call(this);
	}
	
	inherits(EventEmitter, EventTarget);
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  if (type) {
	    delete this._listeners[type];
	  } else {
	    this._listeners = {};
	  }
	};
	
	EventEmitter.prototype.once = function(type, listener) {
	  var self = this
	    , fired = false;
	
	  function g() {
	    self.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  this.on(type, g);
	};
	
	EventEmitter.prototype.emit = function() {
	  var type = arguments[0];
	  var listeners = this._listeners[type];
	  if (!listeners) {
	    return;
	  }
	  // equivalent of Array.prototype.slice.call(arguments, 1);
	  var l = arguments.length;
	  var args = new Array(l - 1);
	  for (var ai = 1; ai < l; ai++) {
	    args[ai - 1] = arguments[ai];
	  }
	  for (var i = 0; i < listeners.length; i++) {
	    listeners[i].apply(this, args);
	  }
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
	EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;
	
	module.exports.EventEmitter = EventEmitter;


/***/ },

/***/ "./node_modules/sockjs-client/lib/event/eventtarget.js":
/***/ function(module, exports) {

	'use strict';
	
	/* Simplified implementation of DOM2 EventTarget.
	 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
	 */
	
	function EventTarget() {
	  this._listeners = {};
	}
	
	EventTarget.prototype.addEventListener = function(eventType, listener) {
	  if (!(eventType in this._listeners)) {
	    this._listeners[eventType] = [];
	  }
	  var arr = this._listeners[eventType];
	  // #4
	  if (arr.indexOf(listener) === -1) {
	    // Make a copy so as not to interfere with a current dispatchEvent.
	    arr = arr.concat([listener]);
	  }
	  this._listeners[eventType] = arr;
	};
	
	EventTarget.prototype.removeEventListener = function(eventType, listener) {
	  var arr = this._listeners[eventType];
	  if (!arr) {
	    return;
	  }
	  var idx = arr.indexOf(listener);
	  if (idx !== -1) {
	    if (arr.length > 1) {
	      // Make a copy so as not to interfere with a current dispatchEvent.
	      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
	    } else {
	      delete this._listeners[eventType];
	    }
	    return;
	  }
	};
	
	EventTarget.prototype.dispatchEvent = function() {
	  var event = arguments[0];
	  var t = event.type;
	  // equivalent of Array.prototype.slice.call(arguments, 0);
	  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
	  // TODO: This doesn't match the real behavior; per spec, onfoo get
	  // their place in line from the /first/ time they're set from
	  // non-null. Although WebKit bumps it to the end every time it's
	  // set.
	  if (this['on' + t]) {
	    this['on' + t].apply(this, args);
	  }
	  if (t in this._listeners) {
	    // Grab a reference to the listeners list. removeEventListener may alter the list.
	    var listeners = this._listeners[t];
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	};
	
	module.exports = EventTarget;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/browser/websocket.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var Driver = global.WebSocket || global.MozWebSocket;
	if (Driver) {
		module.exports = function WebSocketBrowserDriver(url) {
			return new Driver(url);
		};
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/xhr-streaming.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , AjaxBasedTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/ajax-based.js")
	  , XhrReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/receiver/xhr.js")
	  , XHRCorsObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-cors.js")
	  , XHRLocalObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-local.js")
	  , browser = __webpack_require__("./node_modules/sockjs-client/lib/utils/browser.js")
	  ;
	
	function XhrStreamingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrStreamingTransport, AjaxBasedTransport);
	
	XhrStreamingTransport.enabled = function(info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	  // Opera doesn't support xhr-streaming #60
	  // But it might be able to #92
	  if (browser.isOpera()) {
	    return false;
	  }
	
	  return XHRCorsObject.enabled;
	};
	
	XhrStreamingTransport.transportName = 'xhr-streaming';
	XhrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	// Safari gets confused when a streaming ajax request is started
	// before onload. This causes the load indicator to spin indefinetely.
	// Only require body when used in a browser
	XhrStreamingTransport.needBody = !!global.document;
	
	module.exports = XhrStreamingTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/lib/ajax-based.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , SenderReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/sender-receiver.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:ajax-based');
	}
	
	function createAjaxSender(AjaxObject) {
	  return function(url, payload, callback) {
	    debug('create ajax sender', url, payload);
	    var opt = {};
	    if (typeof payload === 'string') {
	      opt.headers = {'Content-type': 'text/plain'};
	    }
	    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
	    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
	    xo.once('finish', function(status) {
	      debug('finish', status);
	      xo = null;
	
	      if (status !== 200 && status !== 204) {
	        return callback(new Error('http status ' + status));
	      }
	      callback();
	    });
	    return function() {
	      debug('abort');
	      xo.close();
	      xo = null;
	
	      var err = new Error('Aborted');
	      err.code = 1000;
	      callback(err);
	    };
	  };
	}
	
	function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
	  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
	}
	
	inherits(AjaxBasedTransport, SenderReceiver);
	
	module.exports = AjaxBasedTransport;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/lib/sender-receiver.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , BufferedSender = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/buffered-sender.js")
	  , Polling = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/polling.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:sender-receiver');
	}
	
	function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
	  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
	  debug(pollUrl);
	  var self = this;
	  BufferedSender.call(this, transUrl, senderFunc);
	
	  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
	  this.poll.on('message', function(msg) {
	    debug('poll message', msg);
	    self.emit('message', msg);
	  });
	  this.poll.once('close', function(code, reason) {
	    debug('poll close', code, reason);
	    self.poll = null;
	    self.emit('close', code, reason);
	    self.close();
	  });
	}
	
	inherits(SenderReceiver, BufferedSender);
	
	SenderReceiver.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  if (this.poll) {
	    this.poll.abort();
	    this.poll = null;
	  }
	  this.stop();
	};
	
	module.exports = SenderReceiver;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/lib/buffered-sender.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:buffered-sender');
	}
	
	function BufferedSender(url, sender) {
	  debug(url);
	  EventEmitter.call(this);
	  this.sendBuffer = [];
	  this.sender = sender;
	  this.url = url;
	}
	
	inherits(BufferedSender, EventEmitter);
	
	BufferedSender.prototype.send = function(message) {
	  debug('send', message);
	  this.sendBuffer.push(message);
	  if (!this.sendStop) {
	    this.sendSchedule();
	  }
	};
	
	// For polling transports in a situation when in the message callback,
	// new message is being send. If the sending connection was started
	// before receiving one, it is possible to saturate the network and
	// timeout due to the lack of receiving socket. To avoid that we delay
	// sending messages by some small time, in order to let receiving
	// connection be started beforehand. This is only a halfmeasure and
	// does not fix the big problem, but it does make the tests go more
	// stable on slow networks.
	BufferedSender.prototype.sendScheduleWait = function() {
	  debug('sendScheduleWait');
	  var self = this;
	  var tref;
	  this.sendStop = function() {
	    debug('sendStop');
	    self.sendStop = null;
	    clearTimeout(tref);
	  };
	  tref = setTimeout(function() {
	    debug('timeout');
	    self.sendStop = null;
	    self.sendSchedule();
	  }, 25);
	};
	
	BufferedSender.prototype.sendSchedule = function() {
	  debug('sendSchedule', this.sendBuffer.length);
	  var self = this;
	  if (this.sendBuffer.length > 0) {
	    var payload = '[' + this.sendBuffer.join(',') + ']';
	    this.sendStop = this.sender(this.url, payload, function(err) {
	      self.sendStop = null;
	      if (err) {
	        debug('error', err);
	        self.emit('close', err.code || 1006, 'Sending error: ' + err);
	        self._cleanup();
	      } else {
	        self.sendScheduleWait();
	      }
	    });
	    this.sendBuffer = [];
	  }
	};
	
	BufferedSender.prototype._cleanup = function() {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	BufferedSender.prototype.stop = function() {
	  debug('stop');
	  this._cleanup();
	  if (this.sendStop) {
	    this.sendStop();
	    this.sendStop = null;
	  }
	};
	
	module.exports = BufferedSender;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/lib/polling.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:polling');
	}
	
	function Polling(Receiver, receiveUrl, AjaxObject) {
	  debug(receiveUrl);
	  EventEmitter.call(this);
	  this.Receiver = Receiver;
	  this.receiveUrl = receiveUrl;
	  this.AjaxObject = AjaxObject;
	  this._scheduleReceiver();
	}
	
	inherits(Polling, EventEmitter);
	
	Polling.prototype._scheduleReceiver = function() {
	  debug('_scheduleReceiver');
	  var self = this;
	  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);
	
	  poll.on('message', function(msg) {
	    debug('message', msg);
	    self.emit('message', msg);
	  });
	
	  poll.once('close', function(code, reason) {
	    debug('close', code, reason, self.pollIsClosing);
	    self.poll = poll = null;
	
	    if (!self.pollIsClosing) {
	      if (reason === 'network') {
	        self._scheduleReceiver();
	      } else {
	        self.emit('close', code || 1006, reason);
	        self.removeAllListeners();
	      }
	    }
	  });
	};
	
	Polling.prototype.abort = function() {
	  debug('abort');
	  this.removeAllListeners();
	  this.pollIsClosing = true;
	  if (this.poll) {
	    this.poll.abort();
	  }
	};
	
	module.exports = Polling;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/receiver/xhr.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:receiver:xhr');
	}
	
	function XhrReceiver(url, AjaxObject) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	
	  this.bufferPosition = 0;
	
	  this.xo = new AjaxObject('POST', url, null);
	  this.xo.on('chunk', this._chunkHandler.bind(this));
	  this.xo.once('finish', function(status, text) {
	    debug('finish', status, text);
	    self._chunkHandler(status, text);
	    self.xo = null;
	    var reason = status === 200 ? 'network' : 'permanent';
	    debug('close', reason);
	    self.emit('close', null, reason);
	    self._cleanup();
	  });
	}
	
	inherits(XhrReceiver, EventEmitter);
	
	XhrReceiver.prototype._chunkHandler = function(status, text) {
	  debug('_chunkHandler', status);
	  if (status !== 200 || !text) {
	    return;
	  }
	
	  for (var idx = -1; ; this.bufferPosition += idx + 1) {
	    var buf = text.slice(this.bufferPosition);
	    idx = buf.indexOf('\n');
	    if (idx === -1) {
	      break;
	    }
	    var msg = buf.slice(0, idx);
	    if (msg) {
	      debug('message', msg);
	      this.emit('message', msg);
	    }
	  }
	};
	
	XhrReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	XhrReceiver.prototype.abort = function() {
	  debug('abort');
	  if (this.xo) {
	    this.xo.close();
	    debug('close');
	    this.emit('close', null, 'user');
	    this.xo = null;
	  }
	  this._cleanup();
	};
	
	module.exports = XhrReceiver;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/sender/xhr-cors.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , XhrDriver = __webpack_require__("./node_modules/sockjs-client/lib/transport/browser/abstract-xhr.js")
	  ;
	
	function XHRCorsObject(method, url, payload, opts) {
	  XhrDriver.call(this, method, url, payload, opts);
	}
	
	inherits(XHRCorsObject, XhrDriver);
	
	XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;
	
	module.exports = XHRCorsObject;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/browser/abstract-xhr.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , utils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , XHR = global.XMLHttpRequest
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:browser:xhr');
	}
	
	function AbstractXHRObject(method, url, payload, opts) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function () {
	    self._start(method, url, payload, opts);
	  }, 0);
	}
	
	inherits(AbstractXHRObject, EventEmitter);
	
	AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
	  var self = this;
	
	  try {
	    this.xhr = new XHR();
	  } catch (x) {
	    // intentionally empty
	  }
	
	  if (!this.xhr) {
	    debug('no xhr');
	    this.emit('finish', 0, 'no xhr support');
	    this._cleanup();
	    return;
	  }
	
	  // several browsers cache POSTs
	  url = urlUtils.addQuery(url, 't=' + (+new Date()));
	
	  // Explorer tends to keep connection open, even after the
	  // tab gets closed: http://bugs.jquery.com/ticket/5280
	  this.unloadRef = utils.unloadAdd(function() {
	    debug('unload cleanup');
	    self._cleanup(true);
	  });
	  try {
	    this.xhr.open(method, url, true);
	    if (this.timeout && 'timeout' in this.xhr) {
	      this.xhr.timeout = this.timeout;
	      this.xhr.ontimeout = function() {
	        debug('xhr timeout');
	        self.emit('finish', 0, '');
	        self._cleanup(false);
	      };
	    }
	  } catch (e) {
	    debug('exception', e);
	    // IE raises an exception on wrong port.
	    this.emit('finish', 0, '');
	    this._cleanup(false);
	    return;
	  }
	
	  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
	    debug('withCredentials');
	    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
	    // "This never affects same-site requests."
	
	    this.xhr.withCredentials = 'true';
	  }
	  if (opts && opts.headers) {
	    for (var key in opts.headers) {
	      this.xhr.setRequestHeader(key, opts.headers[key]);
	    }
	  }
	
	  this.xhr.onreadystatechange = function() {
	    if (self.xhr) {
	      var x = self.xhr;
	      var text, status;
	      debug('readyState', x.readyState);
	      switch (x.readyState) {
	      case 3:
	        // IE doesn't like peeking into responseText or status
	        // on Microsoft.XMLHTTP and readystate=3
	        try {
	          status = x.status;
	          text = x.responseText;
	        } catch (e) {
	          // intentionally empty
	        }
	        debug('status', status);
	        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	        if (status === 1223) {
	          status = 204;
	        }
	
	        // IE does return readystate == 3 for 404 answers.
	        if (status === 200 && text && text.length > 0) {
	          debug('chunk');
	          self.emit('chunk', status, text);
	        }
	        break;
	      case 4:
	        status = x.status;
	        debug('status', status);
	        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	        if (status === 1223) {
	          status = 204;
	        }
	        // IE returns this for a bad port
	        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
	        if (status === 12005 || status === 12029) {
	          status = 0;
	        }
	
	        debug('finish', status, x.responseText);
	        self.emit('finish', status, x.responseText);
	        self._cleanup(false);
	        break;
	      }
	    }
	  };
	
	  try {
	    self.xhr.send(payload);
	  } catch (e) {
	    self.emit('finish', 0, '');
	    self._cleanup(false);
	  }
	};
	
	AbstractXHRObject.prototype._cleanup = function(abort) {
	  debug('cleanup');
	  if (!this.xhr) {
	    return;
	  }
	  this.removeAllListeners();
	  utils.unloadDel(this.unloadRef);
	
	  // IE needs this field to be a function
	  this.xhr.onreadystatechange = function() {};
	  if (this.xhr.ontimeout) {
	    this.xhr.ontimeout = null;
	  }
	
	  if (abort) {
	    try {
	      this.xhr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xhr = null;
	};
	
	AbstractXHRObject.prototype.close = function() {
	  debug('close');
	  this._cleanup(true);
	};
	
	AbstractXHRObject.enabled = !!XHR;
	// override XMLHttpRequest for IE6/7
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (!AbstractXHRObject.enabled && (axo in global)) {
	  debug('overriding xmlhttprequest');
	  XHR = function() {
	    try {
	      return new global[axo]('Microsoft.XMLHTTP');
	    } catch (e) {
	      return null;
	    }
	  };
	  AbstractXHRObject.enabled = !!new XHR();
	}
	
	var cors = false;
	try {
	  cors = 'withCredentials' in new XHR();
	} catch (ignored) {
	  // intentionally empty
	}
	
	AbstractXHRObject.supportsCORS = cors;
	
	module.exports = AbstractXHRObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/sender/xhr-local.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , XhrDriver = __webpack_require__("./node_modules/sockjs-client/lib/transport/browser/abstract-xhr.js")
	  ;
	
	function XHRLocalObject(method, url, payload /*, opts */) {
	  XhrDriver.call(this, method, url, payload, {
	    noCredentials: true
	  });
	}
	
	inherits(XHRLocalObject, XhrDriver);
	
	XHRLocalObject.enabled = XhrDriver.enabled;
	
	module.exports = XHRLocalObject;


/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/browser.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = {
	  isOpera: function() {
	    return global.navigator &&
	      /opera/i.test(global.navigator.userAgent);
	  }
	
	, isKonqueror: function() {
	    return global.navigator &&
	      /konqueror/i.test(global.navigator.userAgent);
	  }
	
	  // #187 wrap document.domain in try/catch because of WP8 from file:///
	, hasDomain: function () {
	    // non-browser client always has a domain
	    if (!global.document) {
	      return true;
	    }
	
	    try {
	      return !!global.document.domain;
	    } catch (e) {
	      return false;
	    }
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/xdr-streaming.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , AjaxBasedTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/ajax-based.js")
	  , XhrReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/receiver/xhr.js")
	  , XDRObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xdr.js")
	  ;
	
	// According to:
	//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
	//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/
	
	function XdrStreamingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
	}
	
	inherits(XdrStreamingTransport, AjaxBasedTransport);
	
	XdrStreamingTransport.enabled = function(info) {
	  if (info.cookie_needed || info.nullOrigin) {
	    return false;
	  }
	  return XDRObject.enabled && info.sameScheme;
	};
	
	XdrStreamingTransport.transportName = 'xdr-streaming';
	XdrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrStreamingTransport;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/sender/xdr.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , eventUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , browser = __webpack_require__("./node_modules/sockjs-client/lib/utils/browser.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:sender:xdr');
	}
	
	// References:
	//   http://ajaxian.com/archives/100-line-ajax-wrapper
	//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
	
	function XDRObject(method, url, payload) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function() {
	    self._start(method, url, payload);
	  }, 0);
	}
	
	inherits(XDRObject, EventEmitter);
	
	XDRObject.prototype._start = function(method, url, payload) {
	  debug('_start');
	  var self = this;
	  var xdr = new global.XDomainRequest();
	  // IE caches even POSTs
	  url = urlUtils.addQuery(url, 't=' + (+new Date()));
	
	  xdr.onerror = function() {
	    debug('onerror');
	    self._error();
	  };
	  xdr.ontimeout = function() {
	    debug('ontimeout');
	    self._error();
	  };
	  xdr.onprogress = function() {
	    debug('progress', xdr.responseText);
	    self.emit('chunk', 200, xdr.responseText);
	  };
	  xdr.onload = function() {
	    debug('load');
	    self.emit('finish', 200, xdr.responseText);
	    self._cleanup(false);
	  };
	  this.xdr = xdr;
	  this.unloadRef = eventUtils.unloadAdd(function() {
	    self._cleanup(true);
	  });
	  try {
	    // Fails with AccessDenied if port number is bogus
	    this.xdr.open(method, url);
	    if (this.timeout) {
	      this.xdr.timeout = this.timeout;
	    }
	    this.xdr.send(payload);
	  } catch (x) {
	    this._error();
	  }
	};
	
	XDRObject.prototype._error = function() {
	  this.emit('finish', 0, '');
	  this._cleanup(false);
	};
	
	XDRObject.prototype._cleanup = function(abort) {
	  debug('cleanup', abort);
	  if (!this.xdr) {
	    return;
	  }
	  this.removeAllListeners();
	  eventUtils.unloadDel(this.unloadRef);
	
	  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
	  if (abort) {
	    try {
	      this.xdr.abort();
	    } catch (x) {
	      // intentionally empty
	    }
	  }
	  this.unloadRef = this.xdr = null;
	};
	
	XDRObject.prototype.close = function() {
	  debug('close');
	  this._cleanup(true);
	};
	
	// IE 8/9 if the request target uses the same scheme - #79
	XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());
	
	module.exports = XDRObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/eventsource.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , AjaxBasedTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/ajax-based.js")
	  , EventSourceReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/receiver/eventsource.js")
	  , XHRCorsObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-cors.js")
	  , EventSourceDriver = __webpack_require__("./node_modules/sockjs-client/lib/transport/browser/eventsource.js")
	  ;
	
	function EventSourceTransport(transUrl) {
	  if (!EventSourceTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
	}
	
	inherits(EventSourceTransport, AjaxBasedTransport);
	
	EventSourceTransport.enabled = function() {
	  return !!EventSourceDriver;
	};
	
	EventSourceTransport.transportName = 'eventsource';
	EventSourceTransport.roundTrips = 2;
	
	module.exports = EventSourceTransport;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/receiver/eventsource.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , EventSourceDriver = __webpack_require__("./node_modules/sockjs-client/lib/transport/browser/eventsource.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:receiver:eventsource');
	}
	
	function EventSourceReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	
	  var self = this;
	  var es = this.es = new EventSourceDriver(url);
	  es.onmessage = function(e) {
	    debug('message', e.data);
	    self.emit('message', decodeURI(e.data));
	  };
	  es.onerror = function(e) {
	    debug('error', es.readyState, e);
	    // ES on reconnection has readyState = 0 or 1.
	    // on network error it's CLOSED = 2
	    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
	    self._cleanup();
	    self._close(reason);
	  };
	}
	
	inherits(EventSourceReceiver, EventEmitter);
	
	EventSourceReceiver.prototype.abort = function() {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	EventSourceReceiver.prototype._cleanup = function() {
	  debug('cleanup');
	  var es = this.es;
	  if (es) {
	    es.onmessage = es.onerror = null;
	    es.close();
	    this.es = null;
	  }
	};
	
	EventSourceReceiver.prototype._close = function(reason) {
	  debug('close', reason);
	  var self = this;
	  // Safari and chrome < 15 crash if we close window before
	  // waiting for ES cleanup. See:
	  // https://code.google.com/p/chromium/issues/detail?id=89155
	  setTimeout(function() {
	    self.emit('close', null, reason);
	    self.removeAllListeners();
	  }, 200);
	};
	
	module.exports = EventSourceReceiver;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/browser/eventsource.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global.EventSource;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/lib/iframe-wrap.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , IframeTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/iframe.js")
	  , objectUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/object.js")
	  ;
	
	module.exports = function(transport) {
	
	  function IframeWrapTransport(transUrl, baseUrl) {
	    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
	  }
	
	  inherits(IframeWrapTransport, IframeTransport);
	
	  IframeWrapTransport.enabled = function(url, info) {
	    if (!global.document) {
	      return false;
	    }
	
	    var iframeInfo = objectUtils.extend({}, info);
	    iframeInfo.sameOrigin = true;
	    return transport.enabled(iframeInfo) && IframeTransport.enabled();
	  };
	
	  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
	  IframeWrapTransport.needBody = true;
	  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)
	
	  IframeWrapTransport.facadeTransport = transport;
	
	  return IframeWrapTransport;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/iframe.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// Few cool transports do work only for same-origin. In order to make
	// them work cross-domain we shall use iframe, served from the
	// remote domain. New browsers have capabilities to communicate with
	// cross domain iframe using postMessage(). In IE it was implemented
	// from IE 8+, but of course, IE got some details wrong:
	//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
	//    http://stevesouders.com/misc/test-postmessage.php
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , version = __webpack_require__("./node_modules/sockjs-client/lib/version.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , iframeUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/iframe.js")
	  , eventUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , random = __webpack_require__("./node_modules/sockjs-client/lib/utils/random.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:transport:iframe');
	}
	
	function IframeTransport(transport, transUrl, baseUrl) {
	  if (!IframeTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  EventEmitter.call(this);
	
	  var self = this;
	  this.origin = urlUtils.getOrigin(baseUrl);
	  this.baseUrl = baseUrl;
	  this.transUrl = transUrl;
	  this.transport = transport;
	  this.windowId = random.string(8);
	
	  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
	  debug(transport, transUrl, iframeUrl);
	
	  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
	    debug('err callback');
	    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
	    self.close();
	  });
	
	  this.onmessageCallback = this._message.bind(this);
	  eventUtils.attachEvent('message', this.onmessageCallback);
	}
	
	inherits(IframeTransport, EventEmitter);
	
	IframeTransport.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  if (this.iframeObj) {
	    eventUtils.detachEvent('message', this.onmessageCallback);
	    try {
	      // When the iframe is not loaded, IE raises an exception
	      // on 'contentWindow'.
	      this.postMessage('c');
	    } catch (x) {
	      // intentionally empty
	    }
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	    this.onmessageCallback = this.iframeObj = null;
	  }
	};
	
	IframeTransport.prototype._message = function(e) {
	  debug('message', e.data);
	  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
	    debug('not same origin', e.origin, this.origin);
	    return;
	  }
	
	  var iframeMessage;
	  try {
	    iframeMessage = JSON3.parse(e.data);
	  } catch (ignored) {
	    debug('bad json', e.data);
	    return;
	  }
	
	  if (iframeMessage.windowId !== this.windowId) {
	    debug('mismatched window id', iframeMessage.windowId, this.windowId);
	    return;
	  }
	
	  switch (iframeMessage.type) {
	  case 's':
	    this.iframeObj.loaded();
	    // window global dependency
	    this.postMessage('s', JSON3.stringify([
	      version
	    , this.transport
	    , this.transUrl
	    , this.baseUrl
	    ]));
	    break;
	  case 't':
	    this.emit('message', iframeMessage.data);
	    break;
	  case 'c':
	    var cdata;
	    try {
	      cdata = JSON3.parse(iframeMessage.data);
	    } catch (ignored) {
	      debug('bad json', iframeMessage.data);
	      return;
	    }
	    this.emit('close', cdata[0], cdata[1]);
	    this.close();
	    break;
	  }
	};
	
	IframeTransport.prototype.postMessage = function(type, data) {
	  debug('postMessage', type, data);
	  this.iframeObj.post(JSON3.stringify({
	    windowId: this.windowId
	  , type: type
	  , data: data || ''
	  }), this.origin);
	};
	
	IframeTransport.prototype.send = function(message) {
	  debug('send', message);
	  this.postMessage('m', message);
	};
	
	IframeTransport.enabled = function() {
	  return iframeUtils.iframeEnabled;
	};
	
	IframeTransport.transportName = 'iframe';
	IframeTransport.roundTrips = 2;
	
	module.exports = IframeTransport;


/***/ },

/***/ "./node_modules/json3/lib/json3.js":
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__("./node_modules/webpack/buildin/amd-options.js");
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), (function() { return this; }())))

/***/ },

/***/ "./node_modules/webpack/buildin/amd-options.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },

/***/ "./node_modules/sockjs-client/lib/version.js":
/***/ function(module, exports) {

	module.exports = '1.1.1';


/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/iframe.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var eventUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , browser = __webpack_require__("./node_modules/sockjs-client/lib/utils/browser.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:utils:iframe');
	}
	
	module.exports = {
	  WPrefix: '_jp'
	, currentWindowId: null
	
	, polluteGlobalNamespace: function() {
	    if (!(module.exports.WPrefix in global)) {
	      global[module.exports.WPrefix] = {};
	    }
	  }
	
	, postMessage: function(type, data) {
	    if (global.parent !== global) {
	      global.parent.postMessage(JSON3.stringify({
	        windowId: module.exports.currentWindowId
	      , type: type
	      , data: data || ''
	      }), '*');
	    } else {
	      debug('Cannot postMessage, no parent window.', type, data);
	    }
	  }
	
	, createIframe: function(iframeUrl, errorCallback) {
	    var iframe = global.document.createElement('iframe');
	    var tref, unloadRef;
	    var unattach = function() {
	      debug('unattach');
	      clearTimeout(tref);
	      // Explorer had problems with that.
	      try {
	        iframe.onload = null;
	      } catch (x) {
	        // intentionally empty
	      }
	      iframe.onerror = null;
	    };
	    var cleanup = function() {
	      debug('cleanup');
	      if (iframe) {
	        unattach();
	        // This timeout makes chrome fire onbeforeunload event
	        // within iframe. Without the timeout it goes straight to
	        // onunload.
	        setTimeout(function() {
	          if (iframe) {
	            iframe.parentNode.removeChild(iframe);
	          }
	          iframe = null;
	        }, 0);
	        eventUtils.unloadDel(unloadRef);
	      }
	    };
	    var onerror = function(err) {
	      debug('onerror', err);
	      if (iframe) {
	        cleanup();
	        errorCallback(err);
	      }
	    };
	    var post = function(msg, origin) {
	      debug('post', msg, origin);
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function() {
	          if (iframe && iframe.contentWindow) {
	            iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };
	
	    iframe.src = iframeUrl;
	    iframe.style.display = 'none';
	    iframe.style.position = 'absolute';
	    iframe.onerror = function() {
	      onerror('onerror');
	    };
	    iframe.onload = function() {
	      debug('onload');
	      // `onload` is triggered before scripts on the iframe are
	      // executed. Give it few seconds to actually load stuff.
	      clearTimeout(tref);
	      tref = setTimeout(function() {
	        onerror('onload timeout');
	      }, 2000);
	    };
	    global.document.body.appendChild(iframe);
	    tref = setTimeout(function() {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post
	    , cleanup: cleanup
	    , loaded: unattach
	    };
	  }
	
	/* jshint undef: false, newcap: false */
	/* eslint no-undef: 0, new-cap: 0 */
	, createHtmlfile: function(iframeUrl, errorCallback) {
	    var axo = ['Active'].concat('Object').join('X');
	    var doc = new global[axo]('htmlfile');
	    var tref, unloadRef;
	    var iframe;
	    var unattach = function() {
	      clearTimeout(tref);
	      iframe.onerror = null;
	    };
	    var cleanup = function() {
	      if (doc) {
	        unattach();
	        eventUtils.unloadDel(unloadRef);
	        iframe.parentNode.removeChild(iframe);
	        iframe = doc = null;
	        CollectGarbage();
	      }
	    };
	    var onerror = function(r) {
	      debug('onerror', r);
	      if (doc) {
	        cleanup();
	        errorCallback(r);
	      }
	    };
	    var post = function(msg, origin) {
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function() {
	          if (iframe && iframe.contentWindow) {
	              iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {
	        // intentionally empty
	      }
	    };
	
	    doc.open();
	    doc.write('<html><s' + 'cript>' +
	              'document.domain="' + global.document.domain + '";' +
	              '</s' + 'cript></html>');
	    doc.close();
	    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
	    var c = doc.createElement('div');
	    doc.body.appendChild(c);
	    iframe = doc.createElement('iframe');
	    c.appendChild(iframe);
	    iframe.src = iframeUrl;
	    iframe.onerror = function() {
	      onerror('onerror');
	    };
	    tref = setTimeout(function() {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post
	    , cleanup: cleanup
	    , loaded: unattach
	    };
	  }
	};
	
	module.exports.iframeEnabled = false;
	if (global.document) {
	  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
	  // huge delay, or not at all.
	  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
	    typeof global.postMessage === 'object') && (!browser.isKonqueror());
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/object.js":
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  isObject: function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  }
	
	, extend: function(obj) {
	    if (!this.isObject(obj)) {
	      return obj;
	    }
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	      source = arguments[i];
	      for (prop in source) {
	        if (Object.prototype.hasOwnProperty.call(source, prop)) {
	          obj[prop] = source[prop];
	        }
	      }
	    }
	    return obj;
	  }
	};


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/htmlfile.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , HtmlfileReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/receiver/htmlfile.js")
	  , XHRLocalObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-local.js")
	  , AjaxBasedTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/ajax-based.js")
	  ;
	
	function HtmlFileTransport(transUrl) {
	  if (!HtmlfileReceiver.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
	}
	
	inherits(HtmlFileTransport, AjaxBasedTransport);
	
	HtmlFileTransport.enabled = function(info) {
	  return HtmlfileReceiver.enabled && info.sameOrigin;
	};
	
	HtmlFileTransport.transportName = 'htmlfile';
	HtmlFileTransport.roundTrips = 2;
	
	module.exports = HtmlFileTransport;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/receiver/htmlfile.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , iframeUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/iframe.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , random = __webpack_require__("./node_modules/sockjs-client/lib/utils/random.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:receiver:htmlfile');
	}
	
	function HtmlfileReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	  iframeUtils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));
	
	  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
	  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
	      iframeUtils.createHtmlfile : iframeUtils.createIframe;
	
	  global[iframeUtils.WPrefix][this.id] = {
	    start: function() {
	      debug('start');
	      self.iframeObj.loaded();
	    }
	  , message: function(data) {
	      debug('message', data);
	      self.emit('message', data);
	    }
	  , stop: function() {
	      debug('stop');
	      self._cleanup();
	      self._close('network');
	    }
	  };
	  this.iframeObj = constructFunc(url, function() {
	    debug('callback');
	    self._cleanup();
	    self._close('permanent');
	  });
	}
	
	inherits(HtmlfileReceiver, EventEmitter);
	
	HtmlfileReceiver.prototype.abort = function() {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	HtmlfileReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  if (this.iframeObj) {
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	  }
	  delete global[iframeUtils.WPrefix][this.id];
	};
	
	HtmlfileReceiver.prototype._close = function(reason) {
	  debug('_close', reason);
	  this.emit('close', null, reason);
	  this.removeAllListeners();
	};
	
	HtmlfileReceiver.htmlfileEnabled = false;
	
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (axo in global) {
	  try {
	    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
	  } catch (x) {
	    // intentionally empty
	  }
	}
	
	HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;
	
	module.exports = HtmlfileReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/xhr-polling.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , AjaxBasedTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/ajax-based.js")
	  , XhrReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/receiver/xhr.js")
	  , XHRCorsObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-cors.js")
	  , XHRLocalObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-local.js")
	  ;
	
	function XhrPollingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrPollingTransport, AjaxBasedTransport);
	
	XhrPollingTransport.enabled = function(info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	
	  if (XHRLocalObject.enabled && info.sameOrigin) {
	    return true;
	  }
	  return XHRCorsObject.enabled;
	};
	
	XhrPollingTransport.transportName = 'xhr-polling';
	XhrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XhrPollingTransport;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/xdr-polling.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , AjaxBasedTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/ajax-based.js")
	  , XdrStreamingTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/xdr-streaming.js")
	  , XhrReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/receiver/xhr.js")
	  , XDRObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xdr.js")
	  ;
	
	function XdrPollingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
	}
	
	inherits(XdrPollingTransport, AjaxBasedTransport);
	
	XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
	XdrPollingTransport.transportName = 'xdr-polling';
	XdrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrPollingTransport;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/jsonp-polling.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// The simplest and most robust transport, using the well-know cross
	// domain hack - JSONP. This transport is quite inefficient - one
	// message could use up to one http request. But at least it works almost
	// everywhere.
	// Known limitations:
	//   o you will get a spinning cursor
	//   o for Konqueror a dumb timer is needed to detect errors
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , SenderReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/lib/sender-receiver.js")
	  , JsonpReceiver = __webpack_require__("./node_modules/sockjs-client/lib/transport/receiver/jsonp.js")
	  , jsonpSender = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/jsonp.js")
	  ;
	
	function JsonPTransport(transUrl) {
	  if (!JsonPTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
	}
	
	inherits(JsonPTransport, SenderReceiver);
	
	JsonPTransport.enabled = function() {
	  return !!global.document;
	};
	
	JsonPTransport.transportName = 'jsonp-polling';
	JsonPTransport.roundTrips = 1;
	JsonPTransport.needBody = true;
	
	module.exports = JsonPTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/receiver/jsonp.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var utils = __webpack_require__("./node_modules/sockjs-client/lib/utils/iframe.js")
	  , random = __webpack_require__("./node_modules/sockjs-client/lib/utils/random.js")
	  , browser = __webpack_require__("./node_modules/sockjs-client/lib/utils/browser.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:receiver:jsonp');
	}
	
	function JsonpReceiver(url) {
	  debug(url);
	  var self = this;
	  EventEmitter.call(this);
	
	  utils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));
	
	  global[utils.WPrefix][this.id] = this._callback.bind(this);
	  this._createScript(urlWithId);
	
	  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
	  this.timeoutId = setTimeout(function() {
	    debug('timeout');
	    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
	  }, JsonpReceiver.timeout);
	}
	
	inherits(JsonpReceiver, EventEmitter);
	
	JsonpReceiver.prototype.abort = function() {
	  debug('abort');
	  if (global[utils.WPrefix][this.id]) {
	    var err = new Error('JSONP user aborted read');
	    err.code = 1000;
	    this._abort(err);
	  }
	};
	
	JsonpReceiver.timeout = 35000;
	JsonpReceiver.scriptErrorTimeout = 1000;
	
	JsonpReceiver.prototype._callback = function(data) {
	  debug('_callback', data);
	  this._cleanup();
	
	  if (this.aborting) {
	    return;
	  }
	
	  if (data) {
	    debug('message', data);
	    this.emit('message', data);
	  }
	  this.emit('close', null, 'network');
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._abort = function(err) {
	  debug('_abort', err);
	  this._cleanup();
	  this.aborting = true;
	  this.emit('close', err.code, err.message);
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  clearTimeout(this.timeoutId);
	  if (this.script2) {
	    this.script2.parentNode.removeChild(this.script2);
	    this.script2 = null;
	  }
	  if (this.script) {
	    var script = this.script;
	    // Unfortunately, you can't really abort script loading of
	    // the script.
	    script.parentNode.removeChild(script);
	    script.onreadystatechange = script.onerror =
	        script.onload = script.onclick = null;
	    this.script = null;
	  }
	  delete global[utils.WPrefix][this.id];
	};
	
	JsonpReceiver.prototype._scriptError = function() {
	  debug('_scriptError');
	  var self = this;
	  if (this.errorTimer) {
	    return;
	  }
	
	  this.errorTimer = setTimeout(function() {
	    if (!self.loadedOkay) {
	      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
	    }
	  }, JsonpReceiver.scriptErrorTimeout);
	};
	
	JsonpReceiver.prototype._createScript = function(url) {
	  debug('_createScript', url);
	  var self = this;
	  var script = this.script = global.document.createElement('script');
	  var script2;  // Opera synchronous load trick.
	
	  script.id = 'a' + random.string(8);
	  script.src = url;
	  script.type = 'text/javascript';
	  script.charset = 'UTF-8';
	  script.onerror = this._scriptError.bind(this);
	  script.onload = function() {
	    debug('onload');
	    self._abort(new Error('JSONP script loaded abnormally (onload)'));
	  };
	
	  // IE9 fires 'error' event after onreadystatechange or before, in random order.
	  // Use loadedOkay to determine if actually errored
	  script.onreadystatechange = function() {
	    debug('onreadystatechange', script.readyState);
	    if (/loaded|closed/.test(script.readyState)) {
	      if (script && script.htmlFor && script.onclick) {
	        self.loadedOkay = true;
	        try {
	          // In IE, actually execute the script.
	          script.onclick();
	        } catch (x) {
	          // intentionally empty
	        }
	      }
	      if (script) {
	        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
	      }
	    }
	  };
	  // IE: event/htmlFor/onclick trick.
	  // One can't rely on proper order for onreadystatechange. In order to
	  // make sure, set a 'htmlFor' and 'event' properties, so that
	  // script code will be installed as 'onclick' handler for the
	  // script object. Later, onreadystatechange, manually execute this
	  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
	  // set. For reference see:
	  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
	  // Also, read on that about script ordering:
	  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
	  if (typeof script.async === 'undefined' && global.document.attachEvent) {
	    // According to mozilla docs, in recent browsers script.async defaults
	    // to 'true', so we may use it to detect a good browser:
	    // https://developer.mozilla.org/en/HTML/Element/script
	    if (!browser.isOpera()) {
	      // Naively assume we're in IE
	      try {
	        script.htmlFor = script.id;
	        script.event = 'onclick';
	      } catch (x) {
	        // intentionally empty
	      }
	      script.async = true;
	    } else {
	      // Opera, second sync script hack
	      script2 = this.script2 = global.document.createElement('script');
	      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
	      script.async = script2.async = false;
	    }
	  }
	  if (typeof script.async !== 'undefined') {
	    script.async = true;
	  }
	
	  var head = global.document.getElementsByTagName('head')[0];
	  head.insertBefore(script, head.firstChild);
	  if (script2) {
	    head.insertBefore(script2, head.firstChild);
	  }
	};
	
	module.exports = JsonpReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/sender/jsonp.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var random = __webpack_require__("./node_modules/sockjs-client/lib/utils/random.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:sender:jsonp');
	}
	
	var form, area;
	
	function createIframe(id) {
	  debug('createIframe', id);
	  try {
	    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	    return global.document.createElement('<iframe name="' + id + '">');
	  } catch (x) {
	    var iframe = global.document.createElement('iframe');
	    iframe.name = id;
	    return iframe;
	  }
	}
	
	function createForm() {
	  debug('createForm');
	  form = global.document.createElement('form');
	  form.style.display = 'none';
	  form.style.position = 'absolute';
	  form.method = 'POST';
	  form.enctype = 'application/x-www-form-urlencoded';
	  form.acceptCharset = 'UTF-8';
	
	  area = global.document.createElement('textarea');
	  area.name = 'd';
	  form.appendChild(area);
	
	  global.document.body.appendChild(form);
	}
	
	module.exports = function(url, payload, callback) {
	  debug(url, payload);
	  if (!form) {
	    createForm();
	  }
	  var id = 'a' + random.string(8);
	  form.target = id;
	  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);
	
	  var iframe = createIframe(id);
	  iframe.id = id;
	  iframe.style.display = 'none';
	  form.appendChild(iframe);
	
	  try {
	    area.value = payload;
	  } catch (e) {
	    // seriously broken browsers get here
	  }
	  form.submit();
	
	  var completed = function(err) {
	    debug('completed', id, err);
	    if (!iframe.onerror) {
	      return;
	    }
	    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
	    // Opera mini doesn't like if we GC iframe
	    // immediately, thus this timeout.
	    setTimeout(function() {
	      debug('cleaning up', id);
	      iframe.parentNode.removeChild(iframe);
	      iframe = null;
	    }, 500);
	    area.value = '';
	    // It is not possible to detect if the iframe succeeded or
	    // failed to submit our form.
	    callback(err);
	  };
	  iframe.onerror = function() {
	    debug('onerror', id);
	    completed();
	  };
	  iframe.onload = function() {
	    debug('onload', id);
	    completed();
	  };
	  iframe.onreadystatechange = function(e) {
	    debug('onreadystatechange', id, iframe.readyState, e);
	    if (iframe.readyState === 'complete') {
	      completed();
	    }
	  };
	  return function() {
	    debug('aborted', id);
	    completed(new Error('Aborted'));
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/main.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	__webpack_require__("./node_modules/sockjs-client/lib/shims.js");
	
	var URL = __webpack_require__("./node_modules/url-parse/index.js")
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , random = __webpack_require__("./node_modules/sockjs-client/lib/utils/random.js")
	  , escape = __webpack_require__("./node_modules/sockjs-client/lib/utils/escape.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , eventUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , transport = __webpack_require__("./node_modules/sockjs-client/lib/utils/transport.js")
	  , objectUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/object.js")
	  , browser = __webpack_require__("./node_modules/sockjs-client/lib/utils/browser.js")
	  , log = __webpack_require__("./node_modules/sockjs-client/lib/utils/log.js")
	  , Event = __webpack_require__("./node_modules/sockjs-client/lib/event/event.js")
	  , EventTarget = __webpack_require__("./node_modules/sockjs-client/lib/event/eventtarget.js")
	  , loc = __webpack_require__("./node_modules/sockjs-client/lib/location.js")
	  , CloseEvent = __webpack_require__("./node_modules/sockjs-client/lib/event/close.js")
	  , TransportMessageEvent = __webpack_require__("./node_modules/sockjs-client/lib/event/trans-message.js")
	  , InfoReceiver = __webpack_require__("./node_modules/sockjs-client/lib/info-receiver.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:main');
	}
	
	var transports;
	
	// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
	function SockJS(url, protocols, options) {
	  if (!(this instanceof SockJS)) {
	    return new SockJS(url, protocols, options);
	  }
	  if (arguments.length < 1) {
	    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
	  }
	  EventTarget.call(this);
	
	  this.readyState = SockJS.CONNECTING;
	  this.extensions = '';
	  this.protocol = '';
	
	  // non-standard extension
	  options = options || {};
	  if (options.protocols_whitelist) {
	    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
	  }
	  this._transportsWhitelist = options.transports;
	  this._transportOptions = options.transportOptions || {};
	
	  var sessionId = options.sessionId || 8;
	  if (typeof sessionId === 'function') {
	    this._generateSessionId = sessionId;
	  } else if (typeof sessionId === 'number') {
	    this._generateSessionId = function() {
	      return random.string(sessionId);
	    };
	  } else {
	    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
	  }
	
	  this._server = options.server || random.numberString(1000);
	
	  // Step 1 of WS spec - parse and validate the url. Issue #8
	  var parsedUrl = new URL(url);
	  if (!parsedUrl.host || !parsedUrl.protocol) {
	    throw new SyntaxError("The URL '" + url + "' is invalid");
	  } else if (parsedUrl.hash) {
	    throw new SyntaxError('The URL must not contain a fragment');
	  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
	    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
	  }
	
	  var secure = parsedUrl.protocol === 'https:';
	  // Step 2 - don't allow secure origin with an insecure protocol
	  if (loc.protocol === 'https' && !secure) {
	    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
	  }
	
	  // Step 3 - check port access - no need here
	  // Step 4 - parse protocols argument
	  if (!protocols) {
	    protocols = [];
	  } else if (!Array.isArray(protocols)) {
	    protocols = [protocols];
	  }
	
	  // Step 5 - check protocols argument
	  var sortedProtocols = protocols.sort();
	  sortedProtocols.forEach(function(proto, i) {
	    if (!proto) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
	    }
	    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
	    }
	  });
	
	  // Step 6 - convert origin
	  var o = urlUtils.getOrigin(loc.href);
	  this._origin = o ? o.toLowerCase() : null;
	
	  // remove the trailing slash
	  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));
	
	  // store the sanitized url
	  this.url = parsedUrl.href;
	  debug('using url', this.url);
	
	  // Step 7 - start connection in background
	  // obtain server info
	  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
	  this._urlInfo = {
	    nullOrigin: !browser.hasDomain()
	  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
	  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
	  };
	
	  this._ir = new InfoReceiver(this.url, this._urlInfo);
	  this._ir.once('finish', this._receiveInfo.bind(this));
	}
	
	inherits(SockJS, EventTarget);
	
	function userSetCode(code) {
	  return code === 1000 || (code >= 3000 && code <= 4999);
	}
	
	SockJS.prototype.close = function(code, reason) {
	  // Step 1
	  if (code && !userSetCode(code)) {
	    throw new Error('InvalidAccessError: Invalid code');
	  }
	  // Step 2.4 states the max is 123 bytes, but we are just checking length
	  if (reason && reason.length > 123) {
	    throw new SyntaxError('reason argument has an invalid length');
	  }
	
	  // Step 3.1
	  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
	    return;
	  }
	
	  // TODO look at docs to determine how to set this
	  var wasClean = true;
	  this._close(code || 1000, reason || 'Normal closure', wasClean);
	};
	
	SockJS.prototype.send = function(data) {
	  // #13 - convert anything non-string to string
	  // TODO this currently turns objects into [object Object]
	  if (typeof data !== 'string') {
	    data = '' + data;
	  }
	  if (this.readyState === SockJS.CONNECTING) {
	    throw new Error('InvalidStateError: The connection has not been established yet');
	  }
	  if (this.readyState !== SockJS.OPEN) {
	    return;
	  }
	  this._transport.send(escape.quote(data));
	};
	
	SockJS.version = __webpack_require__("./node_modules/sockjs-client/lib/version.js");
	
	SockJS.CONNECTING = 0;
	SockJS.OPEN = 1;
	SockJS.CLOSING = 2;
	SockJS.CLOSED = 3;
	
	SockJS.prototype._receiveInfo = function(info, rtt) {
	  debug('_receiveInfo', rtt);
	  this._ir = null;
	  if (!info) {
	    this._close(1002, 'Cannot connect to server');
	    return;
	  }
	
	  // establish a round-trip timeout (RTO) based on the
	  // round-trip time (RTT)
	  this._rto = this.countRTO(rtt);
	  // allow server to override url used for the actual transport
	  this._transUrl = info.base_url ? info.base_url : this.url;
	  info = objectUtils.extend(info, this._urlInfo);
	  debug('info', info);
	  // determine list of desired and supported transports
	  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
	  this._transports = enabledTransports.main;
	  debug(this._transports.length + ' enabled transports');
	
	  this._connect();
	};
	
	SockJS.prototype._connect = function() {
	  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
	    debug('attempt', Transport.transportName);
	    if (Transport.needBody) {
	      if (!global.document.body ||
	          (typeof global.document.readyState !== 'undefined' &&
	            global.document.readyState !== 'complete' &&
	            global.document.readyState !== 'interactive')) {
	        debug('waiting for body');
	        this._transports.unshift(Transport);
	        eventUtils.attachEvent('load', this._connect.bind(this));
	        return;
	      }
	    }
	
	    // calculate timeout based on RTO and round trips. Default to 5s
	    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
	    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
	    debug('using timeout', timeoutMs);
	
	    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
	    var options = this._transportOptions[Transport.transportName];
	    debug('transport url', transportUrl);
	    var transportObj = new Transport(transportUrl, this._transUrl, options);
	    transportObj.on('message', this._transportMessage.bind(this));
	    transportObj.once('close', this._transportClose.bind(this));
	    transportObj.transportName = Transport.transportName;
	    this._transport = transportObj;
	
	    return;
	  }
	  this._close(2000, 'All transports failed', false);
	};
	
	SockJS.prototype._transportTimeout = function() {
	  debug('_transportTimeout');
	  if (this.readyState === SockJS.CONNECTING) {
	    this._transportClose(2007, 'Transport timed out');
	  }
	};
	
	SockJS.prototype._transportMessage = function(msg) {
	  debug('_transportMessage', msg);
	  var self = this
	    , type = msg.slice(0, 1)
	    , content = msg.slice(1)
	    , payload
	    ;
	
	  // first check for messages that don't need a payload
	  switch (type) {
	    case 'o':
	      this._open();
	      return;
	    case 'h':
	      this.dispatchEvent(new Event('heartbeat'));
	      debug('heartbeat', this.transport);
	      return;
	  }
	
	  if (content) {
	    try {
	      payload = JSON3.parse(content);
	    } catch (e) {
	      debug('bad json', content);
	    }
	  }
	
	  if (typeof payload === 'undefined') {
	    debug('empty payload', content);
	    return;
	  }
	
	  switch (type) {
	    case 'a':
	      if (Array.isArray(payload)) {
	        payload.forEach(function(p) {
	          debug('message', self.transport, p);
	          self.dispatchEvent(new TransportMessageEvent(p));
	        });
	      }
	      break;
	    case 'm':
	      debug('message', this.transport, payload);
	      this.dispatchEvent(new TransportMessageEvent(payload));
	      break;
	    case 'c':
	      if (Array.isArray(payload) && payload.length === 2) {
	        this._close(payload[0], payload[1], true);
	      }
	      break;
	  }
	};
	
	SockJS.prototype._transportClose = function(code, reason) {
	  debug('_transportClose', this.transport, code, reason);
	  if (this._transport) {
	    this._transport.removeAllListeners();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
	    this._connect();
	    return;
	  }
	
	  this._close(code, reason);
	};
	
	SockJS.prototype._open = function() {
	  debug('_open', this._transport.transportName, this.readyState);
	  if (this.readyState === SockJS.CONNECTING) {
	    if (this._transportTimeoutId) {
	      clearTimeout(this._transportTimeoutId);
	      this._transportTimeoutId = null;
	    }
	    this.readyState = SockJS.OPEN;
	    this.transport = this._transport.transportName;
	    this.dispatchEvent(new Event('open'));
	    debug('connected', this.transport);
	  } else {
	    // The server might have been restarted, and lost track of our
	    // connection.
	    this._close(1006, 'Server lost session');
	  }
	};
	
	SockJS.prototype._close = function(code, reason, wasClean) {
	  debug('_close', this.transport, code, reason, wasClean, this.readyState);
	  var forceFail = false;
	
	  if (this._ir) {
	    forceFail = true;
	    this._ir.close();
	    this._ir = null;
	  }
	  if (this._transport) {
	    this._transport.close();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (this.readyState === SockJS.CLOSED) {
	    throw new Error('InvalidStateError: SockJS has already been closed');
	  }
	
	  this.readyState = SockJS.CLOSING;
	  setTimeout(function() {
	    this.readyState = SockJS.CLOSED;
	
	    if (forceFail) {
	      this.dispatchEvent(new Event('error'));
	    }
	
	    var e = new CloseEvent('close');
	    e.wasClean = wasClean || false;
	    e.code = code || 1000;
	    e.reason = reason;
	
	    this.dispatchEvent(e);
	    this.onmessage = this.onclose = this.onerror = null;
	    debug('disconnected');
	  }.bind(this), 0);
	};
	
	// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
	// and RFC 2988.
	SockJS.prototype.countRTO = function(rtt) {
	  // In a local environment, when using IE8/9 and the `jsonp-polling`
	  // transport the time needed to establish a connection (the time that pass
	  // from the opening of the transport to the call of `_dispatchOpen`) is
	  // around 200msec (the lower bound used in the article above) and this
	  // causes spurious timeouts. For this reason we calculate a value slightly
	  // larger than that used in the article.
	  if (rtt > 100) {
	    return 4 * rtt; // rto > 400msec
	  }
	  return 300 + rtt; // 300msec < rto <= 400msec
	};
	
	module.exports = function(availableTransports) {
	  transports = transport(availableTransports);
	  __webpack_require__("./node_modules/sockjs-client/lib/iframe-bootstrap.js")(SockJS, availableTransports);
	  return SockJS;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/shims.js":
/***/ function(module, exports) {

	/* eslint-disable */
	/* jscs: disable */
	'use strict';
	
	// pulled specific shims from https://github.com/es-shims/es5-shim
	
	var ArrayPrototype = Array.prototype;
	var ObjectPrototype = Object.prototype;
	var FunctionPrototype = Function.prototype;
	var StringPrototype = String.prototype;
	var array_slice = ArrayPrototype.slice;
	
	var _toString = ObjectPrototype.toString;
	var isFunction = function (val) {
	    return ObjectPrototype.toString.call(val) === '[object Function]';
	};
	var isArray = function isArray(obj) {
	    return _toString.call(obj) === '[object Array]';
	};
	var isString = function isString(obj) {
	    return _toString.call(obj) === '[object String]';
	};
	
	var supportsDescriptors = Object.defineProperty && (function () {
	    try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	    } catch (e) { /* this is ES3 */
	        return false;
	    }
	}());
	
	// Define configurable, writable and non-enumerable props
	// if they don't exist.
	var defineProperty;
	if (supportsDescriptors) {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        Object.defineProperty(object, name, {
	            configurable: true,
	            enumerable: false,
	            writable: true,
	            value: method
	        });
	    };
	} else {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        object[name] = method;
	    };
	}
	var defineProperties = function (object, map, forceAssign) {
	    for (var name in map) {
	        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
	          defineProperty(object, name, map[name], forceAssign);
	        }
	    }
	};
	
	var toObject = function (o) {
	    if (o == null) { // this matches both null and undefined
	        throw new TypeError("can't convert " + o + ' to object');
	    }
	    return Object(o);
	};
	
	//
	// Util
	// ======
	//
	
	// ES5 9.4
	// http://es5.github.com/#x9.4
	// http://jsperf.com/to-integer
	
	function toInteger(num) {
	    var n = +num;
	    if (n !== n) { // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}
	
	function ToUint32(x) {
	    return x >>> 0;
	}
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	function Empty() {}
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) { // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isFunction(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var binder = function () {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(
	                    this,
	                    args.concat(array_slice.call(arguments))
	                );
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;
	
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(
	                    that,
	                    args.concat(array_slice.call(arguments))
	                );
	
	            }
	
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = Math.max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            boundArgs.push('$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	//
	// Array
	// =====
	//
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties(Array, { isArray: isArray });
	
	
	var boxedString = Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
	        });
	
	        method.call([1], function () {
	            'use strict';
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(); // TODO message
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                // context
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(sought /*, fromIndex */ ) {
	        var self = splitString && isString(this) ? this.split('') : toObject(this),
	            length = self.length >>> 0;
	
	        if (!length) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	var string_split = StringPrototype.split;
	if (
	    'ab'.split(/(?:ab)*/).length !== 2 ||
	    '.'.split(/(.?)(.?)/).length !== 4 ||
	    'tesst'.split(/(s)*/)[1] === 't' ||
	    'test'.split(/(?:)/, -1).length !== 4 ||
	    ''.split(/.?/).length ||
	    '.'.split(/()()/).length > 1
	) {
	    (function () {
	        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group
	
	        StringPrototype.split = function (separator, limit) {
	            var string = this;
	            if (separator === void 0 && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (_toString.call(separator) !== '[object RegExp]') {
	                return string_split.call(this, separator, limit);
	            }
	
	            var output = [],
	                flags = (separator.ignoreCase ? 'i' : '') +
	                        (separator.multiline  ? 'm' : '') +
	                        (separator.extended   ? 'x' : '') + // Proposed for ES6
	                        (separator.sticky     ? 'y' : ''), // Firefox 3+
	                lastLastIndex = 0,
	                // Make `global` and avoid `lastIndex` issues by working with a copy
	                separator2, match, lastIndex, lastLength;
	            separator = new RegExp(separator.source, flags + 'g');
	            string += ''; // Type-convert
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // Math.pow(2, 32) - 1
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            limit = limit === void 0 ?
	                -1 >>> 0 : // Math.pow(2, 32) - 1
	                ToUint32(limit);
	            while (match = separator.exec(string)) {
	                // `separator.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    output.push(string.slice(lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (arguments[i] === void 0) {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        ArrayPrototype.push.apply(output, match.slice(1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= limit) {
	                        break;
	                    }
	                }
	                if (separator.lastIndex === match.index) {
	                    separator.lastIndex++; // Avoid an infinite loop
	                }
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separator.test('')) {
	                    output.push('');
	                }
	            } else {
	                output.push(string.slice(lastLastIndex));
	            }
	            return output.length > limit ? output.slice(0, limit) : output;
	        };
	    }());
	
	// [bugfix, chrome]
	// If separator is undefined, then the result array contains just one String,
	// which is the this value (converted to a String). If limit is not undefined,
	// then the output array is truncated so that it contains no more than limit
	// elements.
	// "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (separator === void 0 && limit === 0) { return []; }
	        return string_split.call(this, separator, limit);
	    };
	}
	
	// ES5 15.5.4.20
	// whitespace from: http://es5.github.io/#x15.5.4.20
	var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
	    '\u2029\uFEFF';
	var zeroWidth = '\u200b';
	var wsRegexChars = '[' + ws + ']';
	var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
	var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
	var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
	defineProperties(StringPrototype, {
	    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
	    // http://perfectionkills.com/whitespace-deviations/
	    trim: function trim() {
	        if (this === void 0 || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
	    }
	}, hasTrimWhitespaceBug);
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        return string_substr.call(
	            this,
	            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
	            length
	        );
	    }
	}, hasNegativeSubstrBug);


/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/escape.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js");
	
	// Some extra characters that Chrome gets wrong, and substitutes with
	// something else on the wire.
	var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
	  , extraLookup;
	
	// This may be quite slow, so let's delay until user actually uses bad
	// characters.
	var unrollLookup = function(escapable) {
	  var i;
	  var unrolled = {};
	  var c = [];
	  for (i = 0; i < 65536; i++) {
	    c.push( String.fromCharCode(i) );
	  }
	  escapable.lastIndex = 0;
	  c.join('').replace(escapable, function(a) {
	    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    return '';
	  });
	  escapable.lastIndex = 0;
	  return unrolled;
	};
	
	// Quote string, also taking care of unicode characters that browsers
	// often break. Especially, take care of unicode surrogates:
	// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
	module.exports = {
	  quote: function(string) {
	    var quoted = JSON3.stringify(string);
	
	    // In most cases this should be very fast and good enough.
	    extraEscapable.lastIndex = 0;
	    if (!extraEscapable.test(quoted)) {
	      return quoted;
	    }
	
	    if (!extraLookup) {
	      extraLookup = unrollLookup(extraEscapable);
	    }
	
	    return quoted.replace(extraEscapable, function(a) {
	      return extraLookup[a];
	    });
	  }
	};


/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/transport.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:utils:transport');
	}
	
	module.exports = function(availableTransports) {
	  return {
	    filterToEnabled: function(transportsWhitelist, info) {
	      var transports = {
	        main: []
	      , facade: []
	      };
	      if (!transportsWhitelist) {
	        transportsWhitelist = [];
	      } else if (typeof transportsWhitelist === 'string') {
	        transportsWhitelist = [transportsWhitelist];
	      }
	
	      availableTransports.forEach(function(trans) {
	        if (!trans) {
	          return;
	        }
	
	        if (trans.transportName === 'websocket' && info.websocket === false) {
	          debug('disabled from server', 'websocket');
	          return;
	        }
	
	        if (transportsWhitelist.length &&
	            transportsWhitelist.indexOf(trans.transportName) === -1) {
	          debug('not in whitelist', trans.transportName);
	          return;
	        }
	
	        if (trans.enabled(info)) {
	          debug('enabled', trans.transportName);
	          transports.main.push(trans);
	          if (trans.facadeTransport) {
	            transports.facade.push(trans.facadeTransport);
	          }
	        } else {
	          debug('disabled', trans.transportName);
	        }
	      });
	      return transports;
	    }
	  };
	};


/***/ },

/***/ "./node_modules/sockjs-client/lib/utils/log.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var logObject = {};
	['log', 'debug', 'warn'].forEach(function (level) {
	  var levelExists;
	
	  try {
	    levelExists = global.console && global.console[level] && global.console[level].apply;
	  } catch(e) {
	    // do nothing
	  }
	
	  logObject[level] = levelExists ? function () {
	    return global.console[level].apply(global.console, arguments);
	  } : (level === 'log' ? function () {} : logObject.log);
	});
	
	module.exports = logObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/event/event.js":
/***/ function(module, exports) {

	'use strict';
	
	function Event(eventType) {
	  this.type = eventType;
	}
	
	Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
	  this.type = eventType;
	  this.bubbles = canBubble;
	  this.cancelable = cancelable;
	  this.timeStamp = +new Date();
	  return this;
	};
	
	Event.prototype.stopPropagation = function() {};
	Event.prototype.preventDefault = function() {};
	
	Event.CAPTURING_PHASE = 1;
	Event.AT_TARGET = 2;
	Event.BUBBLING_PHASE = 3;
	
	module.exports = Event;


/***/ },

/***/ "./node_modules/sockjs-client/lib/location.js":
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = global.location || {
	  origin: 'http://localhost:80'
	, protocol: 'http'
	, host: 'localhost'
	, port: 80
	, href: 'http://localhost/'
	, hash: ''
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/event/close.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , Event = __webpack_require__("./node_modules/sockjs-client/lib/event/event.js")
	  ;
	
	function CloseEvent() {
	  Event.call(this);
	  this.initEvent('close', false, false);
	  this.wasClean = false;
	  this.code = 0;
	  this.reason = '';
	}
	
	inherits(CloseEvent, Event);
	
	module.exports = CloseEvent;


/***/ },

/***/ "./node_modules/sockjs-client/lib/event/trans-message.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , Event = __webpack_require__("./node_modules/sockjs-client/lib/event/event.js")
	  ;
	
	function TransportMessageEvent(data) {
	  Event.call(this);
	  this.initEvent('message', false, false);
	  this.data = data;
	}
	
	inherits(TransportMessageEvent, Event);
	
	module.exports = TransportMessageEvent;


/***/ },

/***/ "./node_modules/sockjs-client/lib/info-receiver.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , XDR = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xdr.js")
	  , XHRCors = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-cors.js")
	  , XHRLocal = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-local.js")
	  , XHRFake = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-fake.js")
	  , InfoIframe = __webpack_require__("./node_modules/sockjs-client/lib/info-iframe.js")
	  , InfoAjax = __webpack_require__("./node_modules/sockjs-client/lib/info-ajax.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:info-receiver');
	}
	
	function InfoReceiver(baseUrl, urlInfo) {
	  debug(baseUrl);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function() {
	    self.doXhr(baseUrl, urlInfo);
	  }, 0);
	}
	
	inherits(InfoReceiver, EventEmitter);
	
	// TODO this is currently ignoring the list of available transports and the whitelist
	
	InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
	  // determine method of CORS support (if needed)
	  if (urlInfo.sameOrigin) {
	    return new InfoAjax(url, XHRLocal);
	  }
	  if (XHRCors.enabled) {
	    return new InfoAjax(url, XHRCors);
	  }
	  if (XDR.enabled && urlInfo.sameScheme) {
	    return new InfoAjax(url, XDR);
	  }
	  if (InfoIframe.enabled()) {
	    return new InfoIframe(baseUrl, url);
	  }
	  return new InfoAjax(url, XHRFake);
	};
	
	InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
	  var self = this
	    , url = urlUtils.addPath(baseUrl, '/info')
	    ;
	  debug('doXhr', url);
	
	  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);
	
	  this.timeoutRef = setTimeout(function() {
	    debug('timeout');
	    self._cleanup(false);
	    self.emit('finish');
	  }, InfoReceiver.timeout);
	
	  this.xo.once('finish', function(info, rtt) {
	    debug('finish', info, rtt);
	    self._cleanup(true);
	    self.emit('finish', info, rtt);
	  });
	};
	
	InfoReceiver.prototype._cleanup = function(wasClean) {
	  debug('_cleanup');
	  clearTimeout(this.timeoutRef);
	  this.timeoutRef = null;
	  if (!wasClean && this.xo) {
	    this.xo.close();
	  }
	  this.xo = null;
	};
	
	InfoReceiver.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  this._cleanup(false);
	};
	
	InfoReceiver.timeout = 8000;
	
	module.exports = InfoReceiver;


/***/ },

/***/ "./node_modules/sockjs-client/lib/transport/sender/xhr-fake.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  ;
	
	function XHRFake(/* method, url, payload, opts */) {
	  var self = this;
	  EventEmitter.call(this);
	
	  this.to = setTimeout(function() {
	    self.emit('finish', 200, '{}');
	  }, XHRFake.timeout);
	}
	
	inherits(XHRFake, EventEmitter);
	
	XHRFake.prototype.close = function() {
	  clearTimeout(this.to);
	};
	
	XHRFake.timeout = 2000;
	
	module.exports = XHRFake;


/***/ },

/***/ "./node_modules/sockjs-client/lib/info-iframe.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , utils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , IframeTransport = __webpack_require__("./node_modules/sockjs-client/lib/transport/iframe.js")
	  , InfoReceiverIframe = __webpack_require__("./node_modules/sockjs-client/lib/info-iframe-receiver.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:info-iframe');
	}
	
	function InfoIframe(baseUrl, url) {
	  var self = this;
	  EventEmitter.call(this);
	
	  var go = function() {
	    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);
	
	    ifr.once('message', function(msg) {
	      if (msg) {
	        var d;
	        try {
	          d = JSON3.parse(msg);
	        } catch (e) {
	          debug('bad json', msg);
	          self.emit('finish');
	          self.close();
	          return;
	        }
	
	        var info = d[0], rtt = d[1];
	        self.emit('finish', info, rtt);
	      }
	      self.close();
	    });
	
	    ifr.once('close', function() {
	      self.emit('finish');
	      self.close();
	    });
	  };
	
	  // TODO this seems the same as the 'needBody' from transports
	  if (!global.document.body) {
	    utils.attachEvent('load', go);
	  } else {
	    go();
	  }
	}
	
	inherits(InfoIframe, EventEmitter);
	
	InfoIframe.enabled = function() {
	  return IframeTransport.enabled();
	};
	
	InfoIframe.prototype.close = function() {
	  if (this.ifr) {
	    this.ifr.close();
	  }
	  this.removeAllListeners();
	  this.ifr = null;
	};
	
	module.exports = InfoIframe;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/sockjs-client/lib/info-iframe-receiver.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , XHRLocalObject = __webpack_require__("./node_modules/sockjs-client/lib/transport/sender/xhr-local.js")
	  , InfoAjax = __webpack_require__("./node_modules/sockjs-client/lib/info-ajax.js")
	  ;
	
	function InfoReceiverIframe(transUrl) {
	  var self = this;
	  EventEmitter.call(this);
	
	  this.ir = new InfoAjax(transUrl, XHRLocalObject);
	  this.ir.once('finish', function(info, rtt) {
	    self.ir = null;
	    self.emit('message', JSON3.stringify([info, rtt]));
	  });
	}
	
	inherits(InfoReceiverIframe, EventEmitter);
	
	InfoReceiverIframe.transportName = 'iframe-info-receiver';
	
	InfoReceiverIframe.prototype.close = function() {
	  if (this.ir) {
	    this.ir.close();
	    this.ir = null;
	  }
	  this.removeAllListeners();
	};
	
	module.exports = InfoReceiverIframe;


/***/ },

/***/ "./node_modules/sockjs-client/lib/info-ajax.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__("./node_modules/sockjs-client/lib/event/emitter.js").EventEmitter
	  , inherits = __webpack_require__("./node_modules/inherits/inherits_browser.js")
	  , JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , objectUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/object.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:info-ajax');
	}
	
	function InfoAjax(url, AjaxObject) {
	  EventEmitter.call(this);
	
	  var self = this;
	  var t0 = +new Date();
	  this.xo = new AjaxObject('GET', url);
	
	  this.xo.once('finish', function(status, text) {
	    var info, rtt;
	    if (status === 200) {
	      rtt = (+new Date()) - t0;
	      if (text) {
	        try {
	          info = JSON3.parse(text);
	        } catch (e) {
	          debug('bad json', text);
	        }
	      }
	
	      if (!objectUtils.isObject(info)) {
	        info = {};
	      }
	    }
	    self.emit('finish', info, rtt);
	    self.removeAllListeners();
	  });
	}
	
	inherits(InfoAjax, EventEmitter);
	
	InfoAjax.prototype.close = function() {
	  this.removeAllListeners();
	  this.xo.close();
	};
	
	module.exports = InfoAjax;


/***/ },

/***/ "./node_modules/sockjs-client/lib/iframe-bootstrap.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var urlUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/url.js")
	  , eventUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/event.js")
	  , JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , FacadeJS = __webpack_require__("./node_modules/sockjs-client/lib/facade.js")
	  , InfoIframeReceiver = __webpack_require__("./node_modules/sockjs-client/lib/info-iframe-receiver.js")
	  , iframeUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/iframe.js")
	  , loc = __webpack_require__("./node_modules/sockjs-client/lib/location.js")
	  ;
	
	var debug = function() {};
	if (true) {
	  debug = __webpack_require__("./node_modules/debug/browser.js")('sockjs-client:iframe-bootstrap');
	}
	
	module.exports = function(SockJS, availableTransports) {
	  var transportMap = {};
	  availableTransports.forEach(function(at) {
	    if (at.facadeTransport) {
	      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
	    }
	  });
	
	  // hard-coded for the info iframe
	  // TODO see if we can make this more dynamic
	  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
	  var parentOrigin;
	
	  /* eslint-disable camelcase */
	  SockJS.bootstrap_iframe = function() {
	    /* eslint-enable camelcase */
	    var facade;
	    iframeUtils.currentWindowId = loc.hash.slice(1);
	    var onMessage = function(e) {
	      if (e.source !== parent) {
	        return;
	      }
	      if (typeof parentOrigin === 'undefined') {
	        parentOrigin = e.origin;
	      }
	      if (e.origin !== parentOrigin) {
	        return;
	      }
	
	      var iframeMessage;
	      try {
	        iframeMessage = JSON3.parse(e.data);
	      } catch (ignored) {
	        debug('bad json', e.data);
	        return;
	      }
	
	      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
	        return;
	      }
	      switch (iframeMessage.type) {
	      case 's':
	        var p;
	        try {
	          p = JSON3.parse(iframeMessage.data);
	        } catch (ignored) {
	          debug('bad json', iframeMessage.data);
	          break;
	        }
	        var version = p[0];
	        var transport = p[1];
	        var transUrl = p[2];
	        var baseUrl = p[3];
	        debug(version, transport, transUrl, baseUrl);
	        // change this to semver logic
	        if (version !== SockJS.version) {
	          throw new Error('Incompatible SockJS! Main site uses:' +
	                    ' "' + version + '", the iframe:' +
	                    ' "' + SockJS.version + '".');
	        }
	
	        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
	            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
	          throw new Error('Can\'t connect to different domain from within an ' +
	                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
	        }
	        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
	        break;
	      case 'm':
	        facade._send(iframeMessage.data);
	        break;
	      case 'c':
	        if (facade) {
	          facade._close();
	        }
	        facade = null;
	        break;
	      }
	    };
	
	    eventUtils.attachEvent('message', onMessage);
	
	    // Start
	    iframeUtils.postMessage('s');
	  };
	};


/***/ },

/***/ "./node_modules/sockjs-client/lib/facade.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__("./node_modules/json3/lib/json3.js")
	  , iframeUtils = __webpack_require__("./node_modules/sockjs-client/lib/utils/iframe.js")
	  ;
	
	function FacadeJS(transport) {
	  this._transport = transport;
	  transport.on('message', this._transportMessage.bind(this));
	  transport.on('close', this._transportClose.bind(this));
	}
	
	FacadeJS.prototype._transportClose = function(code, reason) {
	  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
	};
	FacadeJS.prototype._transportMessage = function(frame) {
	  iframeUtils.postMessage('t', frame);
	};
	FacadeJS.prototype._send = function(data) {
	  this._transport.send(data);
	};
	FacadeJS.prototype._close = function() {
	  this._transport.close();
	  this._transport.removeAllListeners();
	};
	
	module.exports = FacadeJS;


/***/ },

/***/ "./node_modules/webpack/hot/only-dev-server.js":
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals window __webpack_hash__ */
	if(true) {
		var lastData;
		var upToDate = function upToDate() {
			return lastData.indexOf(__webpack_require__.h()) >= 0;
		};
		var check = function check() {
			module.hot.check(function(err, updatedModules) {
				if(err) {
					if(module.hot.status() in {
							abort: 1,
							fail: 1
						}) {
						console.warn("[HMR] Cannot check for update. Need to do a full reload!");
						console.warn("[HMR] " + err.stack || err.message);
					} else {
						console.warn("[HMR] Update check failed: " + err.stack || err.message);
					}
					return;
				}
	
				if(!updatedModules) {
					console.warn("[HMR] Cannot find update. Need to do a full reload!");
					console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
					return;
				}
	
				module.hot.apply({
					ignoreUnaccepted: true
				}, function(err, renewedModules) {
					if(err) {
						if(module.hot.status() in {
								abort: 1,
								fail: 1
							}) {
							console.warn("[HMR] Cannot apply update. Need to do a full reload!");
							console.warn("[HMR] " + err.stack || err.message);
						} else {
							console.warn("[HMR] Update failed: " + err.stack || err.message);
						}
						return;
					}
	
					if(!upToDate()) {
						check();
					}
	
					__webpack_require__("./node_modules/webpack/hot/log-apply-result.js")(updatedModules, renewedModules);
	
					if(upToDate()) {
						console.log("[HMR] App is up to date.");
					}
				});
			});
		};
		var addEventListener = window.addEventListener ? function(eventName, listener) {
			window.addEventListener(eventName, listener, false);
		} : function(eventName, listener) {
			window.attachEvent("on" + eventName, listener);
		};
		addEventListener("message", function(event) {
			if(typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {
				lastData = event.data;
				if(!upToDate() && module.hot.status() === "idle") {
					console.log("[HMR] Checking for updates on the server...");
					check();
				}
			}
		});
		console.log("[HMR] Waiting for update signal from WDS...");
	} else {
		throw new Error("[HMR] Hot Module Replacement is disabled.");
	}


/***/ },

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(updatedModules, renewedModules) {
		var unacceptedModules = updatedModules.filter(function(moduleId) {
			return renewedModules && renewedModules.indexOf(moduleId) < 0;
		});
	
		if(unacceptedModules.length > 0) {
			console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
			unacceptedModules.forEach(function(moduleId) {
				console.warn("[HMR]  - " + moduleId);
			});
		}
	
		if(!renewedModules || renewedModules.length === 0) {
			console.log("[HMR] Nothing hot updated.");
		} else {
			console.log("[HMR] Updated modules:");
			renewedModules.forEach(function(moduleId) {
				console.log("[HMR]  - " + moduleId);
			});
		}
	};


/***/ },

/***/ "./src/overrides.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/overrides.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/overrides.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/overrides.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/overrides.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".ui.dropdown .menu .selected.item,\n.ui.dropdown .menu > .item:hover,\n.ui.dropdown.selected {\n  background: #e2eff9 !important; }\n\n.ui.card > .extra,\n.ui.cards > .card > .extra {\n  border-top: 1px solid rgba(0, 0, 0, 0.1) !important; }\n", "", {"version":3,"sources":["/./src/src/overrides.scss"],"names":[],"mappings":"AACA;;;EAGE,+BAA4C,EAC7C;;AAED;;EAEE,oDAAiD,EAClD","file":"overrides.scss","sourcesContent":["// Overrides\n:global(.ui.dropdown .menu .selected.item),\n:global(.ui.dropdown .menu > .item:hover),\n:global(.ui.dropdown.selected) {\n  background: lighten(#2987CD, 45%) !important;\n}\n\n:global(.ui.card > .extra),\n:global(.ui.cards > .card > .extra) {\n  border-top: 1px solid rgba(0,0,0, 0.1) !important;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ },

/***/ "./node_modules/css-loader/lib/css-base.js":
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },

/***/ "./node_modules/style-loader/addStyles.js":
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },

/***/ "./src/index.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _moment = __webpack_require__(7);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(8);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactHotLoader = __webpack_require__(9);
	
	var _configureStore = __webpack_require__("./src/store/configure-store.js");
	
	var _configureStore2 = _interopRequireDefault(_configureStore);
	
	var _application = __webpack_require__("./src/application.jsx");
	
	var _application2 = _interopRequireDefault(_application);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_moment2.default.locale('pt-br');
	
	var rootEl = document.querySelector('#wrapper');
	var store = (0, _configureStore2.default)();
	
	_reactDom2.default.render(_react2.default.createElement(
	  _reactHotLoader.AppContainer,
	  null,
	  _react2.default.createElement(_application2.default, { store: store })
	), rootEl);
	
	if (true) {
	  module.hot.accept("./src/application.jsx", function () {
	    var NextApp = __webpack_require__("./src/application.jsx").default;
	
	    _reactDom2.default.render(_react2.default.createElement(
	      _reactHotLoader.AppContainer,
	      null,
	      _react2.default.createElement(NextApp, { store: store })
	    ), rootEl);
	  });
	}
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(rootEl, 'rootEl', 'D:/repo.git/djalmajr/agencia-amiga/src/index.jsx');
	
	  __REACT_HOT_LOADER__.register(store, 'store', 'D:/repo.git/djalmajr/agencia-amiga/src/index.jsx');
	}();

	;

/***/ },

/***/ 7:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1013);

/***/ },

/***/ 8:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1124);

/***/ },

/***/ 9:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1270);

/***/ },

/***/ "./src/store/configure-store.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _toConsumableArray2 = __webpack_require__(10);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	var _lodash = __webpack_require__(11);
	
	var _redux = __webpack_require__(12);
	
	var _reduxAsyncInitialState = __webpack_require__(13);
	
	var _reduxSaga = __webpack_require__(14);
	
	var _reduxSaga2 = _interopRequireDefault(_reduxSaga);
	
	var _reduxImmutableStateInvariant = __webpack_require__(15);
	
	var _reduxImmutableStateInvariant2 = _interopRequireDefault(_reduxImmutableStateInvariant);
	
	var _reducers = __webpack_require__("./src/store/reducers/index.js");
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	var _sagas = __webpack_require__("./src/store/sagas/index.js");
	
	var _sagas2 = _interopRequireDefault(_sagas);
	
	var _cacheState = __webpack_require__("./src/store/cache-state.js");
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEV = ("development") !== 'production';
	
	var configureStore = function configureStore() {
	  var sagaMiddleware = (0, _reduxSaga2.default)();
	  var middlewares = [sagaMiddleware, (0, _reduxAsyncInitialState.middleware)(_cacheState.loadState)];
	
	  if (DEV) {
	    var _require = __webpack_require__("./src/devtools.jsx"),
	        DevTools = _require.DevTools;
	
	    var composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__;
	
	    middlewares = middlewares.concat([(0, _reduxImmutableStateInvariant2.default)()]);
	    middlewares = _redux.applyMiddleware.apply(undefined, (0, _toConsumableArray3.default)(middlewares));
	    middlewares = composeEnhancers ? composeEnhancers(middlewares) : (0, _redux.compose)(middlewares, DevTools.instrument());
	  } else {
	    middlewares = _redux.applyMiddleware.apply(undefined, (0, _toConsumableArray3.default)(middlewares));
	  }
	
	  var store = (0, _redux.createStore)((0, _reduxAsyncInitialState.outerReducer)(_reducers2.default), middlewares);
	
	  store.runSaga = sagaMiddleware.run;
	
	  if (true) {
	    module.hot.accept("./src/store/reducers/index.js", function () {
	      var nextReducer = __webpack_require__("./src/store/reducers/index.js").default;
	
	      store.replaceReducer((0, _reduxAsyncInitialState.outerReducer)(nextReducer));
	    });
	  }
	
	  store.subscribe((0, _lodash.throttle)(function () {
	    var _store$getState = store.getState(),
	        authData = _store$getState.auth.authData;
	
	    (0, _cacheState.saveState)({ auth: { authData: authData } });
	  }, 2000));
	
	  store.runSaga(_sagas2.default);
	
	  return store;
	};
	
	var _default = configureStore;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(DEV, 'DEV', 'D:/repo.git/djalmajr/agencia-amiga/src/store/configure-store.js');
	
	  __REACT_HOT_LOADER__.register(configureStore, 'configureStore', 'D:/repo.git/djalmajr/agencia-amiga/src/store/configure-store.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/store/configure-store.js');
	}();

	;

/***/ },

/***/ 10:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1754);

/***/ },

/***/ 11:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(2184);

/***/ },

/***/ 12:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1352);

/***/ },

/***/ 13:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1558);

/***/ },

/***/ 14:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1812);

/***/ },

/***/ 15:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1808);

/***/ },

/***/ "./src/store/reducers/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(12);
	
	var _reduxAsyncInitialState = __webpack_require__(13);
	
	var _auth = __webpack_require__("./src/store/reducers/auth.js");
	
	var auth = _interopRequireWildcard(_auth);
	
	var _entities = __webpack_require__("./src/store/reducers/entities.js");
	
	var entities = _interopRequireWildcard(_entities);
	
	var _filter = __webpack_require__("./src/store/reducers/filter.js");
	
	var filter = _interopRequireWildcard(_filter);
	
	var _global = __webpack_require__("./src/store/reducers/global.js");
	
	var global = _interopRequireWildcard(_global);
	
	var _profile = __webpack_require__("./src/store/reducers/profile.js");
	
	var profile = _interopRequireWildcard(_profile);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var _default = (0, _redux.combineReducers)({
	  asyncState: _reduxAsyncInitialState.innerReducer,
	  auth: (0, _redux.combineReducers)(auth),
	  entities: (0, _redux.combineReducers)(entities),
	  filter: (0, _redux.combineReducers)(filter),
	  global: (0, _redux.combineReducers)(global),
	  profile: (0, _redux.combineReducers)(profile)
	});
	
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/index.js');
	}();

	;

/***/ },

/***/ "./src/store/reducers/auth.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.authData = exports.isRegistering = exports.isAuthenticating = undefined;
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _handleActions, _handleActions2, _handleActions3;
	
	var _reduxActions = __webpack_require__(17);
	
	var _emptyObject = __webpack_require__(18);
	
	var _emptyObject2 = _interopRequireDefault(_emptyObject);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var isAuthenticating = exports.isAuthenticating = (0, _reduxActions.handleActions)((_handleActions = {}, (0, _defineProperty3.default)(_handleActions, actions.login, function () {
	  return true;
	}), (0, _defineProperty3.default)(_handleActions, actions.authorize, function () {
	  return false;
	}), _handleActions), false);
	
	var isRegistering = exports.isRegistering = (0, _reduxActions.handleActions)((_handleActions2 = {}, (0, _defineProperty3.default)(_handleActions2, actions.register, function () {
	  return true;
	}), (0, _defineProperty3.default)(_handleActions2, actions.authorize, function () {
	  return false;
	}), _handleActions2), false);
	
	var authData = exports.authData = (0, _reduxActions.handleActions)((_handleActions3 = {}, (0, _defineProperty3.default)(_handleActions3, actions.unauthorize, function () {
	  return _emptyObject2.default;
	}), (0, _defineProperty3.default)(_handleActions3, actions.authorize, function (state, _ref) {
	  var error = _ref.error,
	      payload = _ref.payload;
	  return error ? {} : payload;
	}), _handleActions3), _emptyObject2.default);
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(isAuthenticating, 'isAuthenticating', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/auth.js');
	
	  __REACT_HOT_LOADER__.register(isRegistering, 'isRegistering', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/auth.js');
	
	  __REACT_HOT_LOADER__.register(authData, 'authData', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/auth.js');
	}();

	;

/***/ },

/***/ "./node_modules/babel-runtime/helpers/defineProperty.js":
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(16);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	
	  return obj;
	};

/***/ },

/***/ 16:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1795);

/***/ },

/***/ 17:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1411);

/***/ },

/***/ 18:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(983);

/***/ },

/***/ "./src/store/actions.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateCache = exports.save = exports.removeCache = exports.remove = exports.read = exports.addToOrg = exports.updateTabFeed = exports.updateProfile = exports.updateFilter = exports.filter = exports.notifyWarning = exports.notifyInfo = exports.notifyError = exports.notify = exports.unauthorize = exports.authorize = exports.register = exports.logout = exports.login = undefined;
	
	var _uuid = __webpack_require__(19);
	
	var _createAction = __webpack_require__("./src/helpers/create-action.js");
	
	var _createAction2 = _interopRequireDefault(_createAction);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var handleNotify = function handleNotify(message) {
	  message = typeof message === 'string' ? { message: message } : message;
	  message.uid = (0, _uuid.v4)();
	
	  return message;
	};
	
	var login = exports.login = (0, _createAction2.default)('login');
	var logout = exports.logout = (0, _createAction2.default)('logout');
	var register = exports.register = (0, _createAction2.default)('register');
	var authorize = exports.authorize = (0, _createAction2.default)('authorize');
	var unauthorize = exports.unauthorize = (0, _createAction2.default)('unauthorize');
	
	var notify = exports.notify = (0, _createAction2.default)('notify', handleNotify);
	var notifyError = exports.notifyError = (0, _createAction2.default)('notify', handleNotify);
	var notifyInfo = exports.notifyInfo = (0, _createAction2.default)('notify', handleNotify);
	var notifyWarning = exports.notifyWarning = (0, _createAction2.default)('notify', handleNotify);
	var filter = exports.filter = (0, _createAction2.default)('filter');
	var updateFilter = exports.updateFilter = (0, _createAction2.default)('update-filter');
	var updateProfile = exports.updateProfile = (0, _createAction2.default)('update-profile');
	var updateTabFeed = exports.updateTabFeed = (0, _createAction2.default)('update-tab-feed');
	
	var addToOrg = exports.addToOrg = (0, _createAction2.default)('add-to-org');
	var read = exports.read = (0, _createAction2.default)('read');
	var remove = exports.remove = (0, _createAction2.default)('remove');
	var removeCache = exports.removeCache = (0, _createAction2.default)('remove-cache');
	var save = exports.save = (0, _createAction2.default)('save', function (ref, data) {
	  return { ref: ref, data: data };
	});
	var updateCache = exports.updateCache = (0, _createAction2.default)('update-cache');
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(handleNotify, 'handleNotify', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(login, 'login', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(logout, 'logout', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(register, 'register', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(authorize, 'authorize', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(unauthorize, 'unauthorize', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(notify, 'notify', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(notifyError, 'notifyError', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(notifyInfo, 'notifyInfo', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(notifyWarning, 'notifyWarning', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(filter, 'filter', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(updateFilter, 'updateFilter', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(updateProfile, 'updateProfile', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(updateTabFeed, 'updateTabFeed', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(addToOrg, 'addToOrg', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(read, 'read', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(remove, 'remove', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(removeCache, 'removeCache', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(save, 'save', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	
	  __REACT_HOT_LOADER__.register(updateCache, 'updateCache', 'D:/repo.git/djalmajr/agencia-amiga/src/store/actions.js');
	}();

	;

/***/ },

/***/ 19:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(2173);

/***/ },

/***/ "./src/helpers/create-action.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _uuid = __webpack_require__(19);
	
	var _reduxActions = __webpack_require__(17);
	
	var createAction = function createAction(name) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	
	  return _reduxActions.createAction.apply(undefined, [name + '-' + (0, _uuid.v4)()].concat(args));
	};
	
	var _default = createAction;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(createAction, 'createAction', 'D:/repo.git/djalmajr/agencia-amiga/src/helpers/create-action.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/helpers/create-action.js');
	}();

	;

/***/ },

/***/ "./src/store/reducers/entities.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isRemoving = exports.isFetching = exports.byId = undefined;
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _handleActions, _handleActions2, _handleActions3;
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _reduxActions = __webpack_require__(17);
	
	var _emptyObject = __webpack_require__(18);
	
	var _emptyObject2 = _interopRequireDefault(_emptyObject);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var byId = exports.byId = (0, _reduxActions.handleActions)((_handleActions = {}, (0, _defineProperty3.default)(_handleActions, actions.unauthorize, function () {
	  return _emptyObject2.default;
	}), (0, _defineProperty3.default)(_handleActions, actions.removeCache, function (state, _ref) {
	  var error = _ref.error,
	      payload = _ref.payload;
	
	  if (error) {
	    return state;
	  }
	
	  var newState = _lodash2.default.merge({}, state);
	
	  try {
	    delete newState[payload.entity][payload.uid];
	
	    return newState;
	  } catch (err) {
	    return state;
	  }
	}), (0, _defineProperty3.default)(_handleActions, actions.updateCache, function (state, _ref2) {
	  var error = _ref2.error,
	      payload = _ref2.payload;
	
	  if (error) {
	    return state;
	  }
	
	  var newState = _lodash2.default.merge({}, state);
	
	  _lodash2.default.forEach(payload.response, function (val, key) {
	    if (!newState[payload.entity]) {
	      newState[payload.entity] = {};
	    }
	
	    newState[payload.entity][key] = val;
	  });
	
	  return newState;
	}), _handleActions), _emptyObject2.default);
	
	var isFetching = exports.isFetching = (0, _reduxActions.handleActions)((_handleActions2 = {}, (0, _defineProperty3.default)(_handleActions2, actions.unauthorize, function () {
	  return {};
	}), (0, _defineProperty3.default)(_handleActions2, actions.read, function (state, _ref3) {
	  var payload = _ref3.payload;
	  return _lodash2.default.assign({}, state, (0, _defineProperty3.default)({}, payload.entity, true));
	}), (0, _defineProperty3.default)(_handleActions2, actions.addToOrg, function (state, _ref4) {
	  var payload = _ref4.payload;
	  return _lodash2.default.assign({}, state, (0, _defineProperty3.default)({}, payload.entity, true));
	}), (0, _defineProperty3.default)(_handleActions2, actions.updateCache, function (state, _ref5) {
	  var error = _ref5.error,
	      payload = _ref5.payload;
	
	  if (error) {
	    return {};
	  }
	
	  return _lodash2.default.assign({}, state, (0, _defineProperty3.default)({}, payload.entity, false));
	}), _handleActions2), _emptyObject2.default);
	
	var isRemoving = exports.isRemoving = (0, _reduxActions.handleActions)((_handleActions3 = {}, (0, _defineProperty3.default)(_handleActions3, actions.unauthorize, function () {
	  return _emptyObject2.default;
	}), (0, _defineProperty3.default)(_handleActions3, actions.remove, function (state, _ref6) {
	  var payload = _ref6.payload;
	  return _lodash2.default.assign({}, state, (0, _defineProperty3.default)({}, payload.entity, true));
	}), (0, _defineProperty3.default)(_handleActions3, actions.removeCache, function (state, _ref7) {
	  var payload = _ref7.payload;
	
	  var newState = _lodash2.default.merge({}, state);
	
	  delete newState[payload.entity][payload.uid];
	
	  return newState;
	}), _handleActions3), _emptyObject2.default);
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(byId, 'byId', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/entities.js');
	
	  __REACT_HOT_LOADER__.register(isFetching, 'isFetching', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/entities.js');
	
	  __REACT_HOT_LOADER__.register(isRemoving, 'isRemoving', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/entities.js');
	}();

	;

/***/ },

/***/ "./src/store/reducers/filter.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isFiltering = exports.entity = exports.skills = exports.query = undefined;
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _handleActions2;
	
	var _reduxActions = __webpack_require__(17);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var createFilterReducer = function createFilterReducer(name, defaultValue) {
	  var _handleActions;
	
	  return (0, _reduxActions.handleActions)((_handleActions = {}, (0, _defineProperty3.default)(_handleActions, actions.unauthorize, function () {
	    return defaultValue;
	  }), (0, _defineProperty3.default)(_handleActions, actions.updateFilter, function (state, _ref) {
	    var payload = _ref.payload;
	    return name === payload.name ? payload.value : state;
	  }), _handleActions), defaultValue);
	};
	
	var query = exports.query = createFilterReducer('query', '');
	var skills = exports.skills = createFilterReducer('skills', []);
	var entity = exports.entity = createFilterReducer('entity', 'users');
	var isFiltering = exports.isFiltering = (0, _reduxActions.handleActions)((_handleActions2 = {}, (0, _defineProperty3.default)(_handleActions2, actions.unauthorize, function () {
	  return false;
	}), (0, _defineProperty3.default)(_handleActions2, actions.filter, function () {
	  return true;
	}), (0, _defineProperty3.default)(_handleActions2, actions.searchDone, function () {
	  return false;
	}), _handleActions2), false);
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(createFilterReducer, 'createFilterReducer', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/filter.js');
	
	  __REACT_HOT_LOADER__.register(query, 'query', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/filter.js');
	
	  __REACT_HOT_LOADER__.register(skills, 'skills', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/filter.js');
	
	  __REACT_HOT_LOADER__.register(entity, 'entity', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/filter.js');
	
	  __REACT_HOT_LOADER__.register(isFiltering, 'isFiltering', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/filter.js');
	}();

	;

/***/ },

/***/ "./src/store/reducers/global.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.notification = undefined;
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _handleActions;
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _reduxActions = __webpack_require__(17);
	
	var _emptyObject = __webpack_require__(18);
	
	var _emptyObject2 = _interopRequireDefault(_emptyObject);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var notification = exports.notification = (0, _reduxActions.handleActions)((_handleActions = {}, (0, _defineProperty3.default)(_handleActions, actions.notify, function (state, action) {
	  return _lodash2.default.merge({ position: 'br', level: 'success' }, action.payload);
	}), (0, _defineProperty3.default)(_handleActions, actions.notifyError, function (state, action) {
	  return _lodash2.default.merge({ position: 'br', level: 'error' }, action.payload);
	}), (0, _defineProperty3.default)(_handleActions, actions.notifyInfo, function (state, action) {
	  return _lodash2.default.merge({ position: 'br', level: 'info' }, action.payload);
	}), (0, _defineProperty3.default)(_handleActions, actions.notifyWarning, function (state, action) {
	  return _lodash2.default.merge({ position: 'br', level: 'warning' }, action.payload);
	}), _handleActions), _emptyObject2.default);
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(notification, 'notification', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/global.js');
	}();

	;

/***/ },

/***/ "./src/store/reducers/profile.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.currentTabFeed = exports.isUpdatingProfile = undefined;
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _handleActions, _handleActions2;
	
	var _reduxActions = __webpack_require__(17);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var isUpdatingProfile = exports.isUpdatingProfile = (0, _reduxActions.handleActions)((_handleActions = {}, (0, _defineProperty3.default)(_handleActions, actions.unauthorize, function () {
	  return false;
	}), (0, _defineProperty3.default)(_handleActions, actions.updateProfile, function () {
	  return true;
	}), (0, _defineProperty3.default)(_handleActions, actions.updateCache, function (state, _ref) {
	  var payload = _ref.payload;
	  return payload.entity !== 'users';
	}), _handleActions), false);
	
	var currentTabFeed = exports.currentTabFeed = (0, _reduxActions.handleActions)((_handleActions2 = {}, (0, _defineProperty3.default)(_handleActions2, actions.unauthorize, function () {
	  return 'timeline';
	}), (0, _defineProperty3.default)(_handleActions2, actions.updateTabFeed, function (state, _ref2) {
	  var payload = _ref2.payload;
	  return payload;
	}), _handleActions2), 'timeline');
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(isUpdatingProfile, 'isUpdatingProfile', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/profile.js');
	
	  __REACT_HOT_LOADER__.register(currentTabFeed, 'currentTabFeed', 'D:/repo.git/djalmajr/agencia-amiga/src/store/reducers/profile.js');
	}();

	;

/***/ },

/***/ "./src/store/sagas/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__("./node_modules/babel-runtime/regenerator/index.js");
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _reduxSaga = __webpack_require__(14);
	
	var _auth = __webpack_require__("./src/store/sagas/auth.js");
	
	var authSaga = _interopRequireWildcard(_auth);
	
	var _entities = __webpack_require__("./src/store/sagas/entities.js");
	
	var entitySaga = _interopRequireWildcard(_entities);
	
	var _profile = __webpack_require__("./src/store/sagas/profile.js");
	
	var profileSaga = _interopRequireWildcard(_profile);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _default = _regenerator2.default.mark(function _default() {
	  return _regenerator2.default.wrap(function _default$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          _context.next = 2;
	          return (0, _reduxSaga.takeEvery)(actions.login.toString(), authSaga.login);
	
	        case 2:
	          _context.next = 4;
	          return (0, _reduxSaga.takeEvery)(actions.logout.toString(), authSaga.logout);
	
	        case 4:
	          _context.next = 6;
	          return (0, _reduxSaga.takeEvery)(actions.register.toString(), authSaga.register);
	
	        case 6:
	          _context.next = 8;
	          return (0, _reduxSaga.takeEvery)(actions.read.toString(), entitySaga.read);
	
	        case 8:
	          _context.next = 10;
	          return (0, _reduxSaga.takeEvery)(actions.remove.toString(), entitySaga.remove);
	
	        case 10:
	          _context.next = 12;
	          return (0, _reduxSaga.takeEvery)(actions.save.toString(), entitySaga.save);
	
	        case 12:
	          _context.next = 14;
	          return (0, _reduxSaga.takeEvery)(actions.addToOrg.toString(), profileSaga.addToOrg);
	
	        case 14:
	          _context.next = 16;
	          return (0, _reduxSaga.takeEvery)(actions.updateProfile.toString(), profileSaga.update);
	
	        case 16:
	        case 'end':
	          return _context.stop();
	      }
	    }
	  }, _default, this);
	});
	
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/index.js');
	}();

	;

/***/ },

/***/ "./node_modules/babel-runtime/regenerator/index.js":
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__("./node_modules/regenerator-runtime/runtime-module.js");


/***/ },

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;
	
	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
	
	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;
	
	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;
	
	module.exports = __webpack_require__("./node_modules/regenerator-runtime/runtime.js");
	
	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },

/***/ "./node_modules/regenerator-runtime/runtime.js":
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Promise, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__("./node_modules/es6-promise/dist/es6-promise.js"), __webpack_require__(20)))

/***/ },

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, Promise, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */
	
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';
	
	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}
	
	function isFunction(x) {
	  return typeof x === 'function';
	}
	
	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}
	
	var isArray = _isArray;
	
	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;
	
	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};
	
	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}
	
	function setAsap(asapFn) {
	  asap = asapFn;
	}
	
	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';
	
	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}
	
	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	
	  return useSetTimeout();
	}
	
	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });
	
	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}
	
	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}
	
	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}
	
	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];
	
	    callback(arg);
	
	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }
	
	  len = 0;
	}
	
	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(21);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}
	
	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}
	
	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;
	
	  var parent = this;
	
	  var child = new this.constructor(noop);
	
	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }
	
	  var _state = parent._state;
	
	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }
	
	  return child;
	}
	
	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.resolve(1);
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }
	
	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}
	
	var PROMISE_ID = Math.random().toString(36).substring(16);
	
	function noop() {}
	
	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	
	var GET_THEN_ERROR = new ErrorObject();
	
	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}
	
	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}
	
	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}
	
	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}
	
	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	
	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}
	
	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}
	
	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}
	
	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}
	
	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }
	
	  publish(promise);
	}
	
	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	
	  promise._result = value;
	  promise._state = FULFILLED;
	
	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}
	
	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	
	  asap(publishRejection, promise);
	}
	
	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;
	
	  parent._onerror = null;
	
	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;
	
	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}
	
	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;
	
	  if (subscribers.length === 0) {
	    return;
	  }
	
	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;
	
	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];
	
	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }
	
	  promise._subscribers.length = 0;
	}
	
	function ErrorObject() {
	  this.error = null;
	}
	
	var TRY_CATCH_ERROR = new ErrorObject();
	
	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}
	
	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;
	
	  if (hasCallback) {
	    value = tryCatch(callback, detail);
	
	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }
	
	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }
	
	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}
	
	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}
	
	var id = 0;
	function nextId() {
	  return id++;
	}
	
	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}
	
	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);
	
	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }
	
	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;
	
	    this._result = new Array(this.length);
	
	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}
	
	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};
	
	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;
	
	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};
	
	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;
	
	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);
	
	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};
	
	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;
	
	  if (promise._state === PENDING) {
	    this._remaining--;
	
	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }
	
	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};
	
	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;
	
	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};
	
	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```
	
	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```
	
	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}
	
	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.
	
	  Example:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```
	
	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```
	
	  An example real-world use case is implementing timeouts:
	
	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```
	
	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}
	
	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}
	
	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}
	
	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}
	
	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.
	
	  Terminology
	  -----------
	
	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.
	
	  A promise can be in one of three states: pending, fulfilled, or rejected.
	
	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.
	
	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.
	
	
	  Basic Usage:
	  ------------
	
	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);
	
	    // on failure
	    reject(reason);
	  });
	
	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Advanced Usage:
	  ---------------
	
	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.
	
	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();
	
	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();
	
	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }
	
	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Unlike callbacks, promises are great composable primitives.
	
	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON
	
	    return values;
	  });
	  ```
	
	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];
	
	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}
	
	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;
	
	Promise.prototype = {
	  constructor: Promise,
	
	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,
	
	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};
	
	function polyfill() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }
	
	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }
	
	    local.Promise = Promise;
	}
	
	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;
	
	return Promise;
	
	})));
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20), __webpack_require__("./node_modules/es6-promise/dist/es6-promise.js"), (function() { return this; }())))

/***/ },

/***/ 20:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(966);

/***/ },

/***/ 21:
/***/ function(module, exports) {

	/* (ignored) */

/***/ },

/***/ "./src/store/sagas/auth.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _regenerator = __webpack_require__("./node_modules/babel-runtime/regenerator/index.js");
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _stringify = __webpack_require__("./node_modules/babel-runtime/core-js/json/stringify.js");
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	exports.login = login;
	exports.logout = logout;
	exports.register = register;
	
	var _effects = __webpack_require__("./node_modules/redux-saga/effects.js");
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	var _apis = __webpack_require__("./src/store/apis.js");
	
	var api = _interopRequireWildcard(_apis);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _marked = [login, logout, register].map(_regenerator2.default.mark);
	
	function login(action) {
	  var _action$payload, email, password, auth;
	
	  return _regenerator2.default.wrap(function login$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          _action$payload = action.payload, email = _action$payload.email, password = _action$payload.password;
	          _context.prev = 1;
	          _context.next = 4;
	          return api.login(email, password);
	
	        case 4:
	          auth = _context.sent.toJSON();
	          _context.next = 7;
	          return (0, _effects.put)(actions.read({ entity: 'users', uid: auth.uid }));
	
	        case 7:
	          _context.next = 9;
	          return (0, _effects.put)(actions.authorize(auth));
	
	        case 9:
	          _context.next = 18;
	          break;
	
	        case 11:
	          _context.prev = 11;
	          _context.t0 = _context['catch'](1);
	
	          console.log(_context.t0);_context.next = 16;
	          return (0, _effects.put)(actions.notifyError(_context.t0));
	
	        case 16:
	          _context.next = 18;
	          return (0, _effects.put)(actions.authorize(new Error((0, _stringify2.default)(_context.t0))));
	
	        case 18:
	        case 'end':
	          return _context.stop();
	      }
	    }
	  }, _marked[0], this, [[1, 11]]);
	}
	
	function logout() {
	  return _regenerator2.default.wrap(function logout$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          _context2.prev = 0;
	          _context2.next = 3;
	          return api.logout();
	
	        case 3:
	          _context2.next = 5;
	          return (0, _effects.put)(actions.unauthorize());
	
	        case 5:
	          _context2.next = 13;
	          break;
	
	        case 7:
	          _context2.prev = 7;
	          _context2.t0 = _context2['catch'](0);
	          _context2.next = 11;
	          return (0, _effects.put)(actions.notifyError(_context2.t0));
	
	        case 11:
	          _context2.next = 13;
	          return (0, _effects.put)(actions.unauthorize(new Error((0, _stringify2.default)(_context2.t0))));
	
	        case 13:
	        case 'end':
	          return _context2.stop();
	      }
	    }
	  }, _marked[1], this, [[0, 7]]);
	}
	
	function register(action) {
	  var _action$payload2, email, password, type, auth, user, error, message;
	
	  return _regenerator2.default.wrap(function register$(_context3) {
	    while (1) {
	      switch (_context3.prev = _context3.next) {
	        case 0:
	          _action$payload2 = action.payload, email = _action$payload2.email, password = _action$payload2.password, type = _action$payload2.type;
	          _context3.prev = 1;
	          _context3.next = 4;
	          return api.register(email, password);
	
	        case 4:
	          auth = _context3.sent.toJSON();
	          user = { uid: auth.uid, email: email, type: type };
	          _context3.next = 8;
	          return api.save('users', user);
	
	        case 8:
	          _context3.next = 10;
	          return (0, _effects.put)(actions.authorize(auth));
	
	        case 10:
	          _context3.next = 12;
	          return (0, _effects.put)(actions.updateCache({ entity: 'users', response: (0, _defineProperty3.default)({}, user.uid, user) }));
	
	        case 12:
	          _context3.next = 23;
	          break;
	
	        case 14:
	          _context3.prev = 14;
	          _context3.t0 = _context3['catch'](1);
	          error = JSON.parse((0, _stringify2.default)(_context3.t0));
	          message = 'Ocorreu um erro ao tentar realizar a ao solicitada. Por favor, tente novamente.';
	
	
	          console.error(_context3.t0, error);_context3.next = 21;
	          return (0, _effects.put)(actions.notifyError(error.message || message));
	
	        case 21:
	          _context3.next = 23;
	          return (0, _effects.put)(actions.authorize(_context3.t0));
	
	        case 23:
	        case 'end':
	          return _context3.stop();
	      }
	    }
	  }, _marked[2], this, [[1, 14]]);
	}
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(login, 'login', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/auth.js');
	
	  __REACT_HOT_LOADER__.register(logout, 'logout', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/auth.js');
	
	  __REACT_HOT_LOADER__.register(register, 'register', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/auth.js');
	}();

	;

/***/ },

/***/ "./node_modules/babel-runtime/core-js/json/stringify.js":
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/fn/json/stringify.js"), __esModule: true };

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/json/stringify.js":
/***/ function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(22)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ },

/***/ 22:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1655);

/***/ },

/***/ "./node_modules/redux-saga/effects.js":
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(23)

/***/ },

/***/ 23:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1822);

/***/ },

/***/ "./src/store/apis.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.register = exports.logout = exports.login = exports.updatePassword = exports.updateProfile = exports.remove = exports.save = exports.set = exports.once = undefined;
	
	var _promise = __webpack_require__("./node_modules/babel-runtime/core-js/promise.js");
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _constants = __webpack_require__("./src/constants.js");
	
	var _genUid = __webpack_require__("./src/helpers/gen-uid.js");
	
	var _genUid2 = _interopRequireDefault(_genUid);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var once = exports.once = function once(ref) {
	  return _constants.fb.database().ref(ref).once('value');
	};
	var set = exports.set = function set(ref, data) {
	  return _constants.fb.database().ref(ref).set(data);
	};
	
	var save = exports.save = function save(ref, data) {
	  if (!data.uid) {
	    data.uid = (0, _genUid2.default)(ref);
	  }
	
	  if (!data.createdAt) {
	    data.createdAt = _constants.fb.database.ServerValue.TIMESTAMP;
	  }
	
	  data.updatedAt = _constants.fb.database.ServerValue.TIMESTAMP;
	
	  return new _promise2.default(function (resolve, reject) {
	    set(ref + '/' + data.uid, data).then(once(ref + '/' + data.uid)).then(function (res) {
	      return resolve(res.val());
	    }).catch(reject);
	  });
	};
	
	var remove = exports.remove = function remove(ref) {
	  return _constants.fb.database().ref(ref).remove();
	};
	var updateProfile = exports.updateProfile = function updateProfile(data) {
	  return _constants.fb.auth().currentUser.updateProfile(data);
	};
	var updatePassword = exports.updatePassword = function updatePassword(data) {
	  return _constants.fb.auth().currentUser.updatePassword(data);
	};
	var login = exports.login = function login(email, password) {
	  return _constants.fb.auth().signInWithEmailAndPassword(email, password);
	};
	var logout = exports.logout = function logout() {
	  return _constants.fb.auth().signOut();
	};
	var register = exports.register = function register(email, password) {
	  return _constants.fb.auth().createUserWithEmailAndPassword(email, password);
	};
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(once, 'once', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(set, 'set', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(save, 'save', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(remove, 'remove', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(updateProfile, 'updateProfile', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(updatePassword, 'updatePassword', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(login, 'login', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(logout, 'logout', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	
	  __REACT_HOT_LOADER__.register(register, 'register', 'D:/repo.git/djalmajr/agencia-amiga/src/store/apis.js');
	}();

	;

/***/ },

/***/ "./node_modules/babel-runtime/core-js/promise.js":
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/fn/promise.js"), __esModule: true };

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/promise.js":
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(24);
	__webpack_require__(25);
	__webpack_require__(26);
	__webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.promise.js");
	module.exports = __webpack_require__(22).Promise;

/***/ },

/***/ 24:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1709);

/***/ },

/***/ 25:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1647);

/***/ },

/***/ 26:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1691);

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.promise.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(27)
	  , global             = __webpack_require__(28)
	  , ctx                = __webpack_require__(29)
	  , classof            = __webpack_require__(30)
	  , $export            = __webpack_require__(31)
	  , isObject           = __webpack_require__(32)
	  , aFunction          = __webpack_require__(33)
	  , anInstance         = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js")
	  , forOf              = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js")
	  , speciesConstructor = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js")
	  , task               = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js").set
	  , microtask          = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_microtask.js")()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(39)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js")($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(44)($Promise, PROMISE);
	__webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js")(PROMISE);
	Wrapper = __webpack_require__(22)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(47)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },

/***/ "./node_modules/react-hot-loader/patch.js":
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__("./node_modules/react-hot-loader/lib/patch.js");


/***/ },

/***/ 28:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1654);

/***/ },

/***/ 29:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1656);

/***/ },

/***/ 30:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1742);

/***/ },

/***/ 31:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1653);

/***/ },

/***/ 32:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1661);

/***/ },

/***/ 33:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1657);

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js":
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js":
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(29)
	  , call        = __webpack_require__(34)
	  , isArrayIter = __webpack_require__(35)
	  , anObject    = __webpack_require__(36)
	  , toLength    = __webpack_require__(37)
	  , getIterFn   = __webpack_require__(38)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },

/***/ 34:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1758);

/***/ },

/***/ 35:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1759);

/***/ },

/***/ 36:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1660);

/***/ },

/***/ 37:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1680);

/***/ },

/***/ 38:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1741);

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_species-constructor.js":
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(36)
	  , aFunction = __webpack_require__(33)
	  , SPECIES   = __webpack_require__(39)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },

/***/ 39:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1688);

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js":
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(29)
	  , invoke             = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_invoke.js")
	  , html               = __webpack_require__(40)
	  , cel                = __webpack_require__(41)
	  , global             = __webpack_require__(28)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(42)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_invoke.js":
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },

/***/ 40:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1686);

/***/ },

/***/ 41:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1665);

/***/ },

/***/ 42:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1678);

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_microtask.js":
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(28)
	  , macrotask = __webpack_require__("./node_modules/babel-runtime/node_modules/core-js/library/modules/_task.js").set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(42)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js":
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(43);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },

/***/ 43:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1658);

/***/ },

/***/ 44:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1687);

/***/ },

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-species.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(28)
	  , core        = __webpack_require__(22)
	  , dP          = __webpack_require__(45)
	  , DESCRIPTORS = __webpack_require__(46)
	  , SPECIES     = __webpack_require__(39)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },

/***/ 45:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1659);

/***/ },

/***/ 46:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1663);

/***/ },

/***/ 47:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1761);

/***/ },

/***/ "./src/constants.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Filter = exports.Cache = exports.fb = undefined;
	
	var _firebase = __webpack_require__(48);
	
	var _firebase2 = _interopRequireDefault(_firebase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_firebase2.default.initializeApp({
	  apiKey: 'AIzaSyAzTH_P735oVz2r5Ape5ZDj_o9RSzwl4k0',
	  authDomain: 'agencia-amiga.firebaseapp.com',
	  databaseURL: 'https://agencia-amiga.firebaseio.com',
	  storageBucket: 'agencia-amiga.appspot.com',
	  messagingSenderId: '323447297926'
	});
	
	var fb = exports.fb = _firebase2.default;
	
	var Cache = exports.Cache = {
	  KEY: 'AGENCIA_AMIGA_STATE'
	};
	
	var Filter = exports.Filter = {
	  OPTIONS: [{ text: 'Voluntrios', value: 'users', icon: 'user' }, { text: 'Organizaes', value: 'organizations', icon: 'university' }, { text: 'Servios', value: 'services', icon: 'wrench' }, { text: 'Campanhas', value: 'campaigns', icon: 'bullhorn' }]
	};
	
	window.fb = fb;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(fb, 'fb', 'D:/repo.git/djalmajr/agencia-amiga/src/constants.js');
	
	  __REACT_HOT_LOADER__.register(Cache, 'Cache', 'D:/repo.git/djalmajr/agencia-amiga/src/constants.js');
	
	  __REACT_HOT_LOADER__.register(Filter, 'Filter', 'D:/repo.git/djalmajr/agencia-amiga/src/constants.js');
	}();

	;

/***/ },

/***/ 48:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(2167);

/***/ },

/***/ "./src/helpers/gen-uid.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _constants = __webpack_require__("./src/constants.js");
	
	var _default = function _default(ref) {
	  return _constants.fb.database().ref().child(ref).push().key;
	};
	
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/helpers/gen-uid.js');
	}();

	;

/***/ },

/***/ "./src/store/sagas/entities.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _stringify = __webpack_require__("./node_modules/babel-runtime/core-js/json/stringify.js");
	
	var _stringify2 = _interopRequireDefault(_stringify);
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _regenerator = __webpack_require__("./node_modules/babel-runtime/regenerator/index.js");
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	exports.read = read;
	exports.remove = remove;
	exports.save = save;
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _effects = __webpack_require__("./node_modules/redux-saga/effects.js");
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	var _apis = __webpack_require__("./src/store/apis.js");
	
	var api = _interopRequireWildcard(_apis);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _marked = [read, remove, save].map(_regenerator2.default.mark);
	
	var attrs = {
	  users: ['skills', 'services', 'campaigns']
	};
	
	function read(action) {
	  var _this = this;
	
	  var _ref, uid, entity, snapshot, val, i, attr, error, message;
	
	  return _regenerator2.default.wrap(function read$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          _ref = action.payload || {}, uid = _ref.uid, entity = _ref.entity;
	          _context2.prev = 1;
	          _context2.next = 4;
	          return api.once(uid ? entity + '/' + uid : entity);
	
	        case 4:
	          snapshot = _context2.sent;
	          val = snapshot.val();
	
	          if (!attrs[entity]) {
	            _context2.next = 14;
	            break;
	          }
	
	          i = 0;
	
	        case 8:
	          if (!(attr = attrs[entity][i])) {
	            _context2.next = 14;
	            break;
	          }
	
	          if (!snapshot.hasChild(attr)) {
	            _context2.next = 11;
	            break;
	          }
	
	          return _context2.delegateYield(_regenerator2.default.mark(function _callee() {
	            var res, snap;
	            return _regenerator2.default.wrap(function _callee$(_context) {
	              while (1) {
	                switch (_context.prev = _context.next) {
	                  case 0:
	                    res = {};
	                    _context.next = 3;
	                    return api.once(attr);
	
	                  case 3:
	                    snap = _context.sent;
	
	
	                    _lodash2.default.forEach(val[attr], function (id) {
	                      if (snap.hasChild(id)) {
	                        res[id] = snap.child(id).val();
	                      }
	                    });
	
	                    _context.next = 7;
	                    return (0, _effects.put)(actions.updateCache({ entity: attr, response: res }));
	
	                  case 7:
	                  case 'end':
	                    return _context.stop();
	                }
	              }
	            }, _callee, _this);
	          })(), 't0', 11);
	
	        case 11:
	          i++;
	          _context2.next = 8;
	          break;
	
	        case 14:
	          _context2.next = 16;
	          return (0, _effects.put)(actions.updateCache({ entity: entity, response: uid ? (0, _defineProperty3.default)({}, uid, val) : val }));
	
	        case 16:
	          _context2.next = 26;
	          break;
	
	        case 18:
	          _context2.prev = 18;
	          _context2.t1 = _context2['catch'](1);
	          error = JSON.parse((0, _stringify2.default)(_context2.t1));
	          message = error.code === 'PERMISSION_DENIED' ? 'Sua sesso expirou. Por favor, faa login novamente' : 'Ocorreu um erro ao tentar realizar a ao solicitada. Por favor, tente novamente.';
	          _context2.next = 24;
	          return (0, _effects.put)(actions.notifyError(error.message || message));
	
	        case 24:
	          _context2.next = 26;
	          return (0, _effects.put)(actions.updateCache(_context2.t1));
	
	        case 26:
	        case 'end':
	          return _context2.stop();
	      }
	    }
	  }, _marked[0], this, [[1, 18]]);
	}
	
	function remove(action) {
	  var _action$payload, entity, uid, user;
	
	  return _regenerator2.default.wrap(function remove$(_context3) {
	    while (1) {
	      switch (_context3.prev = _context3.next) {
	        case 0:
	          _action$payload = action.payload, entity = _action$payload.entity, uid = _action$payload.uid;
	          _context3.prev = 1;
	          _context3.next = 4;
	          return api.remove(entity + '/' + uid);
	
	        case 4:
	          if (!(entity === 'services' || entity === 'campaigns')) {
	            _context3.next = 15;
	            break;
	          }
	
	          _context3.next = 7;
	          return (0, _effects.select)(_selectors2.default.getUser);
	
	        case 7:
	          user = _context3.sent;
	
	
	          user = _lodash2.default.merge({}, user);
	          delete user[entity][uid];
	          _context3.next = 12;
	          return api.save('users', user);
	
	        case 12:
	          user = _context3.sent;
	          _context3.next = 15;
	          return (0, _effects.put)(actions.updateCache({ entity: 'users', response: (0, _defineProperty3.default)({}, user.uid, user) }));
	
	        case 15:
	          _context3.next = 17;
	          return (0, _effects.put)(actions.removeCache({ entity: entity, uid: uid }));
	
	        case 17:
	          _context3.next = 26;
	          break;
	
	        case 19:
	          _context3.prev = 19;
	          _context3.t0 = _context3['catch'](1);
	
	          console.log(_context3.t0);_context3.next = 24;
	          return (0, _effects.put)(actions.notifyError(_context3.t0));
	
	        case 24:
	          _context3.next = 26;
	          return (0, _effects.put)(actions.removeCache(_context3.t0));
	
	        case 26:
	        case 'end':
	          return _context3.stop();
	      }
	    }
	  }, _marked[1], this, [[1, 19]]);
	}
	
	function save(action) {
	  var _ref3, ref, data, res;
	
	  return _regenerator2.default.wrap(function save$(_context4) {
	    while (1) {
	      switch (_context4.prev = _context4.next) {
	        case 0:
	          _ref3 = action.payload || {}, ref = _ref3.ref, data = _ref3.data;
	          _context4.prev = 1;
	          _context4.next = 4;
	          return api.save(ref, data);
	
	        case 4:
	          res = _context4.sent;
	          _context4.next = 7;
	          return (0, _effects.put)(actions.updateCache({ entity: ref, response: (0, _defineProperty3.default)({}, res.uid, res) }));
	
	        case 7:
	          _context4.next = 16;
	          break;
	
	        case 9:
	          _context4.prev = 9;
	          _context4.t0 = _context4['catch'](1);
	
	          console.log(_context4.t0);_context4.next = 14;
	          return (0, _effects.put)(actions.notifyError(_context4.t0));
	
	        case 14:
	          _context4.next = 16;
	          return (0, _effects.put)(actions.save(_context4.t0));
	
	        case 16:
	        case 'end':
	          return _context4.stop();
	      }
	    }
	  }, _marked[2], this, [[1, 9]]);
	}
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(attrs, 'attrs', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/entities.js');
	
	  __REACT_HOT_LOADER__.register(read, 'read', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/entities.js');
	
	  __REACT_HOT_LOADER__.register(remove, 'remove', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/entities.js');
	
	  __REACT_HOT_LOADER__.register(save, 'save', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/entities.js');
	}();

	;

/***/ },

/***/ "./src/store/selectors/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(49);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _auth = __webpack_require__("./src/store/selectors/auth.js");
	
	var auth = _interopRequireWildcard(_auth);
	
	var _entities = __webpack_require__("./src/store/selectors/entities.js");
	
	var entities = _interopRequireWildcard(_entities);
	
	var _global = __webpack_require__("./src/store/selectors/global.js");
	
	var global = _interopRequireWildcard(_global);
	
	var _filter = __webpack_require__("./src/store/selectors/filter.js");
	
	var filter = _interopRequireWildcard(_filter);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _default = (0, _extends3.default)({}, auth, entities, global, filter);
	
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/index.js');
	}();

	;

/***/ },

/***/ 49:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1720);

/***/ },

/***/ "./src/store/selectors/auth.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isAuthenticated = exports.isAuthenticating = exports.isRegistering = exports.getUser = exports.getAuth = undefined;
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _reselect = __webpack_require__(50);
	
	var _createGetData = __webpack_require__("./src/helpers/create-get-data.js");
	
	var _createGetData2 = _interopRequireDefault(_createGetData);
	
	var _entities = __webpack_require__("./src/store/selectors/entities.js");
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var getData = (0, _createGetData2.default)('auth');
	
	var getAuth = exports.getAuth = getData('authData');
	
	var getUser = exports.getUser = (0, _reselect.createSelector)(getAuth, function (state) {
	  return (0, _entities.getEntitiesByIds)('users', _lodash2.default, state);
	}, function (auth, fnGetUser) {
	  return fnGetUser([auth.uid])[auth.uid];
	});
	
	var isRegistering = exports.isRegistering = getData('isRegistering');
	var isAuthenticating = exports.isAuthenticating = getData('isAuthenticating');
	var isAuthenticated = exports.isAuthenticated = (0, _reselect.createSelector)(getAuth, function (auth) {
	  return !_lodash2.default.isEmpty(auth);
	});
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(getData, 'getData', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/auth.js');
	
	  __REACT_HOT_LOADER__.register(getAuth, 'getAuth', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/auth.js');
	
	  __REACT_HOT_LOADER__.register(getUser, 'getUser', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/auth.js');
	
	  __REACT_HOT_LOADER__.register(isRegistering, 'isRegistering', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/auth.js');
	
	  __REACT_HOT_LOADER__.register(isAuthenticating, 'isAuthenticating', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/auth.js');
	
	  __REACT_HOT_LOADER__.register(isAuthenticated, 'isAuthenticated', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/auth.js');
	}();

	;

/***/ },

/***/ 50:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1824);

/***/ },

/***/ "./src/helpers/create-get-data.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lodash = __webpack_require__(11);
	
	var _default = function _default(reducerName) {
	  return (0, _lodash.curry)(function (attr, state) {
	    return (0, _lodash.get)(state[reducerName], attr);
	  });
	};
	
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/helpers/create-get-data.js');
	}();

	;

/***/ },

/***/ "./src/store/selectors/entities.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getEntitiesByIds = exports.getEntity = exports.getEntities = exports.isRemoving = exports.isFetching = undefined;
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _createGetData = __webpack_require__("./src/helpers/create-get-data.js");
	
	var _createGetData2 = _interopRequireDefault(_createGetData);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var getData = (0, _createGetData2.default)('entities');
	
	var isFetching = exports.isFetching = function isFetching(entity) {
	  return getData('isFetching.' + entity);
	};
	var isRemoving = exports.isRemoving = function isRemoving(entity, id) {
	  return getData('isRemoving.' + entity + '.' + id);
	};
	var getEntities = exports.getEntities = function getEntities(entity) {
	  return getData('byId.' + entity);
	};
	var getEntity = exports.getEntity = function getEntity(entity, id) {
	  return getData('byId.' + entity + '.' + id);
	};
	
	var getEntitiesByIds = exports.getEntitiesByIds = _lodash2.default.curry(function (entity, ids, state) {
	  return ids.reduce(function (entities, id) {
	    entities[id] = getEntity(entity, id)(state) || {};
	    return entities;
	  }, {});
	});
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(getData, 'getData', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/entities.js');
	
	  __REACT_HOT_LOADER__.register(isFetching, 'isFetching', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/entities.js');
	
	  __REACT_HOT_LOADER__.register(isRemoving, 'isRemoving', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/entities.js');
	
	  __REACT_HOT_LOADER__.register(getEntities, 'getEntities', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/entities.js');
	
	  __REACT_HOT_LOADER__.register(getEntity, 'getEntity', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/entities.js');
	
	  __REACT_HOT_LOADER__.register(getEntitiesByIds, 'getEntitiesByIds', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/entities.js');
	}();

	;

/***/ },

/***/ "./src/store/selectors/global.js":
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isLoadingState = exports.isLoadingState = function isLoadingState(state) {
	  return state.asyncState.loading;
	};
	var isUpdatingProfile = exports.isUpdatingProfile = function isUpdatingProfile(state) {
	  return state.global.isUpdatingProfile;
	};
	
	var getCurrentTabFeed = exports.getCurrentTabFeed = function getCurrentTabFeed(state) {
	  return state.global.currentTabFeed;
	};
	var getNotification = exports.getNotification = function getNotification(state) {
	  return state.global.notification;
	};
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(isLoadingState, "isLoadingState", "D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/global.js");
	
	  __REACT_HOT_LOADER__.register(isUpdatingProfile, "isUpdatingProfile", "D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/global.js");
	
	  __REACT_HOT_LOADER__.register(getCurrentTabFeed, "getCurrentTabFeed", "D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/global.js");
	
	  __REACT_HOT_LOADER__.register(getNotification, "getNotification", "D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/global.js");
	}();

	;

/***/ },

/***/ "./src/store/selectors/filter.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getResults = exports.getSkillsFilter = exports.getEntityFilter = exports.getQueryFilter = exports.isFiltering = undefined;
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _latinize = __webpack_require__(51);
	
	var _latinize2 = _interopRequireDefault(_latinize);
	
	var _reselect = __webpack_require__(50);
	
	var _createGetData = __webpack_require__("./src/helpers/create-get-data.js");
	
	var _createGetData2 = _interopRequireDefault(_createGetData);
	
	var _entities = __webpack_require__("./src/store/selectors/entities.js");
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _getData = (0, _createGetData2.default)('filter');
	
	var format = function format(data) {
	  return {
	    title: data.name,
	    meta: data.email,
	    image: data.image,
	    description: data.resume || data.description || '',
	    created_at: data.created_at
	  };
	};
	
	var isFiltering = exports.isFiltering = _getData('isFiltering');
	var getQueryFilter = exports.getQueryFilter = _getData('query');
	var getEntityFilter = exports.getEntityFilter = _getData('entity');
	var getSkillsFilter = exports.getSkillsFilter = _getData('skills');
	
	var getResults = exports.getResults = (0, _reselect.createSelector)(getQueryFilter, getEntityFilter, getSkillsFilter, function (state) {
	  return _lodash2.default.curry(_entities.getEntities)(_lodash2.default, state);
	}, function (query, entity, skills, entityNames, fnGetEntities) {
	  var results = {};
	
	  _lodash2.default.forEach(fnGetEntities(entity), function (item) {
	    var match = (0, _latinize2.default)(item.title).toLowerCase().search(query) !== -1 && (!skills.length || _lodash2.default.intersection(_lodash2.default.values(item.skills), skills).length);
	
	    if (match) {
	      results[item.uid] = format(item);
	    }
	  });
	
	  return results;
	});
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(_getData, '_getData', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/filter.js');
	
	  __REACT_HOT_LOADER__.register(format, 'format', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/filter.js');
	
	  __REACT_HOT_LOADER__.register(isFiltering, 'isFiltering', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/filter.js');
	
	  __REACT_HOT_LOADER__.register(getQueryFilter, 'getQueryFilter', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/filter.js');
	
	  __REACT_HOT_LOADER__.register(getEntityFilter, 'getEntityFilter', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/filter.js');
	
	  __REACT_HOT_LOADER__.register(getSkillsFilter, 'getSkillsFilter', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/filter.js');
	
	  __REACT_HOT_LOADER__.register(getResults, 'getResults', 'D:/repo.git/djalmajr/agencia-amiga/src/store/selectors/filter.js');
	}();

	;

/***/ },

/***/ 51:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(2182);

/***/ },

/***/ "./src/store/sagas/profile.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _regenerator = __webpack_require__("./node_modules/babel-runtime/regenerator/index.js");
	
	var _regenerator2 = _interopRequireDefault(_regenerator);
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _objectWithoutProperties2 = __webpack_require__(52);
	
	var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);
	
	exports.update = update;
	exports.addToOrg = addToOrg;
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _effects = __webpack_require__("./node_modules/redux-saga/effects.js");
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actions = _interopRequireWildcard(_actions);
	
	var _apis = __webpack_require__("./src/store/apis.js");
	
	var api = _interopRequireWildcard(_apis);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _marked = [update, addToOrg].map(_regenerator2.default.mark);
	
	function update(_ref) {
	  var payload = _ref.payload;
	  var password, userData, user;
	  return _regenerator2.default.wrap(function update$(_context) {
	    while (1) {
	      switch (_context.prev = _context.next) {
	        case 0:
	          password = payload.password, userData = (0, _objectWithoutProperties3.default)(payload, ['password']);
	          _context.prev = 1;
	          _context.next = 4;
	          return api.save('users', userData);
	
	        case 4:
	          user = _context.sent;
	          _context.next = 7;
	          return api.updateProfile({ displayName: payload.name });
	
	        case 7:
	          if (!password) {
	            _context.next = 10;
	            break;
	          }
	
	          _context.next = 10;
	          return api.updatePassword(password);
	
	        case 10:
	          _context.next = 12;
	          return (0, _effects.put)(actions.notify('Dados atualizados!'));
	
	        case 12:
	          _context.next = 14;
	          return (0, _effects.put)(actions.updateCache({ entity: 'users', response: (0, _defineProperty3.default)({}, user.uid, user) }));
	
	        case 14:
	          _context.next = 23;
	          break;
	
	        case 16:
	          _context.prev = 16;
	          _context.t0 = _context['catch'](1);
	
	          console.log(_context.t0);_context.next = 21;
	          return (0, _effects.put)(actions.notifyError(_context.t0));
	
	        case 21:
	          _context.next = 23;
	          return (0, _effects.put)(actions.updateCache(_context.t0));
	
	        case 23:
	        case 'end':
	          return _context.stop();
	      }
	    }
	  }, _marked[0], this, [[1, 16]]);
	}
	
	function addToOrg(_ref2) {
	  var _ref2$payload = _ref2.payload,
	      data = _ref2$payload.data,
	      entity = _ref2$payload.entity;
	  var user, res, val;
	  return _regenerator2.default.wrap(function addToOrg$(_context2) {
	    while (1) {
	      switch (_context2.prev = _context2.next) {
	        case 0:
	          _context2.prev = 0;
	          _context2.next = 3;
	          return (0, _effects.select)(_selectors2.default.getUser);
	
	        case 3:
	          user = _context2.sent;
	          _context2.next = 6;
	          return api.save(entity, data);
	
	        case 6:
	          res = _context2.sent;
	          _context2.next = 9;
	          return api.save('users', _lodash2.default.merge({}, user, (0, _defineProperty3.default)({}, entity, (0, _defineProperty3.default)({}, res.uid, res.uid))));
	
	        case 9:
	          val = _context2.sent;
	          _context2.next = 12;
	          return (0, _effects.put)(actions.updateCache({ entity: entity, response: (0, _defineProperty3.default)({}, res.uid, res) }));
	
	        case 12:
	          _context2.next = 14;
	          return (0, _effects.put)(actions.updateCache({ entity: 'users', response: (0, _defineProperty3.default)({}, val.uid, val) }));
	
	        case 14:
	          _context2.next = 23;
	          break;
	
	        case 16:
	          _context2.prev = 16;
	          _context2.t0 = _context2['catch'](0);
	
	          console.log(_context2.t0);_context2.next = 21;
	          return (0, _effects.put)(actions.notifyError(_context2.t0));
	
	        case 21:
	          _context2.next = 23;
	          return (0, _effects.put)(actions.updateCache(_context2.t0));
	
	        case 23:
	        case 'end':
	          return _context2.stop();
	      }
	    }
	  }, _marked[1], this, [[0, 16]]);
	}
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(update, 'update', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/profile.js');
	
	  __REACT_HOT_LOADER__.register(addToOrg, 'addToOrg', 'D:/repo.git/djalmajr/agencia-amiga/src/store/sagas/profile.js');
	}();

	;

/***/ },

/***/ 52:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1641);

/***/ },

/***/ "./src/store/cache-state.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.saveState = exports.loadState = undefined;
	
	var _promise = __webpack_require__("./node_modules/babel-runtime/core-js/promise.js");
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _lodash = __webpack_require__(11);
	
	var _localforage = __webpack_require__(53);
	
	var _localforage2 = _interopRequireDefault(_localforage);
	
	var _constants = __webpack_require__("./src/constants.js");
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var loadState = exports.loadState = function loadState(currentState) {
	  return new _promise2.default(function (resolve) {
	    _localforage2.default.getItem(_constants.Cache.KEY, function (err) {
	      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	      if (err) {
	        console.log(err);
	      }
	
	      return resolve((0, _lodash.merge)({}, currentState, state));
	    });
	  });
	};
	
	var saveState = exports.saveState = function saveState(state) {
	  _localforage2.default.setItem(_constants.Cache.KEY, state);
	};
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(loadState, 'loadState', 'D:/repo.git/djalmajr/agencia-amiga/src/store/cache-state.js');
	
	  __REACT_HOT_LOADER__.register(saveState, 'saveState', 'D:/repo.git/djalmajr/agencia-amiga/src/store/cache-state.js');
	}();

	;

/***/ },

/***/ 53:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(2183);

/***/ },

/***/ "./src/devtools.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.showDevTools = exports.DevTools = undefined;
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(8);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reduxDevtools = __webpack_require__(54);
	
	var _reduxDevtoolsLogMonitor = __webpack_require__(55);
	
	var _reduxDevtoolsLogMonitor2 = _interopRequireDefault(_reduxDevtoolsLogMonitor);
	
	var _reduxDevtoolsDockMonitor = __webpack_require__(56);
	
	var _reduxDevtoolsDockMonitor2 = _interopRequireDefault(_reduxDevtoolsDockMonitor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DevTools = exports.DevTools = (0, _reduxDevtools.createDevTools)(_react2.default.createElement(
	  _reduxDevtoolsDockMonitor2.default,
	  {
	    fluid: true,
	    defaultSize: 1,
	    changePositionKey: 'ctrl-shift-y',
	    toggleVisibilityKey: 'ctrl-shift-h'
	  },
	  _react2.default.createElement(_reduxDevtoolsLogMonitor2.default, null)
	));
	
	var showDevTools = exports.showDevTools = function showDevTools(store) {
	  var popup = window.open(null, 'Redux DevTools', 'menubar=no,location=no,resizable=yes,scrollbars=no,status=no');
	
	  popup.location.reload();
	
	  setTimeout(function () {
	    popup.document.write('<div id="react-devtools-root"></div>');
	    _reactDom2.default.render(_react2.default.createElement(DevTools, { store: store }), popup.document.getElementById('react-devtools-root'));
	  }, 10);
	};
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(DevTools, 'DevTools', 'D:/repo.git/djalmajr/agencia-amiga/src/devtools.jsx');
	
	  __REACT_HOT_LOADER__.register(showDevTools, 'showDevTools', 'D:/repo.git/djalmajr/agencia-amiga/src/devtools.jsx');
	}();

	;

/***/ },

/***/ 54:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1563);

/***/ },

/***/ 55:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1589);

/***/ },

/***/ 56:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1780);

/***/ },

/***/ "./src/application.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _reactRouter = __webpack_require__(58);
	
	var _main = __webpack_require__("./src/views/containers/main.jsx");
	
	var _main2 = _interopRequireDefault(_main);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Application = function Application(_ref) {
	  var store = _ref.store;
	  return _react2.default.createElement(
	    _reactRedux.Provider,
	    { store: store },
	    _react2.default.createElement(
	      _reactRouter.BrowserRouter,
	      null,
	      _react2.default.createElement(_reactRouter.Match, { pattern: '/', component: _main2.default })
	    )
	  );
	};
	
	Application.propTypes = {
	  store: _react2.default.PropTypes.object
	};
	
	var _default = Application;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Application, 'Application', 'D:/repo.git/djalmajr/agencia-amiga/src/application.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/application.jsx');
	}();

	;

/***/ },

/***/ 57:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1345);

/***/ },

/***/ 58:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1374);

/***/ },

/***/ "./src/views/containers/main.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _lodash = __webpack_require__(11);
	
	var _reactRedux = __webpack_require__(57);
	
	var _redux = __webpack_require__(12);
	
	var _reactRouter = __webpack_require__(58);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _requireAuth = __webpack_require__("./src/helpers/require-auth.js");
	
	var _requireAuth2 = _interopRequireDefault(_requireAuth);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _feed = __webpack_require__("./src/views/content/feed/index.js");
	
	var _feed2 = _interopRequireDefault(_feed);
	
	var _buscar = __webpack_require__("./src/views/content/buscar/index.js");
	
	var _buscar2 = _interopRequireDefault(_buscar);
	
	var _campanha = __webpack_require__("./src/views/content/campanha/index.js");
	
	var _campanha2 = _interopRequireDefault(_campanha);
	
	var _organizacao = __webpack_require__("./src/views/content/organizacao/index.js");
	
	var _organizacao2 = _interopRequireDefault(_organizacao);
	
	var _servico = __webpack_require__("./src/views/content/servico/index.js");
	
	var _servico2 = _interopRequireDefault(_servico);
	
	var _usuario = __webpack_require__("./src/views/content/usuario/index.js");
	
	var _usuario2 = _interopRequireDefault(_usuario);
	
	var _login = __webpack_require__("./src/views/containers/login.jsx");
	
	var _login2 = _interopRequireDefault(_login);
	
	var _notification = __webpack_require__("./src/views/containers/notification.jsx");
	
	var _notification2 = _interopRequireDefault(_notification);
	
	var _topbar = __webpack_require__("./src/views/containers/topbar/index.js");
	
	var _topbar2 = _interopRequireDefault(_topbar);
	
	var _main = __webpack_require__("./src/views/containers/main.scss");
	
	var _main2 = _interopRequireDefault(_main);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Main = function (_React$PureComponent) {
	  (0, _inherits3.default)(Main, _React$PureComponent);
	
	  function Main() {
	    (0, _classCallCheck3.default)(this, Main);
	    return (0, _possibleConstructorReturn3.default)(this, (Main.__proto__ || (0, _getPrototypeOf2.default)(Main)).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Main, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(_ref) {
	      var actions = _ref.actions,
	          auth = _ref.auth,
	          hasSkills = _ref.hasSkills,
	          isLogged = _ref.isLogged,
	          user = _ref.user;
	
	      if (!isLogged) {
	        return;
	      }
	
	      if (!hasSkills) {
	        actions.read({ entity: 'skills' });
	      }
	
	      if (!user.id) {
	        actions.read({ entity: 'users', uid: auth.uid });
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          isLogged = _props.isLogged,
	          isLoadingState = _props.isLoadingState,
	          user = _props.user;
	
	
	      if (isLoadingState || !user.id) {
	        return _react2.default.createElement(
	          _flexElement2.default,
	          { column: true, full: true, align: 'center', justify: 'center', className: _main2.default.wrapper },
	          _react2.default.createElement(
	            _semanticUiReact.Loader,
	            { active: true },
	            _react2.default.createElement(
	              'span',
	              { style: { color: 'rgba(0,0,0, 0.45)' } },
	              'Carregando o sistema...'
	            )
	          )
	        );
	      }
	
	      return _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, className: _main2.default.wrapper },
	        _react2.default.createElement(_notification2.default, null),
	        isLogged && _react2.default.createElement(_topbar2.default, null),
	        _react2.default.createElement(
	          _flexElement2.default,
	          { full: true, className: _main2.default.content },
	          _react2.default.createElement(_reactRouter.Match, { pattern: '/', exactly: true, component: (0, _requireAuth2.default)(_feed2.default) }),
	          _react2.default.createElement(_reactRouter.Match, { pattern: '/login', component: _login2.default }),
	          _react2.default.createElement(_reactRouter.Match, { pattern: '/buscar', component: (0, _requireAuth2.default)(_buscar2.default) }),
	          _react2.default.createElement(_reactRouter.Match, { pattern: '/campanhas/:id', component: (0, _requireAuth2.default)(_campanha2.default) }),
	          _react2.default.createElement(_reactRouter.Match, { pattern: '/organizacoes/:id', component: (0, _requireAuth2.default)(_organizacao2.default) }),
	          _react2.default.createElement(_reactRouter.Match, { pattern: '/voluntarios/:id', component: (0, _requireAuth2.default)(_usuario2.default) }),
	          _react2.default.createElement(_reactRouter.Match, { pattern: '/servicos/:id', component: (0, _requireAuth2.default)(_servico2.default) })
	        )
	      );
	    }
	  }]);
	  return Main;
	}(_react2.default.PureComponent);
	
	Main.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  auth: _react2.default.PropTypes.object,
	  hasSkills: _react2.default.PropTypes.bool,
	  isLogged: _react2.default.PropTypes.bool,
	  isLoadingState: _react2.default.PropTypes.bool,
	  user: _react2.default.PropTypes.object
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    hasSkills: !(0, _lodash.isEmpty)(_selectors2.default.getEntities(state, 'skills')),
	    isLogged: _selectors2.default.isAuthenticated(state),
	    isLoadingState: _selectors2.default.isLoadingState(state),
	    auth: _selectors2.default.getAuth(state),
	    user: _selectors2.default.getUser(state)
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Main);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Main, 'Main', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/main.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/main.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/main.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/main.jsx');
	}();

	;

/***/ },

/***/ 59:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1787);

/***/ },

/***/ 60:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1642);

/***/ },

/***/ 61:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1794);

/***/ },

/***/ 62:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1643);

/***/ },

/***/ 63:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1712);

/***/ },

/***/ 64:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1825);

/***/ },

/***/ "./src/helpers/require-auth.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _objectWithoutProperties2 = __webpack_require__(52);
	
	var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _reactRouter = __webpack_require__(58);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var requireAuth = function requireAuth(ComposedComponent) {
	  var Auth = function Auth(_ref) {
	    var isAuthorized = _ref.isAuthorized,
	        otherProps = (0, _objectWithoutProperties3.default)(_ref, ['isAuthorized']);
	    return isAuthorized ? _react2.default.createElement(ComposedComponent, otherProps) : _react2.default.createElement(_reactRouter.Redirect, {
	      to: {
	        pathname: '/login',
	        state: {
	          redirect: (otherProps.location || {}).pathname === '/login' ? ((otherProps.location || {}).state || {}).redirect : otherProps.location
	        }
	      }
	    });
	  };
	
	  Auth.propTypes = {
	    isAuthorized: _react2.default.PropTypes.bool
	  };
	
	  var mapStateToProps = function mapStateToProps(state) {
	    return {
	      isAuthorized: _selectors2.default.isAuthenticated(state)
	    };
	  };
	
	  return (0, _reactRedux.connect)(mapStateToProps)(Auth);
	};
	
	var _default = requireAuth;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(requireAuth, 'requireAuth', 'D:/repo.git/djalmajr/agencia-amiga/src/helpers/require-auth.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/helpers/require-auth.js');
	}();

	;

/***/ },

/***/ "./src/views/components/flex-element/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/flex-element.jsx");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _default = _flexElement2.default;
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/components/flex-element/index.js');
	}();

	;

/***/ },

/***/ "./src/views/components/flex-element/flex-element.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(49);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(65);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _cnames = __webpack_require__("./src/helpers/cnames.js");
	
	var _cnames2 = _interopRequireDefault(_cnames);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/flex-element.scss");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _defaultProps = __webpack_require__("./src/views/components/default-props.jsx");
	
	var _defaultProps2 = _interopRequireDefault(_defaultProps);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FlexElement = function (_React$PureComponent) {
	  (0, _inherits3.default)(FlexElement, _React$PureComponent);
	
	  function FlexElement() {
	    (0, _classCallCheck3.default)(this, FlexElement);
	    return (0, _possibleConstructorReturn3.default)(this, (FlexElement.__proto__ || (0, _getPrototypeOf2.default)(FlexElement)).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(FlexElement, [{
	    key: 'getClassName',
	    value: function getClassName() {
	      var _classes;
	
	      var classes = (_classes = {
	        flex: true,
	        column: this.props.column,
	        disabled: this.props.disabled,
	        full: this.props.full,
	        row: !this.props.column
	      }, (0, _defineProperty3.default)(_classes, 'align-' + this.props.align, !!this.props.align), (0, _defineProperty3.default)(_classes, 'justify-' + this.props.justify, !!this.props.justify), _classes);
	
	      return (0, _classnames2.default)((0, _defineProperty3.default)({}, this.props.className, this.props.className), (0, _cnames2.default)(_flexElement2.default, classes));
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          children = _props.children,
	          component = _props.component,
	          innerRef = _props.innerRef,
	          style = _props.style,
	          onClick = _props.onClick;
	
	      var props = { ref: innerRef, style: style, className: this.getClassName(), onClick: onClick };
	
	      return _react2.default.createElement(component, props, children);
	    }
	  }]);
	  return FlexElement;
	}(_react2.default.PureComponent);
	
	FlexElement.propTypes = (0, _extends3.default)({}, _defaultProps2.default.propTypes, {
	  align: _react2.default.PropTypes.oneOf(['baseline', 'center', 'flex-end', 'flex-start', 'inherit', 'initial', 'stretch']),
	
	  column: _react2.default.PropTypes.bool,
	
	  full: _react2.default.PropTypes.bool,
	
	  justify: _react2.default.PropTypes.oneOf(['center', 'flex-end', 'flex-start', 'inherit', 'initial', 'space-around', 'space-between']),
	
	  row: _react2.default.PropTypes.bool,
	
	  onClick: _react2.default.PropTypes.func
	});
	FlexElement.defaultProps = (0, _extends3.default)({}, _defaultProps2.default.defaultProps);
	var _default = FlexElement;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(FlexElement, 'FlexElement', 'D:/repo.git/djalmajr/agencia-amiga/src/views/components/flex-element/flex-element.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/components/flex-element/flex-element.jsx');
	}();

	;

/***/ },

/***/ 65:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1);

/***/ },

/***/ "./src/helpers/cnames.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classnames = __webpack_require__(65);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _default = function _default(styles) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	
	  var result = [];
	
	  args.forEach(function (arg) {
	    var classes = (0, _classnames2.default)(arg);
	
	    classes.split(' ').forEach(function (cname) {
	      if (styles[cname]) {
	        result.push(styles[cname]);
	      }
	    });
	  });
	
	  return result.join(' ');
	};
	
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/helpers/cnames.js');
	}();

	;

/***/ },

/***/ "./src/views/components/flex-element/flex-element.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/components/flex-element/flex-element.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/components/flex-element/flex-element.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/components/flex-element/flex-element.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/components/flex-element/flex-element.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".flex-element__flex__3n1G9EvjaC {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative; }\n\n.flex-element__column__2xfc6QWVtl {\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column; }\n\n.flex-element__row__3lc3dZ14Z2 {\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row; }\n\n.flex-element__wrap__2V0JOVU1jv {\n  -ms-flex-wrap: wrap;\n      flex-wrap: wrap; }\n\n.flex-element__full__15R8IXwt4M {\n  -webkit-box-flex: 1;\n      -ms-flex: 1;\n          flex: 1; }\n\n.flex-element__disabled__aInL-gj8h0 {\n  cursor: not-allowed;\n  opacity: 0.6; }\n\n.flex-element__align-baseline__3rcCPYPgcm {\n  -webkit-box-align: baseline;\n      -ms-flex-align: baseline;\n          align-items: baseline; }\n\n.flex-element__align-center__1V22hiUx2p {\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center; }\n\n.flex-element__align-flex-end__Rj4x2CHy5b {\n  -webkit-box-align: end;\n      -ms-flex-align: end;\n          align-items: flex-end; }\n\n.flex-element__align-flex-start__1WsAsZPCXD {\n  -webkit-box-align: start;\n      -ms-flex-align: start;\n          align-items: flex-start; }\n\n.flex-element__align-stretch__dImETF0cSm {\n  -webkit-box-align: stretch;\n      -ms-flex-align: stretch;\n          align-items: stretch; }\n\n.flex-element__justify-center__8giI8q8xE0 {\n  -webkit-box-pack: center;\n      -ms-flex-pack: center;\n          justify-content: center; }\n\n.flex-element__justify-flex-end__F77Cyn98eU {\n  -webkit-box-pack: end;\n      -ms-flex-pack: end;\n          justify-content: flex-end; }\n\n.flex-element__justify-flex-start__3xRqqiey-A {\n  -webkit-box-pack: start;\n      -ms-flex-pack: start;\n          justify-content: flex-start; }\n\n.flex-element__justify-space-around__9CzogNVT8b {\n  -ms-flex-pack: distribute;\n      justify-content: space-around; }\n\n.flex-element__justify-space-between__3p_nuQaUnH {\n  -webkit-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between; }\n", "", {"version":3,"sources":["/./src/views/components/flex-element/src/views/components/flex-element/flex-element.scss"],"names":[],"mappings":"AAAA;EACE,qBAAc;EAAd,qBAAc;EAAd,cAAc;EACd,mBAAmB,EACpB;;AAED;EACE,6BAAuB;EAAvB,8BAAuB;MAAvB,2BAAuB;UAAvB,uBAAuB,EACxB;;AAED;EACE,+BAAoB;EAApB,8BAAoB;MAApB,wBAAoB;UAApB,oBAAoB,EACrB;;AAED;EACE,oBAAgB;MAAhB,gBAAgB,EACjB;;AAED;EACE,oBAAQ;MAAR,YAAQ;UAAR,QAAQ,EACT;;AAED;EACE,oBAAoB;EACpB,aAAa,EACd;;AAED;EACE,4BAAsB;MAAtB,yBAAsB;UAAtB,sBAAsB,EACvB;;AAED;EACE,0BAAoB;MAApB,uBAAoB;UAApB,oBAAoB,EACrB;;AAED;EACE,uBAAsB;MAAtB,oBAAsB;UAAtB,sBAAsB,EACvB;;AAED;EACE,yBAAwB;MAAxB,sBAAwB;UAAxB,wBAAwB,EACzB;;AAED;EACE,2BAAqB;MAArB,wBAAqB;UAArB,qBAAqB,EACtB;;AAED;EACE,yBAAwB;MAAxB,sBAAwB;UAAxB,wBAAwB,EACzB;;AAED;EACE,sBAA0B;MAA1B,mBAA0B;UAA1B,0BAA0B,EAC3B;;AAED;EACE,wBAA4B;MAA5B,qBAA4B;UAA5B,4BAA4B,EAC7B;;AAED;EACE,0BAA8B;MAA9B,8BAA8B,EAC/B;;AAED;EACE,0BAA+B;MAA/B,uBAA+B;UAA/B,+BAA+B,EAChC","file":"flex-element.scss","sourcesContent":[".flex {\n  display: flex;\n  position: relative;\n}\n\n.column {\n  flex-direction: column;\n}\n\n.row {\n  flex-direction: row;\n}\n\n.wrap {\n  flex-wrap: wrap;\n}\n\n.full {\n  flex: 1;\n}\n\n.disabled {\n  cursor: not-allowed;\n  opacity: 0.6;\n}\n\n.align-baseline {\n  align-items: baseline;\n}\n\n.align-center {\n  align-items: center;\n}\n\n.align-flex-end {\n  align-items: flex-end;\n}\n\n.align-flex-start {\n  align-items: flex-start;\n}\n\n.align-stretch {\n  align-items: stretch;\n}\n\n.justify-center {\n  justify-content: center;\n}\n\n.justify-flex-end {\n  justify-content: flex-end;\n}\n\n.justify-flex-start {\n  justify-content: flex-start;\n}\n\n.justify-space-around {\n  justify-content: space-around;\n}\n\n.justify-space-between {\n  justify-content: space-between;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"flex": "flex-element__flex__3n1G9EvjaC",
		"column": "flex-element__column__2xfc6QWVtl",
		"row": "flex-element__row__3lc3dZ14Z2",
		"wrap": "flex-element__wrap__2V0JOVU1jv",
		"full": "flex-element__full__15R8IXwt4M",
		"disabled": "flex-element__disabled__aInL-gj8h0",
		"align-baseline": "flex-element__align-baseline__3rcCPYPgcm",
		"align-center": "flex-element__align-center__1V22hiUx2p",
		"align-flex-end": "flex-element__align-flex-end__Rj4x2CHy5b",
		"align-flex-start": "flex-element__align-flex-start__1WsAsZPCXD",
		"align-stretch": "flex-element__align-stretch__dImETF0cSm",
		"justify-center": "flex-element__justify-center__8giI8q8xE0",
		"justify-flex-end": "flex-element__justify-flex-end__F77Cyn98eU",
		"justify-flex-start": "flex-element__justify-flex-start__3xRqqiey-A",
		"justify-space-around": "flex-element__justify-space-around__9CzogNVT8b",
		"justify-space-between": "flex-element__justify-space-between__3p_nuQaUnH"
	};

/***/ },

/***/ "./src/views/components/default-props.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _elementType = __webpack_require__(66);
	
	var _elementType2 = _interopRequireDefault(_elementType);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DefaultProps = function DefaultProps() {
	  return _react2.default.createElement('noscript', null);
	};
	
	DefaultProps.propTypes = {
	  children: _react2.default.PropTypes.node,
	
	  className: _react2.default.PropTypes.string,
	
	  component: _elementType2.default,
	
	  style: _react2.default.PropTypes.object
	};
	
	DefaultProps.defaultProps = {
	  className: '',
	  component: 'div',
	  style: {}
	};
	
	var _default = DefaultProps;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(DefaultProps, 'DefaultProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/components/default-props.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/components/default-props.jsx');
	}();

	;

/***/ },

/***/ 66:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1343);

/***/ },

/***/ "./src/views/content/feed/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _objectWithoutProperties2 = __webpack_require__(52);
	
	var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _organization = __webpack_require__("./src/views/content/feed/organization/index.js");
	
	var _organization2 = _interopRequireDefault(_organization);
	
	var _volunteer = __webpack_require__("./src/views/content/feed/volunteer/index.js");
	
	var _volunteer2 = _interopRequireDefault(_volunteer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Feed = function Feed(_ref) {
	  var user = _ref.user,
	      props = (0, _objectWithoutProperties3.default)(_ref, ['user']);
	  return user.type === 'organization' ? _react2.default.createElement(_organization2.default, props) : _react2.default.createElement(_volunteer2.default, props);
	};
	
	Feed.propTypes = {
	  user: _react2.default.PropTypes.object
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    user: _selectors2.default.getUser(state)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(Feed);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Feed, 'Feed', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/index.js');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _threeColumns = __webpack_require__("./src/views/components/three-columns.jsx");
	
	var _threeColumns2 = _interopRequireDefault(_threeColumns);
	
	var _panel = __webpack_require__("./src/views/content/feed/organization/panel.jsx");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	var _details = __webpack_require__("./src/views/content/feed/organization/details.jsx");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Usuario = function Usuario(props) {
	  return _react2.default.createElement(_threeColumns2.default, {
	    panel: _react2.default.createElement(_panel2.default, props),
	    content: _react2.default.createElement(_details2.default, props)
	  });
	};
	
	var _default = Usuario;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Usuario, 'Usuario', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/index.js');
	}();

	;

/***/ },

/***/ "./src/views/components/three-columns.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ThreeColumns = function ThreeColumns(_ref) {
	  var content = _ref.content,
	      panel = _ref.panel,
	      related = _ref.related;
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { full: true },
	    _react2.default.createElement(
	      _flexElement2.default,
	      { column: true },
	      panel
	    ),
	    _react2.default.createElement(
	      _flexElement2.default,
	      { column: true, full: true },
	      content
	    ),
	    _react2.default.createElement(
	      _flexElement2.default,
	      { column: true },
	      related
	    )
	  );
	};
	
	ThreeColumns.propTypes = {
	  content: _react2.default.PropTypes.node,
	  panel: _react2.default.PropTypes.node,
	  related: _react2.default.PropTypes.node
	};
	
	var _default = ThreeColumns;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(ThreeColumns, 'ThreeColumns', 'D:/repo.git/djalmajr/agencia-amiga/src/views/components/three-columns.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/components/three-columns.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/panel.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var style = {
	  fontSize: '1rem',
	  marginRight: '0.8em',
	  width: '16em'
	};
	
	var Panel = function Panel() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, style: style },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      _react2.default.createElement(
	        _semanticUiReact.Header,
	        { as: 'h5', style: { fontSize: '0.95em' } },
	        'PEDIDOS DE VOLUNT\xC1RIOS'
	      ),
	      _react2.default.createElement(
	        _semanticUiReact.Header,
	        { as: 'h5', style: { fontSize: '0.95em' } },
	        'SERVI\xC7OS ABERTOS'
	      )
	    )
	  );
	};
	
	Panel.propTypes = {
	  skills: _react2.default.PropTypes.object,
	  user: _react2.default.PropTypes.object
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    user: _selectors2.default.getUser(state),
	    skills: _selectors2.default.getEntities(state, 'skills')
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(Panel);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(style, 'style', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(Panel, 'Panel', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/panel.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/details.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _timeline = __webpack_require__("./src/views/content/feed/organization/tabs/timeline.jsx");
	
	var _timeline2 = _interopRequireDefault(_timeline);
	
	var _campaigns = __webpack_require__("./src/views/content/feed/organization/tabs/campaigns/index.js");
	
	var _campaigns2 = _interopRequireDefault(_campaigns);
	
	var _services = __webpack_require__("./src/views/content/feed/organization/tabs/services/index.js");
	
	var _services2 = _interopRequireDefault(_services);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var views = {
	  timeline: {
	    description: 'Feed',
	    component: _timeline2.default
	  },
	  campaigns: {
	    description: 'Campanhas',
	    component: _campaigns2.default
	  },
	  services: {
	    description: 'Servios',
	    component: _services2.default
	  }
	};
	
	var Details = function Details(_ref) {
	  var active = _ref.active,
	      onTabClick = _ref.onTabClick;
	
	  var Component = views[active].component;
	
	  return _react2.default.createElement(
	    _semanticUiReact.Container,
	    { fluid: true, style: { fontSize: '1rem' } },
	    _react2.default.createElement(
	      _semanticUiReact.Menu,
	      { attached: 'top', tabular: true },
	      _lodash2.default.map(views, function (val, key) {
	        return _react2.default.createElement(
	          _semanticUiReact.Menu.Item,
	          {
	            key: key,
	            name: key,
	            active: active === key,
	            onClick: onTabClick
	          },
	          val.description
	        );
	      })
	    ),
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      { attached: 'bottom' },
	      _react2.default.createElement(Component, null)
	    )
	  );
	};
	
	Details.propTypes = {
	  active: _react2.default.PropTypes.string,
	  onTabClick: _react2.default.PropTypes.func
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    active: _selectors2.default.getCurrentTabFeed(state)
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    onTabClick: function onTabClick(evt, _ref2) {
	      var name = _ref2.name;
	      return dispatch(actionCreators.updateTabFeed(name));
	    }
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Details);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(views, 'views', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/details.jsx');
	
	  __REACT_HOT_LOADER__.register(Details, 'Details', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/details.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/details.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/details.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/details.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/timeline.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _moment = __webpack_require__(7);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var styles = {
	  emptyContainer: { height: 300, fontSize: '1rem' },
	  emptyContent: { maxWidth: 350 },
	  emptyIcon: { color: 'rgba(0,0,0,0.1)', fontSize: '6em' },
	  emptyText: { color: 'rgba(0,0,0,0.5)', marginTop: '1em', textAlign: 'center' }
	};
	
	var Timeline = function Timeline(_ref) {
	  var feed = _ref.feed;
	
	  if (_lodash2.default.isEmpty(feed)) {
	    return _react2.default.createElement(
	      _flexElement2.default,
	      { column: true, align: 'center', justify: 'center', style: styles.emptyContainer },
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, align: 'center', justify: 'center', style: styles.emptyContent },
	        _react2.default.createElement(_semanticUiReact.Icon, { name: 'cloud', style: styles.emptyIcon }),
	        _react2.default.createElement(
	          'span',
	          { style: styles.emptyText },
	          'Est\xE1 meio parado por aqui... Que tal procurar por volunt\xE1rios, criar campanhas ou servi\xE7os?'
	        )
	      )
	    );
	  }
	
	  return _react2.default.createElement(
	    _semanticUiReact.Feed,
	    null,
	    _lodash2.default.keys(feed).sort().reverse().map(function (key) {
	      return _react2.default.createElement(
	        _semanticUiReact.Feed.Event,
	        { key: key, style: { borderBottom: '1px solid #eee' } },
	        _react2.default.createElement(
	          _semanticUiReact.Feed.Label,
	          null,
	          _react2.default.createElement(_semanticUiReact.Icon, { circular: true, name: feed[key].icon, style: { color: 'rgba(0,0,0,0.3)', fontSize: '1.4em' } })
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Feed.Content,
	          null,
	          _react2.default.createElement(_semanticUiReact.Feed.Date, { content: (0, _moment2.default)(parseInt(key, 10)).fromNow() }),
	          _react2.default.createElement(
	            _semanticUiReact.Feed.Summary,
	            null,
	            _react2.default.createElement(
	              'span',
	              { style: { fontWeight: 'normal' } },
	              feed[key].pretext
	            ),
	            ' ',
	            feed[key].text
	          )
	        )
	      );
	    })
	  );
	};
	
	Timeline.propTypes = {
	  feed: _react2.default.PropTypes.object
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    feed: _selectors2.default.getFeed(state)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(Timeline);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(styles, 'styles', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/timeline.jsx');
	
	  __REACT_HOT_LOADER__.register(Timeline, 'Timeline', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/timeline.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/timeline.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/timeline.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/campaigns/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _campaigns = __webpack_require__("./src/views/content/feed/organization/tabs/campaigns/campaigns.jsx");
	
	var _campaigns2 = _interopRequireDefault(_campaigns);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _default = _campaigns2.default;
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/campaigns/campaigns.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _redux = __webpack_require__(12);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _campaign = __webpack_require__("./src/views/content/feed/organization/tabs/campaigns/campaign.jsx");
	
	var _campaign2 = _interopRequireDefault(_campaign);
	
	var _modal = __webpack_require__("./src/views/content/feed/organization/tabs/campaigns/modal.jsx");
	
	var _modal2 = _interopRequireDefault(_modal);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var styles = {
	  emptyContainer: { height: 300, fontSize: '1rem' },
	  emptyIcon: { color: 'rgba(0,0,0,0.1)', fontSize: '6em' },
	  emptyText: { color: 'rgba(0,0,0,0.5)', marginTop: '1em', textAlign: 'center' }
	};
	
	var Campaigns = function (_React$Component) {
	  (0, _inherits3.default)(Campaigns, _React$Component);
	
	  function Campaigns() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, Campaigns);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Campaigns.__proto__ || (0, _getPrototypeOf2.default)(Campaigns)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      selectedId: null,
	      isModalOpen: false
	    }, _this.handleClose = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleClose__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleCreate = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleCreate__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleEdit = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleEdit__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _this.handleRemove = function () {
	      var _this5;
	
	      return (_this5 = _this).__handleRemove__REACT_HOT_LOADER__.apply(_this5, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(Campaigns, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          actions = _props.actions,
	          hasCampaigns = _props.hasCampaigns,
	          isLogged = _props.isLogged,
	          isFetching = _props.isFetching;
	
	
	      if (!hasCampaigns && isLogged && !isFetching) {
	        actions.read({ entity: 'campaigns' });
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(_ref2) {
	      var actions = _ref2.actions,
	          campaigns = _ref2.user.campaigns;
	
	      var oldCampaigns = this.props.user.campaigns;
	
	      if (campaigns !== oldCampaigns) {
	        var newLen = _lodash2.default.keys(campaigns).length;
	        var oldLen = _lodash2.default.keys(oldCampaigns).length;
	        var operation = newLen > oldLen && 'criada' || newLen < oldLen && 'removida' || 'editada';
	
	        this.handleClose();
	
	        actions.notify('Campanha ' + operation + ' com sucesso!');
	      }
	    }
	  }, {
	    key: '__handleClose__REACT_HOT_LOADER__',
	    value: function __handleClose__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: false });
	    }
	  }, {
	    key: '__handleCreate__REACT_HOT_LOADER__',
	    value: function __handleCreate__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: true, selectedId: null });
	    }
	  }, {
	    key: '__handleEdit__REACT_HOT_LOADER__',
	    value: function __handleEdit__REACT_HOT_LOADER__(selectedId) {
	      this.setState({ isOpen: true, selectedId: selectedId });
	    }
	  }, {
	    key: '__handleRemove__REACT_HOT_LOADER__',
	    value: function __handleRemove__REACT_HOT_LOADER__(uid) {
	      this.props.actions.remove({ entity: 'campaigns', uid: uid });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this6 = this;
	
	      var _state = this.state,
	          isOpen = _state.isOpen,
	          selectedId = _state.selectedId;
	      var _props2 = this.props,
	          isFetching = _props2.isFetching,
	          user = _props2.user;
	
	
	      return _react2.default.createElement(
	        _flexElement2.default,
	        { column: true },
	        _react2.default.createElement(
	          _flexElement2.default,
	          { justify: 'flex-end' },
	          _react2.default.createElement(_semanticUiReact.Button, {
	            compact: true,
	            primary: true,
	            icon: 'plus',
	            size: 'small',
	            content: 'Campanha',
	            onClick: this.handleCreate
	          })
	        ),
	        _react2.default.createElement(_modal2.default, { isOpen: isOpen, uid: selectedId, onClose: this.handleClose }),
	        _react2.default.createElement(_semanticUiReact.Divider, { style: { marginBottom: 0 } }),
	        isFetching && !_lodash2.default.isEmpty(user.campaigns) && _react2.default.createElement(
	          _flexElement2.default,
	          { column: true, align: 'center', justify: 'center', style: styles.emptyContainer },
	          _react2.default.createElement(
	            _semanticUiReact.Loader,
	            { active: true },
	            _react2.default.createElement(
	              'span',
	              { style: { color: 'rgba(0,0,0, 0.45)' } },
	              'Carregando campanhas...'
	            )
	          )
	        ),
	        !isFetching && _lodash2.default.isEmpty(user.campaigns) && _react2.default.createElement(
	          _flexElement2.default,
	          { column: true, align: 'center', justify: 'center', style: styles.emptyContainer },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'bullhorn', style: styles.emptyIcon }),
	          _react2.default.createElement(
	            'span',
	            { style: styles.emptyText },
	            'Clique no bot\xE3o acima para adicionar um campanha.'
	          )
	        ),
	        !isFetching && !_lodash2.default.isEmpty(user.campaigns) && _react2.default.createElement(
	          _semanticUiReact.Table,
	          { basic: 'very', style: { margin: 0 } },
	          _react2.default.createElement(
	            _semanticUiReact.Table.Body,
	            null,
	            _lodash2.default.map(user.campaigns, function (uid) {
	              return _react2.default.createElement(_campaign2.default, {
	                key: uid,
	                uid: uid,
	                onEdit: _this6.handleEdit,
	                onRemove: _this6.handleRemove
	              });
	            })
	          )
	        )
	      );
	    }
	  }]);
	  return Campaigns;
	}(_react2.default.Component);
	
	Campaigns.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  isFetching: _react2.default.PropTypes.bool,
	  isLogged: _react2.default.PropTypes.bool,
	  hasCampaigns: _react2.default.PropTypes.bool,
	  user: _react2.default.PropTypes.object
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    user: _selectors2.default.getUser(state),
	    isLogged: _selectors2.default.isAuthenticated(state),
	    isFetching: _selectors2.default.isFetching(state, 'campaigns'),
	    hasCampaigns: !_lodash2.default.isEmpty(_selectors2.default.getEntities(state, 'campaigns'))
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Campaigns);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(styles, 'styles', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaigns.jsx');
	
	  __REACT_HOT_LOADER__.register(Campaigns, 'Campaigns', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaigns.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaigns.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaigns.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaigns.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/campaigns/campaign.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var styles = {
	  edit: { marginRight: 10 },
	  remove: { marginTop: -1 },
	  loader: { marginLeft: 8, marginRight: 5, position: 'relative' }
	};
	
	var Campaign = function (_React$Component) {
	  (0, _inherits3.default)(Campaign, _React$Component);
	
	  function Campaign() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, Campaign);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Campaign.__proto__ || (0, _getPrototypeOf2.default)(Campaign)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      isOpen: false
	    }, _this.handleClose = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleClose__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleOpen = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleOpen__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleRemove = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleRemove__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(Campaign, [{
	    key: '__handleClose__REACT_HOT_LOADER__',
	    value: function __handleClose__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: false });
	    }
	  }, {
	    key: '__handleOpen__REACT_HOT_LOADER__',
	    value: function __handleOpen__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: true });
	    }
	  }, {
	    key: '__handleRemove__REACT_HOT_LOADER__',
	    value: function __handleRemove__REACT_HOT_LOADER__() {
	      var _this5 = this;
	
	      this.setState({ isOpen: false }, function () {
	        _this5.props.onRemove(_this5.props.uid);
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var isOpen = this.state.isOpen;
	      var _props = this.props,
	          isRemoving = _props.isRemoving,
	          campaign = _props.campaign,
	          onEdit = _props.onEdit;
	
	      var trigger = isRemoving ? _react2.default.createElement(
	        'span',
	        { style: styles.loader },
	        _react2.default.createElement(_semanticUiReact.Loader, { active: true, size: 'mini' })
	      ) : _react2.default.createElement(_semanticUiReact.Icon, { link: true, name: 'trash outline', style: styles.remove, onClick: this.handleOpen });
	
	      return _react2.default.createElement(
	        _semanticUiReact.Table.Row,
	        null,
	        _react2.default.createElement(
	          _semanticUiReact.Table.Cell,
	          null,
	          _react2.default.createElement(
	            _semanticUiReact.Header,
	            { as: 'h4', image: true },
	            _react2.default.createElement(_semanticUiReact.Icon, { name: 'bullhorn' }),
	            _react2.default.createElement(
	              _semanticUiReact.Header.Content,
	              null,
	              campaign.name,
	              _react2.default.createElement(
	                _semanticUiReact.Header.Subheader,
	                null,
	                (campaign.details || '').length > 200 ? campaign.details.substr(0, 200) + '...' : campaign.details
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Table.Cell,
	          { collapsing: true },
	          _react2.default.createElement(_semanticUiReact.Icon, {
	            link: true,
	            name: 'edit',
	            style: styles.edit,
	            onClick: function onClick() {
	              return onEdit(campaign.uid);
	            }
	          }),
	          _react2.default.createElement(
	            _semanticUiReact.Modal,
	            {
	              size: 'small',
	              open: isOpen,
	              trigger: trigger,
	              closeOnEscape: false,
	              closeOnRootNodeClick: false
	            },
	            _react2.default.createElement(_semanticUiReact.Header, { size: 'mini', content: 'Remover Campanha' }),
	            _react2.default.createElement(
	              _semanticUiReact.Modal.Content,
	              null,
	              'Confirmar a remo\xE7\xE3o de ',
	              _react2.default.createElement(
	                'strong',
	                null,
	                campaign.name
	              ),
	              '?'
	            ),
	            _react2.default.createElement(
	              _semanticUiReact.Modal.Actions,
	              null,
	              _react2.default.createElement(
	                _semanticUiReact.Button,
	                { onClick: this.handleClose },
	                _react2.default.createElement(_semanticUiReact.Icon, { name: 'remove' }),
	                ' N\xE3o'
	              ),
	              _react2.default.createElement(
	                _semanticUiReact.Button,
	                { color: 'red', onClick: this.handleRemove },
	                _react2.default.createElement(_semanticUiReact.Icon, { name: 'trash outline' }),
	                ' Sim'
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	  return Campaign;
	}(_react2.default.Component);
	
	Campaign.propTypes = {
	  isRemoving: _react2.default.PropTypes.bool,
	  campaign: _react2.default.PropTypes.object,
	  uid: _react2.default.PropTypes.string,
	  onEdit: _react2.default.PropTypes.func,
	  onRemove: _react2.default.PropTypes.func
	};
	
	
	var mapStateToProps = function mapStateToProps(state, _ref2) {
	  var uid = _ref2.uid;
	  return {
	    campaign: _selectors2.default.getEntities(state, 'campaigns', uid),
	    isRemoving: _selectors2.default.isRemoving(state, 'campaigns', uid)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(Campaign);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(styles, 'styles', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaign.jsx');
	
	  __REACT_HOT_LOADER__.register(Campaign, 'Campaign', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaign.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaign.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/campaign.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/campaigns/modal.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(12);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  formData: {
	    name: '',
	    details: ''
	  }
	};
	
	var ModalCampaign = function (_React$Component) {
	  (0, _inherits3.default)(ModalCampaign, _React$Component);
	
	  function ModalCampaign() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, ModalCampaign);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = ModalCampaign.__proto__ || (0, _getPrototypeOf2.default)(ModalCampaign)).call.apply(_ref, [this].concat(args))), _this), _this.state = initialState, _this.handleClose = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleClose__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleOpen = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleOpen__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleChange = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleChange__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _this.handleSubmit = function () {
	      var _this5;
	
	      return (_this5 = _this).__handleSubmit__REACT_HOT_LOADER__.apply(_this5, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(ModalCampaign, [{
	    key: '__handleClose__REACT_HOT_LOADER__',
	    value: function __handleClose__REACT_HOT_LOADER__() {
	      this.props.onClose();
	    }
	  }, {
	    key: '__handleOpen__REACT_HOT_LOADER__',
	    value: function __handleOpen__REACT_HOT_LOADER__() {
	      var campaign = this.props.campaign;
	
	
	      this.setState({
	        formData: {
	          name: campaign.name || '',
	          details: campaign.details || ''
	        }
	      });
	    }
	  }, {
	    key: '__handleChange__REACT_HOT_LOADER__',
	    value: function __handleChange__REACT_HOT_LOADER__(e) {
	      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	      var formData = _lodash2.default.merge({}, this.state.formData);
	      var name = data.name || e.currentTarget.name;
	      var value = data.value || e.currentTarget.value;
	
	      formData[name] = value;
	
	      this.setState({ formData: formData });
	    }
	  }, {
	    key: '__handleSubmit__REACT_HOT_LOADER__',
	    value: function __handleSubmit__REACT_HOT_LOADER__(evt) {
	      var formData = this.state.formData;
	      var _props = this.props,
	          actions = _props.actions,
	          campaign = _props.campaign;
	
	
	      evt.preventDefault();
	
	      if (this.isValid(formData)) {
	        actions.addToOrg({
	          entity: 'campaigns',
	          data: _lodash2.default.assign({}, campaign, formData)
	        });
	      }
	    }
	  }, {
	    key: 'isValid',
	    value: function isValid(data) {
	      var isValid = !['name', 'details'].map(function (attr) {
	        return data[attr];
	      }).some(function (val) {
	        return _lodash2.default.isEmpty(val);
	      });
	
	      if (!isValid) {
	        this.props.actions.notifyError(' necessrio preencher os campos obrigatrios');
	      }
	
	      return isValid;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props2 = this.props,
	          isOpen = _props2.isOpen,
	          isSaving = _props2.isSaving,
	          campaign = _props2.campaign;
	      var formData = this.state.formData;
	
	
	      return _react2.default.createElement(
	        _semanticUiReact.Modal,
	        {
	          open: isOpen,
	          closeOnEscape: false,
	          closeOnRootNodeClick: false,
	          onMount: this.handleOpen,
	          onClose: this.handleClose
	        },
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Header,
	          null,
	          campaign.uid ? 'Editar Campanha' : 'Nova Campanha'
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Content,
	          { as: _semanticUiReact.Form, onSubmit: this.handleSubmit },
	          _react2.default.createElement(_semanticUiReact.Form.Input, {
	            required: true,
	            name: 'name',
	            label: 'Nome',
	            placeholder: 'Nome que ser\xE1 exibido nos resultados da pesquisa',
	            disabled: isSaving,
	            value: formData.name,
	            onChange: this.handleChange
	          }),
	          _react2.default.createElement(_semanticUiReact.Form.TextArea, {
	            required: true,
	            rows: '6',
	            name: 'details',
	            label: 'Detalhes',
	            placeholder: 'Do que se trata esta campanha?',
	            disabled: isSaving,
	            value: formData.details,
	            onChange: this.handleChange
	          })
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Actions,
	          { as: _flexElement2.default, justify: 'flex-end' },
	          _react2.default.createElement(_semanticUiReact.Button, {
	            content: 'Fechar',
	            disabled: isSaving,
	            onClick: this.handleClose
	          }),
	          _react2.default.createElement(_semanticUiReact.Button, {
	            primary: true,
	            icon: 'save',
	            content: 'Salvar',
	            loading: isSaving,
	            disabled: isSaving,
	            onClick: this.handleSubmit
	          })
	        )
	      );
	    }
	  }]);
	  return ModalCampaign;
	}(_react2.default.Component);
	
	ModalCampaign.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  campaign: _react2.default.PropTypes.object,
	  isOpen: _react2.default.PropTypes.bool,
	  isSaving: _react2.default.PropTypes.bool,
	  onClose: _react2.default.PropTypes.func
	};
	ModalCampaign.defaultProps = {
	  campaign: {}
	};
	
	
	var mapStateToProps = function mapStateToProps(state, _ref2) {
	  var uid = _ref2.uid;
	  return {
	    user: _selectors2.default.getUser(state),
	    campaign: _selectors2.default.getEntities(state, 'campaigns', uid),
	    isSaving: _selectors2.default.isFetching(state, 'campaigns') || _selectors2.default.isFetching(state, 'users')
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(ModalCampaign);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(initialState, 'initialState', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(ModalCampaign, 'ModalCampaign', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/campaigns/modal.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/services/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _services = __webpack_require__("./src/views/content/feed/organization/tabs/services/services.jsx");
	
	var _services2 = _interopRequireDefault(_services);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _default = _services2.default;
	exports.default = _default;
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }

	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/services/services.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _redux = __webpack_require__(12);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _service = __webpack_require__("./src/views/content/feed/organization/tabs/services/service.jsx");
	
	var _service2 = _interopRequireDefault(_service);
	
	var _modal = __webpack_require__("./src/views/content/feed/organization/tabs/services/modal.jsx");
	
	var _modal2 = _interopRequireDefault(_modal);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var styles = {
	  emptyContainer: { height: 300, fontSize: '1rem' },
	  emptyIcon: { color: 'rgba(0,0,0,0.1)', fontSize: '6em' },
	  emptyText: { color: 'rgba(0,0,0,0.5)', marginTop: '1em', textAlign: 'center' }
	};
	
	var Services = function (_React$Component) {
	  (0, _inherits3.default)(Services, _React$Component);
	
	  function Services() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, Services);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Services.__proto__ || (0, _getPrototypeOf2.default)(Services)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      selectedId: null,
	      isModalOpen: false
	    }, _this.handleClose = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleClose__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleCreate = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleCreate__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleEdit = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleEdit__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _this.handleRemove = function () {
	      var _this5;
	
	      return (_this5 = _this).__handleRemove__REACT_HOT_LOADER__.apply(_this5, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(Services, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          actions = _props.actions,
	          hasServices = _props.hasServices,
	          isLogged = _props.isLogged,
	          isFetching = _props.isFetching;
	
	
	      if (!hasServices && isLogged && !isFetching) {
	        actions.read({ entity: 'services' });
	      }
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(_ref2) {
	      var actions = _ref2.actions,
	          services = _ref2.user.services;
	
	      var oldServices = this.props.user.services;
	
	      if (services !== oldServices) {
	        var newLen = _lodash2.default.keys(services).length;
	        var oldLen = _lodash2.default.keys(oldServices).length;
	        var operation = newLen > oldLen && 'criado' || newLen < oldLen && 'removido' || 'editado';
	
	        this.handleClose();
	
	        actions.notify('Servi\xE7o ' + operation + ' com sucesso!');
	      }
	    }
	  }, {
	    key: '__handleClose__REACT_HOT_LOADER__',
	    value: function __handleClose__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: false });
	    }
	  }, {
	    key: '__handleCreate__REACT_HOT_LOADER__',
	    value: function __handleCreate__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: true, selectedId: null });
	    }
	  }, {
	    key: '__handleEdit__REACT_HOT_LOADER__',
	    value: function __handleEdit__REACT_HOT_LOADER__(selectedId) {
	      this.setState({ isOpen: true, selectedId: selectedId });
	    }
	  }, {
	    key: '__handleRemove__REACT_HOT_LOADER__',
	    value: function __handleRemove__REACT_HOT_LOADER__(uid) {
	      this.props.actions.remove({ entity: 'services', uid: uid });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this6 = this;
	
	      var _state = this.state,
	          isOpen = _state.isOpen,
	          selectedId = _state.selectedId;
	      var _props2 = this.props,
	          isFetching = _props2.isFetching,
	          user = _props2.user;
	
	
	      return _react2.default.createElement(
	        _flexElement2.default,
	        { column: true },
	        _react2.default.createElement(
	          _flexElement2.default,
	          { justify: 'flex-end' },
	          _react2.default.createElement(_semanticUiReact.Button, {
	            compact: true,
	            primary: true,
	            icon: 'plus',
	            size: 'small',
	            content: 'Servi\xE7o',
	            onClick: this.handleCreate
	          })
	        ),
	        _react2.default.createElement(_modal2.default, { isOpen: isOpen, uid: selectedId, onClose: this.handleClose }),
	        _react2.default.createElement(_semanticUiReact.Divider, { style: { marginBottom: 0 } }),
	        isFetching && !_lodash2.default.isEmpty(user.services) && _react2.default.createElement(
	          _flexElement2.default,
	          { column: true, align: 'center', justify: 'center', style: styles.emptyContainer },
	          _react2.default.createElement(
	            _semanticUiReact.Loader,
	            { active: true },
	            _react2.default.createElement(
	              'span',
	              { style: { color: 'rgba(0,0,0, 0.45)' } },
	              'Carregando servi\xE7os...'
	            )
	          )
	        ),
	        !isFetching && _lodash2.default.isEmpty(user.services) && _react2.default.createElement(
	          _flexElement2.default,
	          { column: true, align: 'center', justify: 'center', style: styles.emptyContainer },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'wrench', style: styles.emptyIcon }),
	          _react2.default.createElement(
	            'span',
	            { style: styles.emptyText },
	            'Clique no bot\xE3o acima para adicionar um servi\xE7o.'
	          )
	        ),
	        !isFetching && !_lodash2.default.isEmpty(user.services) && _react2.default.createElement(
	          _semanticUiReact.Table,
	          { basic: 'very', style: { margin: 0 } },
	          _react2.default.createElement(
	            _semanticUiReact.Table.Body,
	            null,
	            _lodash2.default.map(user.services, function (uid) {
	              return _react2.default.createElement(_service2.default, {
	                key: uid,
	                uid: uid,
	                onEdit: _this6.handleEdit,
	                onRemove: _this6.handleRemove
	              });
	            })
	          )
	        )
	      );
	    }
	  }]);
	  return Services;
	}(_react2.default.Component);
	
	Services.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  isFetching: _react2.default.PropTypes.bool,
	  isLogged: _react2.default.PropTypes.bool,
	  hasServices: _react2.default.PropTypes.bool,
	  user: _react2.default.PropTypes.object
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    user: _selectors2.default.getUser(state),
	    isLogged: _selectors2.default.isAuthenticated(state),
	    isFetching: _selectors2.default.isFetching(state, 'services'),
	    hasServices: !_lodash2.default.isEmpty(_selectors2.default.getEntities(state, 'services'))
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Services);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(styles, 'styles', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/services.jsx');
	
	  __REACT_HOT_LOADER__.register(Services, 'Services', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/services.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/services.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/services.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/services.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/services/service.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var styles = {
	  edit: { marginRight: 10 },
	  remove: { marginTop: -1 },
	  loader: { marginLeft: 8, marginRight: 5, position: 'relative' }
	};
	
	var Service = function (_React$Component) {
	  (0, _inherits3.default)(Service, _React$Component);
	
	  function Service() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, Service);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Service.__proto__ || (0, _getPrototypeOf2.default)(Service)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      isOpen: false
	    }, _this.handleClose = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleClose__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleOpen = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleOpen__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleRemove = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleRemove__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(Service, [{
	    key: '__handleClose__REACT_HOT_LOADER__',
	    value: function __handleClose__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: false });
	    }
	  }, {
	    key: '__handleOpen__REACT_HOT_LOADER__',
	    value: function __handleOpen__REACT_HOT_LOADER__() {
	      this.setState({ isOpen: true });
	    }
	  }, {
	    key: '__handleRemove__REACT_HOT_LOADER__',
	    value: function __handleRemove__REACT_HOT_LOADER__() {
	      var _this5 = this;
	
	      this.setState({ isOpen: false }, function () {
	        _this5.props.onRemove(_this5.props.uid);
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var isOpen = this.state.isOpen;
	      var _props = this.props,
	          isRemoving = _props.isRemoving,
	          service = _props.service,
	          onEdit = _props.onEdit;
	
	      var trigger = isRemoving ? _react2.default.createElement(
	        'span',
	        { style: styles.loader },
	        _react2.default.createElement(_semanticUiReact.Loader, { active: true, size: 'mini' })
	      ) : _react2.default.createElement(_semanticUiReact.Icon, { link: true, name: 'trash outline', style: styles.remove, onClick: this.handleOpen });
	
	      return _react2.default.createElement(
	        _semanticUiReact.Table.Row,
	        null,
	        _react2.default.createElement(
	          _semanticUiReact.Table.Cell,
	          null,
	          _react2.default.createElement(
	            _semanticUiReact.Header,
	            { as: 'h4', image: true },
	            _react2.default.createElement(_semanticUiReact.Icon, { name: 'wrench' }),
	            _react2.default.createElement(
	              _semanticUiReact.Header.Content,
	              null,
	              service.name,
	              _react2.default.createElement(
	                _semanticUiReact.Header.Subheader,
	                null,
	                (service.details || '').length > 200 ? service.details.substr(0, 200) + '...' : service.details
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Table.Cell,
	          { collapsing: true },
	          _react2.default.createElement(_semanticUiReact.Icon, {
	            link: true,
	            name: 'edit',
	            style: styles.edit,
	            onClick: function onClick() {
	              return onEdit(service.uid);
	            }
	          }),
	          _react2.default.createElement(
	            _semanticUiReact.Modal,
	            {
	              size: 'small',
	              open: isOpen,
	              trigger: trigger,
	              closeOnEscape: false,
	              closeOnRootNodeClick: false
	            },
	            _react2.default.createElement(_semanticUiReact.Header, { size: 'mini', content: 'Remover Servi\xE7o' }),
	            _react2.default.createElement(
	              _semanticUiReact.Modal.Content,
	              null,
	              'Confirmar a remo\xE7\xE3o de ',
	              _react2.default.createElement(
	                'strong',
	                null,
	                service.name
	              ),
	              '?'
	            ),
	            _react2.default.createElement(
	              _semanticUiReact.Modal.Actions,
	              null,
	              _react2.default.createElement(
	                _semanticUiReact.Button,
	                { onClick: this.handleClose },
	                _react2.default.createElement(_semanticUiReact.Icon, { name: 'remove' }),
	                ' N\xE3o'
	              ),
	              _react2.default.createElement(
	                _semanticUiReact.Button,
	                { color: 'red', onClick: this.handleRemove },
	                _react2.default.createElement(_semanticUiReact.Icon, { name: 'trash outline' }),
	                ' Sim'
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	  return Service;
	}(_react2.default.Component);
	
	Service.propTypes = {
	  isRemoving: _react2.default.PropTypes.bool,
	  service: _react2.default.PropTypes.object,
	  uid: _react2.default.PropTypes.string,
	  onEdit: _react2.default.PropTypes.func,
	  onRemove: _react2.default.PropTypes.func
	};
	
	
	var mapStateToProps = function mapStateToProps(state, _ref2) {
	  var uid = _ref2.uid;
	  return {
	    service: _selectors2.default.getEntities(state, 'services', uid),
	    isRemoving: _selectors2.default.isRemoving(state, 'services', uid)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(Service);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(styles, 'styles', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/service.jsx');
	
	  __REACT_HOT_LOADER__.register(Service, 'Service', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/service.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/service.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/service.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/organization/tabs/services/modal.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(12);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _genUid = __webpack_require__("./src/helpers/gen-uid.js");
	
	var _genUid2 = _interopRequireDefault(_genUid);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var initialState = {
	  isCreatingSkill: false,
	  skills: {},
	  options: [],
	  formData: {
	    name: '',
	    details: '',
	    qtyAvailable: '',
	    skills: []
	  }
	};
	
	var ModalService = function (_React$Component) {
	  (0, _inherits3.default)(ModalService, _React$Component);
	
	  function ModalService() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, ModalService);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = ModalService.__proto__ || (0, _getPrototypeOf2.default)(ModalService)).call.apply(_ref, [this].concat(args))), _this), _this.state = initialState, _this.handleClose = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleClose__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleOpen = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleOpen__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleChange = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleChange__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _this.handleSubmit = function () {
	      var _this5;
	
	      return (_this5 = _this).__handleSubmit__REACT_HOT_LOADER__.apply(_this5, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(ModalService, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(_ref2) {
	      var skills = _ref2.skills;
	
	      if (skills !== this.props.skills) {
	        this.setState({ isCreatingSkill: false });
	      }
	    }
	  }, {
	    key: '__handleClose__REACT_HOT_LOADER__',
	    value: function __handleClose__REACT_HOT_LOADER__() {
	      this.props.onClose();
	    }
	  }, {
	    key: '__handleOpen__REACT_HOT_LOADER__',
	    value: function __handleOpen__REACT_HOT_LOADER__() {
	      var _props = this.props,
	          skills = _props.skills,
	          service = _props.service;
	
	
	      this.setState({
	        isCreatingSkill: false,
	        skills: _lodash2.default.merge({}, skills),
	        options: _lodash2.default.values(skills).map(function (_ref3) {
	          var uid = _ref3.uid,
	              name = _ref3.name;
	          return {
	            text: name,
	            value: uid
	          };
	        }),
	        formData: {
	          name: service.name || '',
	          details: service.details || '',
	          qtyAvailable: service.qtyAvailable || '',
	          skills: service.skills || []
	        }
	      });
	    }
	  }, {
	    key: '__handleChange__REACT_HOT_LOADER__',
	    value: function __handleChange__REACT_HOT_LOADER__(e) {
	      var _this6 = this;
	
	      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var _state = this.state,
	          skills = _state.skills,
	          options = _state.options;
	
	      var formData = _lodash2.default.merge({}, this.state.formData);
	      var name = data.name || e.currentTarget.name;
	      var value = data.value || e.currentTarget.value;
	
	      if (name === 'skills') {
	        (function () {
	          var newValue = {};
	          var newSkill = _lodash2.default.remove(value, function (attr) {
	            return !skills[attr];
	          })[0];
	
	          if (newSkill) {
	            (function () {
	              var uid = (0, _genUid2.default)('skills');
	
	              skills[uid] = { uid: uid, name: newSkill };
	
	              options.push({ text: newSkill, value: uid });
	
	              _this6.setState({ options: options, skills: skills }, function () {
	                _this6.props.actions.save('skills', skills[uid]);
	              });
	
	              newValue[uid] = uid;
	            })();
	          }
	
	          value.forEach(function (uid) {
	            return newValue[uid] = uid;
	          });
	
	          formData[name] = newValue;
	        })();
	      } else {
	        formData[name] = value;
	      }
	
	      this.setState({ formData: formData });
	    }
	  }, {
	    key: '__handleSubmit__REACT_HOT_LOADER__',
	    value: function __handleSubmit__REACT_HOT_LOADER__(evt) {
	      var formData = this.state.formData;
	      var _props2 = this.props,
	          actions = _props2.actions,
	          service = _props2.service;
	
	
	      evt.preventDefault();
	
	      if (this.isValid(formData)) {
	        actions.addToOrg({
	          entity: 'services',
	          data: _lodash2.default.assign({}, service, formData)
	        });
	      }
	    }
	  }, {
	    key: 'isValid',
	    value: function isValid(data) {
	      var isValid = !['name', 'qtyAvailable', 'details', 'skills'].map(function (attr) {
	        return data[attr];
	      }).some(function (val) {
	        return _lodash2.default.isEmpty(val);
	      });
	
	      if (!isValid) {
	        this.props.actions.notifyError(' necessrio preencher os campos obrigatrios');
	      }
	
	      return isValid;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props3 = this.props,
	          isOpen = _props3.isOpen,
	          isSaving = _props3.isSaving,
	          service = _props3.service;
	      var _state2 = this.state,
	          formData = _state2.formData,
	          options = _state2.options,
	          isCreatingSkill = _state2.isCreatingSkill;
	
	
	      return _react2.default.createElement(
	        _semanticUiReact.Modal,
	        {
	          open: isOpen,
	          closeOnEscape: false,
	          closeOnRootNodeClick: false,
	          onMount: this.handleOpen,
	          onClose: this.handleClose
	        },
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Header,
	          null,
	          service.uid ? 'Editar Servio' : 'Novo Servio'
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Content,
	          { as: _semanticUiReact.Form, onSubmit: this.handleSubmit },
	          _react2.default.createElement(
	            _semanticUiReact.Form.Group,
	            { widths: 'equal' },
	            _react2.default.createElement(_semanticUiReact.Form.Input, {
	              required: true,
	              name: 'name',
	              label: 'Nome',
	              placeholder: 'Nome que ser\xE1 exibido nos resultados da pesquisa',
	              disabled: isSaving,
	              value: formData.name,
	              onChange: this.handleChange
	            }),
	            _react2.default.createElement(_semanticUiReact.Form.Input, {
	              required: true,
	              name: 'qtyAvailable',
	              label: 'Vagas dispon\xEDveis',
	              placeholder: 'N\xFAmero de vagas dispon\xEDveis',
	              disabled: isSaving,
	              value: formData.qtyAvailable,
	              onChange: this.handleChange
	            })
	          ),
	          _react2.default.createElement(_semanticUiReact.Form.Select, {
	            fluid: true,
	            search: true,
	            required: true,
	            multiple: true,
	            selection: true,
	            allowAdditions: true,
	            name: 'skills',
	            label: 'Habilidades',
	            additionLabel: 'Adicionar: ',
	            placeholder: 'Digite as habilidades necess\xE1rias para este servi\xE7o',
	            noResultsMessage: 'Nenhum resultado encontrado',
	            options: options,
	            disabled: isSaving,
	            loading: isCreatingSkill,
	            value: _lodash2.default.keys(formData.skills),
	            onChange: this.handleChange
	          }),
	          _react2.default.createElement(_semanticUiReact.Form.TextArea, {
	            required: true,
	            rows: '6',
	            name: 'details',
	            label: 'Detalhes',
	            placeholder: 'Do que se trata este servi\xE7o?',
	            disabled: isSaving,
	            value: formData.details,
	            onChange: this.handleChange
	          })
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Actions,
	          { as: _flexElement2.default, justify: 'flex-end' },
	          _react2.default.createElement(_semanticUiReact.Button, {
	            content: 'Fechar',
	            disabled: isSaving,
	            onClick: this.handleClose
	          }),
	          _react2.default.createElement(_semanticUiReact.Button, {
	            primary: true,
	            icon: 'save',
	            content: 'Salvar',
	            loading: isSaving,
	            disabled: isSaving,
	            onClick: this.handleSubmit
	          })
	        )
	      );
	    }
	  }]);
	  return ModalService;
	}(_react2.default.Component);
	
	ModalService.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  service: _react2.default.PropTypes.object,
	  isOpen: _react2.default.PropTypes.bool,
	  isSaving: _react2.default.PropTypes.bool,
	  skills: _react2.default.PropTypes.object,
	  onClose: _react2.default.PropTypes.func
	};
	ModalService.defaultProps = {
	  service: {}
	};
	
	
	var mapStateToProps = function mapStateToProps(state, _ref4) {
	  var uid = _ref4.uid;
	  return {
	    user: _selectors2.default.getUser(state),
	    skills: _selectors2.default.getEntities(state, 'skills'),
	    service: _selectors2.default.getEntities(state, 'services', uid),
	    isSaving: _selectors2.default.isFetching(state, 'services') || _selectors2.default.isFetching(state, 'users')
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(ModalService);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(initialState, 'initialState', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(ModalService, 'ModalService', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/modal.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/organization/tabs/services/modal.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/volunteer/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _threeColumns = __webpack_require__("./src/views/components/three-columns.jsx");
	
	var _threeColumns2 = _interopRequireDefault(_threeColumns);
	
	var _panel = __webpack_require__("./src/views/content/feed/volunteer/panel.jsx");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	var _details = __webpack_require__("./src/views/content/feed/volunteer/details.jsx");
	
	var _details2 = _interopRequireDefault(_details);
	
	var _related = __webpack_require__("./src/views/content/feed/volunteer/related.jsx");
	
	var _related2 = _interopRequireDefault(_related);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Usuario = function Usuario(props) {
	  return _react2.default.createElement(_threeColumns2.default, {
	    panel: _react2.default.createElement(_panel2.default, props),
	    content: _react2.default.createElement(_details2.default, props),
	    related: _react2.default.createElement(_related2.default, props)
	  });
	};
	
	var _default = Usuario;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Usuario, 'Usuario', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/volunteer/panel.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var style = {
	  fontSize: '1rem',
	  marginRight: '0.8em',
	  width: '16em'
	};
	
	var Panel = function Panel(_ref) {
	  var skills = _ref.skills,
	      user = _ref.user;
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, style: style },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      _react2.default.createElement(
	        _semanticUiReact.Header,
	        { as: 'h5', style: { fontSize: '0.95em' } },
	        'MINHAS HABILIDADES'
	      ),
	      _lodash2.default.keys(user.skills, function (key) {
	        return _react2.default.createElement(
	          _semanticUiReact.Label,
	          { key: key },
	          skills[key].name
	        );
	      }),
	      _react2.default.createElement(
	        _semanticUiReact.Header,
	        { as: 'h5', style: { fontSize: '0.95em' } },
	        'PROPOSTAS DE SERVI\xC7OS'
	      ),
	      _react2.default.createElement(
	        _semanticUiReact.Header,
	        { as: 'h5', style: { fontSize: '0.95em' } },
	        'SERVI\xC7OS REALIZADOS'
	      )
	    )
	  );
	};
	
	Panel.propTypes = {
	  skills: _react2.default.PropTypes.object,
	  user: _react2.default.PropTypes.object
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    user: _selectors2.default.getUser(state),
	    skills: _selectors2.default.getEntities(state, 'skills')
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(Panel);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(style, 'style', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(Panel, 'Panel', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/panel.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/feed/volunteer/details.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _faker = __webpack_require__(67);
	
	var _faker2 = _interopRequireDefault(_faker);
	
	var _redux = __webpack_require__(12);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var srcImg = 'http://xpenology.org/wp-content/themes/qaengine/img/default-thumbnail.jpg';
	
	var style = {
	  fontSize: '1rem'
	};
	
	var Details = function Details() {
	  return _react2.default.createElement(
	    _semanticUiReact.Container,
	    { fluid: true, style: style },
	    _react2.default.createElement(
	      _semanticUiReact.Card,
	      { fluid: true },
	      _react2.default.createElement(
	        _semanticUiReact.Card.Content,
	        null,
	        _react2.default.createElement(_semanticUiReact.Image, { floated: 'left', size: 'small', src: srcImg }),
	        _react2.default.createElement(
	          _semanticUiReact.Card.Header,
	          { style: { fontSize: '1em', marginBottom: '0.3em' } },
	          'NOME DA CAMPANHA'
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Card.Meta,
	          null,
	          _faker2.default.lorem.paragraph(4)
	        )
	      )
	    ),
	    _react2.default.createElement(
	      _semanticUiReact.Card,
	      { fluid: true },
	      _react2.default.createElement(
	        _semanticUiReact.Card.Content,
	        null,
	        _react2.default.createElement(
	          _semanticUiReact.Card.Header,
	          { style: { fontSize: '1em' } },
	          'FEED DE NOT\xCDCIAS'
	        )
	      ),
	      _react2.default.createElement(
	        _semanticUiReact.Card.Content,
	        null,
	        _react2.default.createElement(
	          _semanticUiReact.Feed,
	          null,
	          _react2.default.createElement(
	            _semanticUiReact.Feed.Event,
	            null,
	            _react2.default.createElement(_semanticUiReact.Feed.Label, { image: 'http://semantic-ui.com/images/avatar/small/jenny.jpg' }),
	            _react2.default.createElement(
	              _semanticUiReact.Feed.Content,
	              null,
	              _react2.default.createElement(_semanticUiReact.Feed.Date, { content: '1 day ago' }),
	              _react2.default.createElement(
	                _semanticUiReact.Feed.Summary,
	                null,
	                'You added ',
	                _react2.default.createElement(
	                  'a',
	                  null,
	                  'Jenny Hess'
	                ),
	                ' to your ',
	                _react2.default.createElement(
	                  'a',
	                  null,
	                  'coworker'
	                ),
	                ' group.'
	              )
	            )
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Feed.Event,
	            null,
	            _react2.default.createElement(_semanticUiReact.Feed.Label, { image: 'http://semantic-ui.com/images/avatar2/small/molly.png' }),
	            _react2.default.createElement(
	              _semanticUiReact.Feed.Content,
	              null,
	              _react2.default.createElement(_semanticUiReact.Feed.Date, { content: '3 days ago' }),
	              _react2.default.createElement(
	                _semanticUiReact.Feed.Summary,
	                null,
	                'You added ',
	                _react2.default.createElement(
	                  'a',
	                  null,
	                  'Molly Malone'
	                ),
	                ' as a friend.'
	              )
	            )
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Feed.Event,
	            null,
	            _react2.default.createElement(_semanticUiReact.Feed.Label, { image: 'http://semantic-ui.com/images/avatar/small/elliot.jpg' }),
	            _react2.default.createElement(
	              _semanticUiReact.Feed.Content,
	              null,
	              _react2.default.createElement(_semanticUiReact.Feed.Date, { content: '4 days ago' }),
	              _react2.default.createElement(
	                _semanticUiReact.Feed.Summary,
	                null,
	                'You added ',
	                _react2.default.createElement(
	                  'a',
	                  null,
	                  'Elliot Baker'
	                ),
	                ' to your ',
	                _react2.default.createElement(
	                  'a',
	                  null,
	                  'musicians'
	                ),
	                ' group.'
	              )
	            )
	          )
	        )
	      )
	    )
	  );
	};
	
	var mapStateToProps = function mapStateToProps(state, _ref) {
	  var id = _ref.params.id;
	  return {
	    user: _selectors2.default.getEntities(state, 'users', id),
	    skills: _selectors2.default.getEntities(state, 'skills')
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Details);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(srcImg, 'srcImg', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/details.jsx');
	
	  __REACT_HOT_LOADER__.register(style, 'style', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/details.jsx');
	
	  __REACT_HOT_LOADER__.register(Details, 'Details', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/details.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/details.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/details.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/details.jsx');
	}();

	;

/***/ },

/***/ 67:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(2);

/***/ },

/***/ "./src/views/content/feed/volunteer/related.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Related = function Related() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, style: { marginLeft: '0.8em', width: '16em' } },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      _react2.default.createElement(
	        _semanticUiReact.Header,
	        { as: 'h5', style: { fontSize: '0.95em' } },
	        'SERVI\xC7OS DE INTERESSE'
	      )
	    )
	  );
	};
	
	Related.propTypes = {
	  skills: _react2.default.PropTypes.object,
	  user: _react2.default.PropTypes.object
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    user: _selectors2.default.getUser(state),
	    skills: _selectors2.default.getEntities(state, 'skills')
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(Related);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Related, 'Related', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/related.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/related.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/feed/volunteer/related.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/buscar/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _threeColumns = __webpack_require__("./src/views/components/three-columns.jsx");
	
	var _threeColumns2 = _interopRequireDefault(_threeColumns);
	
	var _filters = __webpack_require__("./src/views/content/buscar/filters.jsx");
	
	var _filters2 = _interopRequireDefault(_filters);
	
	var _results = __webpack_require__("./src/views/content/buscar/results.jsx");
	
	var _results2 = _interopRequireDefault(_results);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Buscar = function Buscar(props) {
	  return _react2.default.createElement(_threeColumns2.default, {
	    panel: _react2.default.createElement(_filters2.default, props),
	    content: _react2.default.createElement(_results2.default, props)
	  });
	};
	
	var _default = Buscar;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Buscar, 'Buscar', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/buscar/filters.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _classnames = __webpack_require__(65);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _latinize = __webpack_require__(51);
	
	var _latinize2 = _interopRequireDefault(_latinize);
	
	var _lodash = __webpack_require__(11);
	
	var _reactRedux = __webpack_require__(57);
	
	var _redux = __webpack_require__(12);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _constants = __webpack_require__("./src/constants.js");
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _filters = __webpack_require__("./src/views/content/buscar/filters.scss");
	
	var _filters2 = _interopRequireDefault(_filters);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Filters = function (_React$Component) {
	  (0, _inherits3.default)(Filters, _React$Component);
	
	  function Filters() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, Filters);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Filters.__proto__ || (0, _getPrototypeOf2.default)(Filters)).call.apply(_ref, [this].concat(args))), _this), _this.handleClear = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleClear__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleSearch = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleSearch__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleFilterClick = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleFilterClick__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(Filters, [{
	    key: '__handleClear__REACT_HOT_LOADER__',
	    value: function __handleClear__REACT_HOT_LOADER__() {
	      this.dropdown.setValue('');
	      this.props.actions.updateFilter({ skills: null });
	    }
	  }, {
	    key: '__handleSearch__REACT_HOT_LOADER__',
	    value: function __handleSearch__REACT_HOT_LOADER__() {
	      var skills = this.dropdown.state.value;
	
	      this.props.actions.updateFilter({ skills: skills });
	
	      this.applySearch(this.props.appliedFilter.filter);
	    }
	  }, {
	    key: '__handleFilterClick__REACT_HOT_LOADER__',
	    value: function __handleFilterClick__REACT_HOT_LOADER__(value) {
	      var transitionTo = this.context.router.transitionTo;
	      var actions = this.props.actions;
	
	      var _find = (0, _lodash.find)(_constants.Filter.OPTIONS, { value: value }),
	          text = _find.text;
	
	      var slug = (0, _latinize2.default)(text).toLowerCase();
	
	      transitionTo({
	        pathname: '/buscar',
	        query: value === 'all' ? null : { filtro: slug }
	      });
	
	      actions.updateFilter({ filter: value });
	      this.applySearch(value);
	    }
	  }, {
	    key: 'applySearch',
	    value: function applySearch(entity) {
	      this.props.actions.read({ entity: entity });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this5 = this;
	
	      var _props = this.props,
	          isFiltering = _props.isFiltering,
	          appliedFilter = _props.appliedFilter,
	          skills = _props.skills;
	
	
	      return _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, className: _filters2.default.wrapper },
	        _react2.default.createElement(
	          _semanticUiReact.Segment,
	          null,
	          _react2.default.createElement(
	            _flexElement2.default,
	            { column: true, className: _filters2.default.menu },
	            _constants.Filter.OPTIONS.map(function (option) {
	              return _react2.default.createElement(
	                _flexElement2.default,
	                {
	                  align: 'center',
	                  key: option.value,
	                  className: (0, _classnames2.default)(_filters2.default.menuItem, (0, _defineProperty3.default)({}, _filters2.default.selected, option.value === appliedFilter.filter)),
	                  onClick: function onClick() {
	                    return _this5.handleFilterClick(option.value);
	                  }
	                },
	                _react2.default.createElement(_semanticUiReact.Icon, { name: option.icon }),
	                _react2.default.createElement(
	                  'span',
	                  { style: { marginLeft: '0.5em' } },
	                  option.text
	                )
	              );
	            })
	          ),
	          _react2.default.createElement(_semanticUiReact.Divider, null),
	          _react2.default.createElement(
	            _flexElement2.default,
	            { column: true },
	            _react2.default.createElement(
	              _semanticUiReact.Header,
	              { as: 'h5' },
	              'Filtrar por:'
	            ),
	            _react2.default.createElement(
	              _semanticUiReact.Form,
	              { className: _filters2.default.searchForm, onSubmit: this.handleSearch },
	              _react2.default.createElement(_semanticUiReact.Dropdown, {
	                fluid: true,
	                search: true,
	                multiple: true,
	                selection: true,
	                disabled: isFiltering,
	                ref: function ref(el) {
	                  return _this5.dropdown = el;
	                },
	                noResultsMessage: 'Nenhum registro encontrado',
	                options: (0, _lodash.values)(skills).map(function (_ref2) {
	                  var name = _ref2.name,
	                      uid = _ref2.uid;
	                  return { text: name, value: uid };
	                }),
	                placeholder: 'Habilidades...'
	              })
	            ),
	            _react2.default.createElement(
	              _flexElement2.default,
	              { justify: 'space-between', style: { marginTop: '1em' } },
	              _react2.default.createElement(
	                _semanticUiReact.Button,
	                {
	                  primary: true,
	                  size: 'small',
	                  type: 'submit',
	                  disabled: isFiltering,
	                  onClick: this.handleSearch
	                },
	                'Buscar'
	              ),
	              _react2.default.createElement(
	                _semanticUiReact.Button,
	                { size: 'small', disabled: isFiltering, onClick: this.handleClear },
	                'Limpar'
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	  return Filters;
	}(_react2.default.Component);
	
	Filters.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  isFiltering: _react2.default.PropTypes.bool,
	  appliedFilter: _react2.default.PropTypes.object,
	  skills: _react2.default.PropTypes.object
	};
	Filters.contextTypes = {
	  router: _react2.default.PropTypes.object.isRequired
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    appliedFilter: _selectors2.default.getAppliedFilter(state),
	    isFiltering: _selectors2.default.isFiltering(state),
	    skills: _selectors2.default.getEntities(state, 'skills')
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Filters);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Filters, 'Filters', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/filters.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/filters.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/filters.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/filters.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/buscar/filters.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/filters.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/filters.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/filters.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/filters.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".filters__wrapper__ha_-DdT2XM {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em; }\n\n.filters__menu__3X6dScawmO {\n  margin: -0.5em -1em 1em; }\n\n.filters__menuItem__2UwRF8dCiA {\n  border-bottom: 1px solid transparent;\n  border-left: 5px solid transparent;\n  border-top: 1px solid transparent;\n  cursor: pointer;\n  padding: .5em .7em; }\n  .filters__menuItem__2UwRF8dCiA.filters__selected__2aAMMDJvPk {\n    background-color: #f0f0f0;\n    border-bottom-color: #ddd;\n    border-top-color: #ddd;\n    border-left-color: #2987CD; }\n  .filters__menuItem__2UwRF8dCiA:hover {\n    background-color: #f0f0f0; }\n", "", {"version":3,"sources":["/./src/views/content/buscar/src/views/content/buscar/filters.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,YAAY,EACb;;AAED;EACE,wBAAwB,EACzB;;AAED;EACE,qCAAqC;EACrC,mCAAmC;EACnC,kCAAkC;EAClC,gBAAgB;EAChB,mBAAmB,EAYpB;EAjBD;IAQI,0BAA0B;IAC1B,0BAA0B;IAC1B,uBAAuB;IACvB,2BAA2B,EAC5B;EAZH;IAeI,0BAA0B,EAC3B","file":"filters.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em;\n}\n\n.menu {\n  margin: -0.5em -1em 1em;\n}\n\n.menuItem {\n  border-bottom: 1px solid transparent;\n  border-left: 5px solid transparent;\n  border-top: 1px solid transparent;\n  cursor: pointer;\n  padding: .5em .7em;\n\n  &.selected {\n    background-color: #f0f0f0;\n    border-bottom-color: #ddd;\n    border-top-color: #ddd;\n    border-left-color: #2987CD;\n  }\n\n  &:hover {\n    background-color: #f0f0f0;\n  }\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "filters__wrapper__ha_-DdT2XM",
		"menu": "filters__menu__3X6dScawmO",
		"menuItem": "filters__menuItem__2UwRF8dCiA",
		"selected": "filters__selected__2aAMMDJvPk"
	};

/***/ },

/***/ "./src/views/content/buscar/results.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _latinize = __webpack_require__(51);
	
	var _latinize2 = _interopRequireDefault(_latinize);
	
	var _moment = __webpack_require__(7);
	
	var _moment2 = _interopRequireDefault(_moment);
	
	var _lodash = __webpack_require__(11);
	
	var _redux = __webpack_require__(12);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _constants = __webpack_require__("./src/constants.js");
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _results = __webpack_require__("./src/views/content/buscar/results.scss");
	
	var _results2 = _interopRequireDefault(_results);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Results = function (_React$Component) {
	  (0, _inherits3.default)(Results, _React$Component);
	
	  function Results() {
	    (0, _classCallCheck3.default)(this, Results);
	    return (0, _possibleConstructorReturn3.default)(this, (Results.__proto__ || (0, _getPrototypeOf2.default)(Results)).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Results, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      var actions = this.props.actions;
	
	      var filter = this.getFilter();
	
	      if (filter) {
	        actions.updateFilter({ filter: filter });
	      }
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {}
	  }, {
	    key: 'getFilter',
	    value: function getFilter() {
	      var _ref = this.props.location.query || {},
	          filtro = _ref.filtro;
	
	      if (filtro) {
	        var comparator = function comparator(option) {
	          return filtro === (0, _latinize2.default)(option.text).toLowerCase();
	        };
	
	        var _ref2 = (0, _lodash.find)(_constants.Filter.OPTIONS, comparator) || {},
	            value = _ref2.value;
	
	        return value;
	      }
	
	      return null;
	    }
	  }, {
	    key: 'navigateTo',
	    value: function navigateTo(entity, id) {
	      var transitionTo = this.context.router.transitionTo;
	
	      var _find = (0, _lodash.find)(_constants.Filter.OPTIONS, { value: entity }),
	          text = _find.text;
	
	      var slug = (0, _latinize2.default)(text).toLowerCase();
	
	      transitionTo('/' + slug + '/' + id);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var _props = this.props,
	          records = _props.records,
	          isFiltering = _props.isFiltering;
	
	
	      if (isFiltering) {
	        return _react2.default.createElement(
	          _semanticUiReact.Segment,
	          { basic: true, style: { height: '100%', width: '100%' } },
	          _react2.default.createElement(_semanticUiReact.Loader, { active: true, size: 'small' })
	        );
	      }
	
	      if (!isFiltering && (0, _lodash.isEmpty)(records)) {
	        return _react2.default.createElement(
	          _flexElement2.default,
	          { column: true, full: true, align: 'center', justify: 'center', className: _results2.default.wrapper },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'cloud', size: 'massive', style: { color: 'rgba(0,0,0, 0.1)' } }),
	          _react2.default.createElement(
	            'span',
	            { style: { color: 'rgba(0,0,0, 0.45)' } },
	            'Nenhum resultado encontrado :('
	          )
	        );
	      }
	
	      return _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, full: true, className: _results2.default.wrapper },
	        _react2.default.createElement(
	          _semanticUiReact.Card.Group,
	          { itemsPerRow: 4, className: _results2.default.cards },
	          (0, _lodash.map)(records, function (record, key) {
	            var date = (0, _moment2.default)(record.created_at);
	
	            var _find2 = (0, _lodash.find)(_constants.Filter.OPTIONS, { value: record.entity }),
	                icon = _find2.icon;
	
	            return _react2.default.createElement(
	              _semanticUiReact.Card,
	              {
	                key: key,
	                className: _results2.default.card,
	                onClick: function onClick() {
	                  return _this2.navigateTo(record.entity, record.id);
	                }
	              },
	              _react2.default.createElement(
	                _semanticUiReact.Card.Content,
	                null,
	                record.image ? _react2.default.createElement(_semanticUiReact.Image, { floated: 'left', size: 'mini', src: record.image }) : _react2.default.createElement(_semanticUiReact.Icon, { className: _results2.default.cardIcon, name: icon, color: 'black' }),
	                _react2.default.createElement(
	                  _semanticUiReact.Card.Header,
	                  null,
	                  record.title
	                ),
	                _react2.default.createElement(
	                  _semanticUiReact.Card.Meta,
	                  null,
	                  record.meta
	                ),
	                _react2.default.createElement(
	                  _semanticUiReact.Card.Description,
	                  null,
	                  record.description.length - 3 > 100 ? record.description.slice(0, 100) + '...' : record.description
	                )
	              ),
	              _react2.default.createElement(
	                _semanticUiReact.Card.Content,
	                { extra: true },
	                _react2.default.createElement(
	                  _flexElement2.default,
	                  { column: true, align: 'flex-end' },
	                  _react2.default.createElement(
	                    'span',
	                    null,
	                    date.isValid() && date.fromNow()
	                  )
	                )
	              )
	            );
	          })
	        )
	      );
	    }
	  }]);
	  return Results;
	}(_react2.default.Component);
	
	Results.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  isFiltering: _react2.default.PropTypes.bool,
	
	  location: _react2.default.PropTypes.object,
	  records: _react2.default.PropTypes.array
	};
	Results.contextTypes = {
	  router: _react2.default.PropTypes.object.isRequired
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    isLogged: _selectors2.default.isAuthenticated(state),
	    isFiltering: _selectors2.default.isFiltering(state),
	    appliedFilter: _selectors2.default.getAppliedFilter(state),
	    records: _selectors2.default.getSearchResults(state)
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Results);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Results, 'Results', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/results.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/results.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/results.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/buscar/results.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/buscar/results.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/results.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/results.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/results.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/buscar/results.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".results__wrapper__2d0lG8noCt {\n  font-size: 1rem; }\n\n.results__sorting__1o9FoAkp_r {\n  padding: .5em .5em 1.5em; }\n  .results__sorting__1o9FoAkp_r a.results__selected__1ZoN-8AnAQ {\n    font-weight: bold;\n    text-decoration: underline; }\n  .results__sorting__1o9FoAkp_r strong {\n    margin-right: .5em; }\n  .results__sorting__1o9FoAkp_r span {\n    margin: 0 .5em; }\n\n.results__cards__DVKGeb4-8s {\n  margin-left: -0.3em !important;\n  margin-right: -0.5em !important; }\n\n.results__card__3ArhkmpO4m {\n  cursor: pointer; }\n  .results__card__3ArhkmpO4m:hover {\n    box-shadow: 0 0 0 1px #D4D4D5, 0 2px 4px 0 rgba(34, 36, 38, 0.12), 0 2px 10px 0 rgba(34, 36, 38, 0.15) !important; }\n\n.results__cardIcon__1aDKwe3Ll3 {\n  float: left !important;\n  height: auto !important;\n  width: 35px !important;\n  font-size: 2em !important;\n  margin-bottom: 10px !important;\n  margin-right: 10px !important;\n  margin-top: 5px !important; }\n", "", {"version":3,"sources":["/./src/views/content/buscar/src/views/content/buscar/results.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB,EACjB;;AAED;EACE,yBAAyB,EAc1B;EAfD;IAII,kBAAkB;IAClB,2BAA2B,EAC5B;EANH;IASI,mBAAmB,EACpB;EAVH;IAaI,eAAe,EAChB;;AAGH;EACE,+BAA+B;EAC/B,gCAAgC,EACjC;;AAED;EACE,gBAAgB,EAQjB;EATD;IAII,kHAG4C,EAC7C;;AAGH;EACE,uBAAuB;EACvB,wBAAwB;EACxB,uBAAuB;EACvB,0BAA0B;EAC1B,+BAA+B;EAC/B,8BAA8B;EAC9B,2BAA2B,EAC5B","file":"results.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n}\n\n.sorting {\n  padding: .5em .5em 1.5em;\n\n  a.selected {\n    font-weight: bold;\n    text-decoration: underline;\n  }\n\n  strong {\n    margin-right: .5em;\n  }\n\n  span {\n    margin: 0 .5em;\n  }\n}\n\n.cards {\n  margin-left: -0.3em !important;\n  margin-right: -0.5em !important;\n}\n\n.card {\n  cursor: pointer;\n\n  &:hover {\n    box-shadow:\n      0 0 0 1px #D4D4D5,\n      0 2px 4px 0 rgba(34,36,38,.12),\n      0 2px 10px 0 rgba(34,36,38,.15) !important;\n  }\n}\n\n.cardIcon {\n  float: left !important;\n  height: auto !important;\n  width: 35px !important;\n  font-size: 2em !important;\n  margin-bottom: 10px !important;\n  margin-right: 10px !important;\n  margin-top: 5px !important;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "results__wrapper__2d0lG8noCt",
		"sorting": "results__sorting__1o9FoAkp_r",
		"selected": "results__selected__1ZoN-8AnAQ",
		"cards": "results__cards__DVKGeb4-8s",
		"card": "results__card__3ArhkmpO4m",
		"cardIcon": "results__cardIcon__1aDKwe3Ll3"
	};

/***/ },

/***/ "./src/views/content/campanha/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _threeColumns = __webpack_require__("./src/views/components/three-columns.jsx");
	
	var _threeColumns2 = _interopRequireDefault(_threeColumns);
	
	var _panel = __webpack_require__("./src/views/content/campanha/panel.jsx");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	var _details = __webpack_require__("./src/views/content/campanha/details.jsx");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Campanha = function Campanha(props) {
	  return _react2.default.createElement(_threeColumns2.default, {
	    panel: _react2.default.createElement(_panel2.default, props),
	    content: _react2.default.createElement(_details2.default, props)
	  });
	};
	
	var _default = Campanha;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Campanha, 'Campanha', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/campanha/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/campanha/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/campanha/panel.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _panel = __webpack_require__("./src/views/content/campanha/panel.scss");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Panel = function Panel() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, className: _panel2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      'Campanha'
	    )
	  );
	};
	
	var _default = Panel;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Panel, 'Panel', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/campanha/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/campanha/panel.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/campanha/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/panel.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/panel.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/panel.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".panel__wrapper__1kh_1kRRlF {\n  font-size: 1rem;\n  margin-right: 0.8em;\n  width: 15em; }\n", "", {"version":3,"sources":["/./src/views/content/campanha/src/views/content/campanha/panel.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,oBAAoB;EACpB,YAAY,EACb","file":"panel.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n  margin-right: 0.8em;\n  width: 15em;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "panel__wrapper__1kh_1kRRlF"
	};

/***/ },

/***/ "./src/views/content/campanha/details.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _faker = __webpack_require__(67);
	
	var _faker2 = _interopRequireDefault(_faker);
	
	var _times = __webpack_require__(68);
	
	var _times2 = _interopRequireDefault(_times);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _details = __webpack_require__("./src/views/content/campanha/details.scss");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Details = function Details() {
	  return _react2.default.createElement(
	    _semanticUiReact.Segment,
	    { className: _details2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Container,
	      { fluid: true },
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, style: { marginBottom: 30 } },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'clipboard' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'SERVI\xC7O'
	          )
	        ),
	        _react2.default.createElement(
	          'p',
	          null,
	          _faker2.default.lorem.sentence(20)
	        )
	      ),
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, style: { marginBottom: 30 } },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'lightbulb' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'HABILIDADES REQUERIDAS'
	          )
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Label.Group,
	          null,
	          _react2.default.createElement(
	            _semanticUiReact.Label,
	            null,
	            'Encanador'
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Label,
	            null,
	            'Eletricista'
	          )
	        )
	      ),
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'clipboard' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'DESCRI\xC7\xC3O'
	          )
	        ),
	        (0, _times2.default)(3).map(function (idx) {
	          return _react2.default.createElement(
	            'p',
	            { key: idx },
	            _faker2.default.lorem.paragraph(6)
	          );
	        })
	      )
	    )
	  );
	};
	
	var _default = Details;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Details, 'Details', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/campanha/details.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/campanha/details.jsx');
	}();

	;

/***/ },

/***/ 68:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1890);

/***/ },

/***/ "./src/views/content/campanha/details.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/details.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/details.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/details.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/campanha/details.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".details__wrapper__Pj9bK3uKvK {\n  font-size: 1rem; }\n", "", {"version":3,"sources":["/./src/views/content/campanha/src/views/content/campanha/details.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB,EACjB","file":"details.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "details__wrapper__Pj9bK3uKvK"
	};

/***/ },

/***/ "./src/views/content/organizacao/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _threeColumns = __webpack_require__("./src/views/components/three-columns.jsx");
	
	var _threeColumns2 = _interopRequireDefault(_threeColumns);
	
	var _panel = __webpack_require__("./src/views/content/organizacao/panel.jsx");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	var _details = __webpack_require__("./src/views/content/organizacao/details.jsx");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Organizacao = function Organizacao(props) {
	  return _react2.default.createElement(_threeColumns2.default, {
	    panel: _react2.default.createElement(_panel2.default, props),
	    content: _react2.default.createElement(_details2.default, props)
	  });
	};
	
	var _default = Organizacao;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Organizacao, 'Organizacao', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/organizacao/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/organizacao/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/organizacao/panel.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _panel = __webpack_require__("./src/views/content/organizacao/panel.scss");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Panel = function Panel() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, className: _panel2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      'Organizacao'
	    )
	  );
	};
	
	var _default = Panel;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Panel, 'Panel', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/organizacao/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/organizacao/panel.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/organizacao/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/panel.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/panel.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/panel.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".panel__wrapper__2tfiz0jVlS {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em; }\n", "", {"version":3,"sources":["/./src/views/content/organizacao/src/views/content/organizacao/panel.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,YAAY,EACb","file":"panel.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "panel__wrapper__2tfiz0jVlS"
	};

/***/ },

/***/ "./src/views/content/organizacao/details.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _faker = __webpack_require__(67);
	
	var _faker2 = _interopRequireDefault(_faker);
	
	var _times = __webpack_require__(68);
	
	var _times2 = _interopRequireDefault(_times);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _details = __webpack_require__("./src/views/content/organizacao/details.scss");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Details = function Details() {
	  return _react2.default.createElement(
	    _semanticUiReact.Segment,
	    { className: _details2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Container,
	      { fluid: true },
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, style: { marginBottom: 30 } },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'clipboard' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'SERVI\xC7O'
	          )
	        ),
	        _react2.default.createElement(
	          'p',
	          null,
	          _faker2.default.lorem.sentence(20)
	        )
	      ),
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, style: { marginBottom: 30 } },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'lightbulb' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'HABILIDADES REQUERIDAS'
	          )
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Label.Group,
	          null,
	          _react2.default.createElement(
	            _semanticUiReact.Label,
	            null,
	            'Encanador'
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Label,
	            null,
	            'Eletricista'
	          )
	        )
	      ),
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'clipboard' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'DESCRI\xC7\xC3O'
	          )
	        ),
	        (0, _times2.default)(3).map(function (idx) {
	          return _react2.default.createElement(
	            'p',
	            { key: idx },
	            _faker2.default.lorem.paragraph(6)
	          );
	        })
	      )
	    )
	  );
	};
	
	var _default = Details;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Details, 'Details', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/organizacao/details.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/organizacao/details.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/organizacao/details.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/details.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/details.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/details.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/organizacao/details.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".details__wrapper__1SL5uvq3wG {\n  font-size: 1rem; }\n", "", {"version":3,"sources":["/./src/views/content/organizacao/src/views/content/organizacao/details.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB,EACjB","file":"details.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "details__wrapper__1SL5uvq3wG"
	};

/***/ },

/***/ "./src/views/content/servico/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _threeColumns = __webpack_require__("./src/views/components/three-columns.jsx");
	
	var _threeColumns2 = _interopRequireDefault(_threeColumns);
	
	var _panel = __webpack_require__("./src/views/content/servico/panel.jsx");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	var _details = __webpack_require__("./src/views/content/servico/details.jsx");
	
	var _details2 = _interopRequireDefault(_details);
	
	var _related = __webpack_require__("./src/views/content/servico/related.jsx");
	
	var _related2 = _interopRequireDefault(_related);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Servico = function Servico(props) {
	  return _react2.default.createElement(_threeColumns2.default, {
	    panel: _react2.default.createElement(_panel2.default, props),
	    content: _react2.default.createElement(_details2.default, props),
	    related: _react2.default.createElement(_related2.default, props)
	  });
	};
	
	var _default = Servico;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Servico, 'Servico', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/servico/panel.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _panel = __webpack_require__("./src/views/content/servico/panel.scss");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Panel = function Panel() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, className: _panel2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      'Servico'
	    )
	  );
	};
	
	var _default = Panel;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Panel, 'Panel', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/panel.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/servico/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/panel.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/panel.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/panel.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".panel__wrapper__1Vf43xDGO2 {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em; }\n", "", {"version":3,"sources":["/./src/views/content/servico/src/views/content/servico/panel.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,YAAY,EACb","file":"panel.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "panel__wrapper__1Vf43xDGO2"
	};

/***/ },

/***/ "./src/views/content/servico/details.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _faker = __webpack_require__(67);
	
	var _faker2 = _interopRequireDefault(_faker);
	
	var _times = __webpack_require__(68);
	
	var _times2 = _interopRequireDefault(_times);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _details = __webpack_require__("./src/views/content/servico/details.scss");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Details = function Details() {
	  return _react2.default.createElement(
	    _semanticUiReact.Segment,
	    { className: _details2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Container,
	      { fluid: true },
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, style: { marginBottom: 30 } },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'clipboard' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'SERVI\xC7O'
	          )
	        ),
	        _react2.default.createElement(
	          'p',
	          null,
	          _faker2.default.lorem.sentence(20)
	        )
	      ),
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, style: { marginBottom: 30 } },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'lightbulb' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'HABILIDADES REQUERIDAS'
	          )
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Label.Group,
	          null,
	          _react2.default.createElement(
	            _semanticUiReact.Label,
	            null,
	            'Encanador'
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Label,
	            null,
	            'Eletricista'
	          )
	        )
	      ),
	      _react2.default.createElement(
	        _flexElement2.default,
	        { column: true },
	        _react2.default.createElement(
	          _semanticUiReact.Header,
	          { as: 'h5' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'clipboard' }),
	          _react2.default.createElement(
	            _semanticUiReact.Header.Content,
	            null,
	            'DESCRI\xC7\xC3O'
	          )
	        ),
	        (0, _times2.default)(3).map(function (idx) {
	          return _react2.default.createElement(
	            'p',
	            { key: idx },
	            _faker2.default.lorem.paragraph(6)
	          );
	        })
	      )
	    )
	  );
	};
	
	var _default = Details;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Details, 'Details', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/details.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/details.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/servico/details.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/details.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/details.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/details.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/details.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".details__wrapper__3nv26yCiLL {\n  font-size: 1rem; }\n", "", {"version":3,"sources":["/./src/views/content/servico/src/views/content/servico/details.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB,EACjB","file":"details.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "details__wrapper__3nv26yCiLL"
	};

/***/ },

/***/ "./src/views/content/servico/related.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _related = __webpack_require__("./src/views/content/servico/related.scss");
	
	var _related2 = _interopRequireDefault(_related);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Related = function Related() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, className: _related2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      'Pellentesque habitant morbi tristique senectus.'
	    ),
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      'Pellentesque habitant morbi tristique senectus.'
	    )
	  );
	};
	
	var _default = Related;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Related, 'Related', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/related.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/servico/related.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/servico/related.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/related.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/related.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/related.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/servico/related.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".related__wrapper__24ZbXKELIF {\n  font-size: 1rem;\n  margin-left: .8em;\n  width: 18em; }\n", "", {"version":3,"sources":["/./src/views/content/servico/src/views/content/servico/related.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,YAAY,EACb","file":"related.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n  margin-left: .8em;\n  width: 18em;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "related__wrapper__24ZbXKELIF"
	};

/***/ },

/***/ "./src/views/content/usuario/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _threeColumns = __webpack_require__("./src/views/components/three-columns.jsx");
	
	var _threeColumns2 = _interopRequireDefault(_threeColumns);
	
	var _panel = __webpack_require__("./src/views/content/usuario/panel.jsx");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	var _details = __webpack_require__("./src/views/content/usuario/details.jsx");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Usuario = function Usuario(props) {
	  return _react2.default.createElement(_threeColumns2.default, {
	    panel: _react2.default.createElement(_panel2.default, props),
	    content: _react2.default.createElement(_details2.default, props)
	  });
	};
	
	var _default = Usuario;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Usuario, 'Usuario', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/index.js');
	}();

	;

/***/ },

/***/ "./src/views/content/usuario/panel.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _panel = __webpack_require__("./src/views/content/usuario/panel.scss");
	
	var _panel2 = _interopRequireDefault(_panel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Panel = function Panel() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { column: true, className: _panel2.default.wrapper },
	    _react2.default.createElement(
	      _semanticUiReact.Segment,
	      null,
	      'Usuario'
	    )
	  );
	};
	
	var _default = Panel;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Panel, 'Panel', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/panel.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/panel.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/usuario/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/panel.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/panel.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/panel.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/panel.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".panel__wrapper__E6444UuFG3 {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em; }\n", "", {"version":3,"sources":["/./src/views/content/usuario/src/views/content/usuario/panel.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,mBAAmB;EACnB,YAAY,EACb","file":"panel.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n  margin-right: .8em;\n  width: 15em;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "panel__wrapper__E6444UuFG3"
	};

/***/ },

/***/ "./src/views/content/usuario/details.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _lodash = __webpack_require__(11);
	
	var _redux = __webpack_require__(12);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _details = __webpack_require__("./src/views/content/usuario/details.scss");
	
	var _details2 = _interopRequireDefault(_details);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Details = function (_React$Component) {
	  (0, _inherits3.default)(Details, _React$Component);
	
	  function Details() {
	    (0, _classCallCheck3.default)(this, Details);
	    return (0, _possibleConstructorReturn3.default)(this, (Details.__proto__ || (0, _getPrototypeOf2.default)(Details)).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(Details, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      if (this.props.isLogged) {
	        this.props.actions.read({ entity: 'users' });
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          user = _props.user,
	          skills = _props.skills;
	
	
	      return _react2.default.createElement(
	        _semanticUiReact.Segment,
	        { className: _details2.default.wrapper },
	        _react2.default.createElement(
	          _semanticUiReact.Container,
	          { fluid: true },
	          _react2.default.createElement(
	            _flexElement2.default,
	            { column: true, style: { marginBottom: 30 } },
	            _react2.default.createElement(
	              _semanticUiReact.Header,
	              { as: 'h5' },
	              _react2.default.createElement(_semanticUiReact.Icon, { name: 'clipboard' }),
	              _react2.default.createElement(
	                _semanticUiReact.Header.Content,
	                null,
	                'SOBRE MIM'
	              )
	            ),
	            _react2.default.createElement(
	              'p',
	              null,
	              user.description
	            )
	          ),
	          _react2.default.createElement(
	            _flexElement2.default,
	            { column: true, style: { marginBottom: 30 } },
	            _react2.default.createElement(
	              _semanticUiReact.Header,
	              { as: 'h5' },
	              _react2.default.createElement(_semanticUiReact.Icon, { name: 'lightbulb' }),
	              _react2.default.createElement(
	                _semanticUiReact.Header.Content,
	                null,
	                'HABILIDADES'
	              )
	            ),
	            _react2.default.createElement(
	              _semanticUiReact.Label.Group,
	              null,
	              (0, _lodash.values)(user.skills).map(function (skillID) {
	                return _react2.default.createElement(
	                  _semanticUiReact.Label,
	                  { key: skillID },
	                  skills[skillID].name
	                );
	              })
	            )
	          )
	        )
	      );
	    }
	  }]);
	  return Details;
	}(_react2.default.Component);
	
	Details.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  isLogged: _react2.default.PropTypes.bool,
	  user: _react2.default.PropTypes.object,
	  skills: _react2.default.PropTypes.object
	};
	
	
	var mapStateToProps = function mapStateToProps(state, _ref) {
	  var id = _ref.params.id;
	  return {
	    isLogged: _selectors2.default.isAuthenticated(state),
	    user: _selectors2.default.getEntities(state, 'users', id),
	    skills: _selectors2.default.getEntities(state, 'skills')
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Details);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Details, 'Details', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/details.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/details.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/details.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/content/usuario/details.jsx');
	}();

	;

/***/ },

/***/ "./src/views/content/usuario/details.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/details.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/details.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/details.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/content/usuario/details.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".details__wrapper__y-ZrJIHt4e {\n  font-size: 1rem; }\n", "", {"version":3,"sources":["/./src/views/content/usuario/src/views/content/usuario/details.scss"],"names":[],"mappings":"AAAA;EACE,gBAAgB,EACjB","file":"details.scss","sourcesContent":[".wrapper {\n  font-size: 1rem;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "details__wrapper__y-ZrJIHt4e"
	};

/***/ },

/***/ "./src/views/containers/login.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__("./node_modules/babel-runtime/helpers/defineProperty.js");
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(12);
	
	var _reactRedux = __webpack_require__(57);
	
	var _reactRouter = __webpack_require__(58);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Login = function (_React$Component) {
	  (0, _inherits3.default)(Login, _React$Component);
	
	  function Login() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, Login);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = Login.__proto__ || (0, _getPrototypeOf2.default)(Login)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      type: 'volunteer'
	    }, _this.handleChange = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleChange__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleLogin = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleLogin__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _this.handleRegister = function () {
	      var _this4;
	
	      return (_this4 = _this).__handleRegister__REACT_HOT_LOADER__.apply(_this4, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(Login, [{
	    key: '__handleChange__REACT_HOT_LOADER__',
	    value: function __handleChange__REACT_HOT_LOADER__(evt, _ref2) {
	      var name = _ref2.name,
	          value = _ref2.value;
	
	      this.setState((0, _defineProperty3.default)({}, name, value));
	    }
	  }, {
	    key: '__handleLogin__REACT_HOT_LOADER__',
	    value: function __handleLogin__REACT_HOT_LOADER__(evt, _ref3) {
	      var email = _ref3.email,
	          password = _ref3.password;
	
	      evt.preventDefault();
	
	      var type = this.state.type;
	      var _props = this.props,
	          actions = _props.actions,
	          isLogging = _props.isLogging,
	          isRegistering = _props.isRegistering;
	
	
	      if (isLogging || isRegistering) {
	        return;
	      }
	
	      if (email && password) {
	        actions.login({ email: email, password: password, type: type });
	      } else {
	        actions.notifyError('Por favor, preencha todos os campos.');
	      }
	    }
	  }, {
	    key: '__handleRegister__REACT_HOT_LOADER__',
	    value: function __handleRegister__REACT_HOT_LOADER__(evt) {
	      evt.preventDefault();
	
	      var type = this.state.type;
	      var _props2 = this.props,
	          actions = _props2.actions,
	          isLogging = _props2.isLogging,
	          isRegistering = _props2.isRegistering;
	
	
	      if (isRegistering || isLogging) {
	        return;
	      }
	
	      var email = this.el.querySelector('[name="email"]').value;
	      var password = this.el.querySelector('[name="password"]').value;
	
	      if (email && password) {
	        actions.register({ email: email, password: password, type: type });
	      } else {
	        actions.notifyError('Por favor, preencha todos os campos.');
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this5 = this;
	
	      var type = this.state.type;
	      var _props3 = this.props,
	          isLogged = _props3.isLogged,
	          isLogging = _props3.isLogging,
	          isRegistering = _props3.isRegistering,
	          location = _props3.location;
	
	      var _ref4 = location.state || {},
	          _ref4$redirect = _ref4.redirect,
	          redirect = _ref4$redirect === undefined ? { pathname: '/' } : _ref4$redirect;
	
	      if (isLogged) {
	        return _react2.default.createElement(_reactRouter.Redirect, { to: redirect });
	      }
	
	      return _react2.default.createElement(
	        _flexElement2.default,
	        { column: true, full: true, align: 'center', justify: 'center', innerRef: function innerRef(el) {
	            return _this5.el = el;
	          } },
	        _react2.default.createElement(
	          _flexElement2.default,
	          { column: true, align: 'center' },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: 'travel', color: 'blue', style: { fontSize: '6em' } }),
	          _react2.default.createElement(
	            'span',
	            { style: { color: 'rgba(0,0,0,0.5)', fontSize: '1.3em' } },
	            'Ag\xEAncia Amiga'
	          )
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Segment,
	          { column: true, align: 'center', as: _flexElement2.default, style: { marginTop: 30, width: 300 } },
	          _react2.default.createElement(
	            _semanticUiReact.Form,
	            { style: { marginBottom: '1em', width: '100%' }, onSubmit: this.handleLogin },
	            _react2.default.createElement(
	              _semanticUiReact.Form.Field,
	              null,
	              _react2.default.createElement(
	                'label',
	                { htmlFor: true },
	                'Login'
	              )
	            ),
	            _react2.default.createElement(_semanticUiReact.Form.Input, {
	              type: 'text',
	              name: 'email',
	              disabled: isLogging || isRegistering,
	              placeholder: 'Email'
	            }),
	            _react2.default.createElement(_semanticUiReact.Form.Input, {
	              type: 'password',
	              name: 'password',
	              placeholder: 'Senha',
	              disabled: isLogging || isRegistering
	            }),
	            _react2.default.createElement(
	              _semanticUiReact.Button,
	              {
	                primary: true,
	                fluid: true,
	                size: 'large',
	                type: 'submit',
	                style: { margin: 0 },
	                loading: isLogging,
	                disabled: isLogging || isRegistering
	              },
	              _react2.default.createElement(
	                _flexElement2.default,
	                { align: 'center', justify: 'space-between' },
	                _react2.default.createElement(
	                  'span',
	                  null,
	                  isLogging ? 'Autenticando...' : 'Entrar'
	                ),
	                _react2.default.createElement(_semanticUiReact.Icon, { name: 'sign in' })
	              )
	            )
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Divider,
	            { horizontal: true, style: { width: '100%' } },
	            'ou'
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Form,
	            { style: { marginTop: '1em', width: '100%' } },
	            _react2.default.createElement(
	              _semanticUiReact.Form.Field,
	              null,
	              _react2.default.createElement(
	                'label',
	                { htmlFor: true },
	                'Cadastre-se como:'
	              )
	            ),
	            _react2.default.createElement(
	              _semanticUiReact.Form.Group,
	              { widths: 'equal' },
	              _react2.default.createElement(_semanticUiReact.Form.Checkbox, {
	                radio: true,
	                name: 'type',
	                label: 'Volunt\xE1rio',
	                value: 'volunteer',
	                checked: type === 'volunteer',
	                disabled: isLogging || isRegistering,
	                onChange: this.handleChange
	              }),
	              _react2.default.createElement(_semanticUiReact.Form.Checkbox, {
	                radio: true,
	                name: 'type',
	                label: 'Organiza\xE7\xE3o',
	                value: 'organization',
	                checked: type === 'organization',
	                disabled: isLogging || isRegistering,
	                onChange: this.handleChange
	              })
	            )
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Button,
	            {
	              fluid: true,
	              size: 'large',
	              style: { margin: 0, marginTop: 10 },
	              loading: isRegistering,
	              disabled: isLogging || isRegistering,
	              onClick: this.handleRegister
	            },
	            _react2.default.createElement(
	              _flexElement2.default,
	              { align: 'center', justify: 'space-between' },
	              _react2.default.createElement(
	                'span',
	                null,
	                isRegistering ? 'Registrando...' : 'Registrar'
	              ),
	              _react2.default.createElement(_semanticUiReact.Icon, { name: 'signup', style: { margin: 0 } })
	            )
	          )
	        )
	      );
	    }
	  }]);
	  return Login;
	}(_react2.default.Component);
	
	Login.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  isLogged: _react2.default.PropTypes.bool,
	  isLogging: _react2.default.PropTypes.bool,
	  isRegistering: _react2.default.PropTypes.bool,
	  location: _react2.default.PropTypes.object
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    isLogged: _selectors2.default.isAuthenticated(state),
	    isLogging: _selectors2.default.isAuthenticating(state),
	    isRegistering: _selectors2.default.isRegistering(state)
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Login);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Login, 'Login', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/login.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/login.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/login.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/login.jsx');
	}();

	;

/***/ },

/***/ "./src/views/containers/notification.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactNotificationSystem = __webpack_require__(69);
	
	var _reactNotificationSystem2 = _interopRequireDefault(_reactNotificationSystem);
	
	var _reactRedux = __webpack_require__(57);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NotificationContainer = function (_React$PureComponent) {
	  (0, _inherits3.default)(NotificationContainer, _React$PureComponent);
	
	  function NotificationContainer() {
	    (0, _classCallCheck3.default)(this, NotificationContainer);
	    return (0, _possibleConstructorReturn3.default)(this, (NotificationContainer.__proto__ || (0, _getPrototypeOf2.default)(NotificationContainer)).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(NotificationContainer, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(_ref) {
	      var notification = _ref.notification;
	
	      if (notification.level) {
	        this.el.addNotification(notification);
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(_reactNotificationSystem2.default, { ref: function ref(el) {
	          return _this2.el = el;
	        } });
	    }
	  }]);
	  return NotificationContainer;
	}(_react2.default.PureComponent);
	
	NotificationContainer.propTypes = {
	  notification: _react2.default.PropTypes.object
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    notification: _selectors2.default.getNotification(state)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps)(NotificationContainer);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(NotificationContainer, 'NotificationContainer', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/notification.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/notification.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/notification.jsx');
	}();

	;

/***/ },

/***/ 69:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1331);

/***/ },

/***/ "./src/views/containers/topbar/index.js":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(58);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _search = __webpack_require__("./src/views/containers/topbar/search.jsx");
	
	var _search2 = _interopRequireDefault(_search);
	
	var _user = __webpack_require__("./src/views/containers/topbar/user.jsx");
	
	var _user2 = _interopRequireDefault(_user);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var styles = {
	  topBar: {
	    backgroundColor: '#2987CD',
	    color: 'white',
	    fontSize: '1rem',
	    padding: '0.4em 0.4em 0.5em 1em',
	    width: '100%'
	  },
	  logo: {
	    fontSize: '1.3em',
	    marginRight: '0.5em',
	    marginTop: '0.1em'
	  }
	};
	
	var TopBar = function TopBar() {
	  return _react2.default.createElement(
	    _flexElement2.default,
	    { style: styles.topBar },
	    _react2.default.createElement(
	      _flexElement2.default,
	      { column: true, align: 'center', style: { fontSize: '1.2em' } },
	      _react2.default.createElement(_semanticUiReact.Icon, { name: 'travel', style: styles.logo }),
	      _react2.default.createElement(
	        _reactRouter.Link,
	        { to: '/', style: { color: 'white' } },
	        'Ag\xEAncia Amiga'
	      )
	    ),
	    _react2.default.createElement(
	      _flexElement2.default,
	      { full: true, column: true, align: 'center' },
	      _react2.default.createElement(_search2.default, null)
	    ),
	    _react2.default.createElement(
	      _flexElement2.default,
	      { column: true, align: 'center' },
	      _react2.default.createElement(_user2.default, null)
	    )
	  );
	};
	
	var _default = TopBar;
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(styles, 'styles', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/index.js');
	
	  __REACT_HOT_LOADER__.register(TopBar, 'TopBar', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/index.js');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/index.js');
	}();

	;

/***/ },

/***/ "./src/views/containers/topbar/search.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _latinize = __webpack_require__(51);
	
	var _latinize2 = _interopRequireDefault(_latinize);
	
	var _lodash = __webpack_require__(11);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _constants = __webpack_require__("./src/constants.js");
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _search = __webpack_require__("./src/views/containers/topbar/search.scss");
	
	var _search2 = _interopRequireDefault(_search);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TopBarSearch = function (_React$Component) {
	  (0, _inherits3.default)(TopBarSearch, _React$Component);
	
	  function TopBarSearch() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, TopBarSearch);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = TopBarSearch.__proto__ || (0, _getPrototypeOf2.default)(TopBarSearch)).call.apply(_ref, [this].concat(args))), _this), _this.handleFilterClick = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleFilterClick__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleSearch = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleSearch__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(TopBarSearch, [{
	    key: '__handleFilterClick__REACT_HOT_LOADER__',
	    value: function __handleFilterClick__REACT_HOT_LOADER__(evt, _ref2) {
	      var value = _ref2.value;
	
	      evt.preventDefault();
	
	      this.props.onUpdateFilter({ filter: value });
	    }
	  }, {
	    key: '__handleSearch__REACT_HOT_LOADER__',
	    value: function __handleSearch__REACT_HOT_LOADER__(evt, _ref3) {
	      var query = _ref3.query;
	      var _props = this.props,
	          entity = _props.entity,
	          onFilter = _props.onFilter;
	
	      var _find = (0, _lodash.find)(_constants.Filter.OPTIONS, { value: entity }),
	          text = _find.text;
	
	      var slug = (0, _latinize2.default)(text).toLowerCase();
	
	      evt.preventDefault();
	
	      onFilter({ query: query });
	
	      this.context.router.transitionTo({
	        pathname: '/buscar',
	        query: { filtro: slug }
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this4 = this;
	
	      var _props2 = this.props,
	          entity = _props2.entity,
	          query = _props2.query,
	          isFiltering = _props2.isFiltering;
	
	      var selected = (0, _lodash.find)(_constants.Filter.OPTIONS, { value: entity });
	
	      return _react2.default.createElement(
	        _semanticUiReact.Form,
	        { className: _search2.default.searchForm, onSubmit: this.handleSearch },
	        _react2.default.createElement(
	          _semanticUiReact.Input,
	          { action: true, focus: false, className: _search2.default.searchInput },
	          _react2.default.createElement(_semanticUiReact.Icon, { name: selected.icon }),
	          _react2.default.createElement('input', { name: 'query', defaultValue: query, placeholder: 'Buscar ' + selected.text }),
	          _react2.default.createElement(
	            _semanticUiReact.Dropdown,
	            { pointing: 'top left', icon: 'sliders', className: _search2.default.filters },
	            _react2.default.createElement(
	              _semanticUiReact.Dropdown.Menu,
	              null,
	              _constants.Filter.OPTIONS.map(function (option) {
	                return _react2.default.createElement(_semanticUiReact.Dropdown.Item, {
	                  key: option.value,
	                  selected: entity === option.value,
	                  icon: option.icon,
	                  value: option.value,
	                  text: option.text,
	                  onClick: _this4.handleFilterClick
	                });
	              })
	            )
	          ),
	          _react2.default.createElement(
	            _semanticUiReact.Button,
	            { type: 'submit', className: _search2.default.filterButton, disabled: isFiltering },
	            'Buscar'
	          )
	        )
	      );
	    }
	  }]);
	  return TopBarSearch;
	}(_react2.default.Component);
	
	TopBarSearch.propTypes = {
	  entity: _react2.default.PropTypes.string,
	  isFiltering: _react2.default.PropTypes.bool,
	  query: _react2.default.PropTypes.string,
	  onFilter: _react2.default.PropTypes.func,
	  onUpdateFilter: _react2.default.PropTypes.func
	};
	TopBarSearch.contextTypes = {
	  router: _react2.default.PropTypes.object.isRequired
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    isFiltering: _selectors2.default.isFiltering(state),
	    entity: _selectors2.default.getEntityFilter(state),
	    query: _selectors2.default.getQueryFilter(state)
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    onFilter: function onFilter() {
	      return dispatch(actionCreators.filter());
	    },
	    onUpdateFilter: function onUpdateFilter(updates) {
	      return dispatch(actionCreators.updateFilter(updates));
	    }
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(TopBarSearch);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(TopBarSearch, 'TopBarSearch', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/search.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/search.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/search.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/search.jsx');
	}();

	;

/***/ },

/***/ "./src/views/containers/topbar/search.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/topbar/search.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/topbar/search.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/topbar/search.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ "./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/topbar/search.scss":
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")();
	// imports
	
	
	// module
	exports.push([module.id, ".search__searchForm__JpHByftYa3 {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  font-size: 1rem;\n  margin: 0 .5em; }\n\n.search__searchInput__1vgOId3m8T {\n  -webkit-box-align: stretch;\n      -ms-flex-align: stretch;\n          align-items: stretch;\n  color: rgba(0, 0, 0, 0.3);\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  margin: auto;\n  z-index: 1; }\n  .search__searchInput__1vgOId3m8T > i {\n    color: rgba(0, 0, 0, 0.4);\n    font-size: 0.9em;\n    margin: auto -2em auto auto;\n    z-index: 1; }\n  .search__searchInput__1vgOId3m8T > input {\n    border: none !important;\n    background: white !important;\n    padding-left: 2.4em !important;\n    width: 20em !important; }\n\n.search__filters__3Y5dXHizBH {\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  background-color: white;\n  padding: .5em .8em;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex; }\n  .search__filters__3Y5dXHizBH > i {\n    margin: 0 !important; }\n\n.search__filterButton__1RZ58KRFhW {\n  background-color: #1d6092 !important;\n  color: white !important; }\n", "", {"version":3,"sources":["/./src/views/containers/topbar/src/views/containers/topbar/search.scss"],"names":[],"mappings":"AAAA;EACE,qBAAc;EAAd,qBAAc;EAAd,cAAc;EACd,oBAAQ;MAAR,YAAQ;UAAR,QAAQ;EACR,gBAAgB;EAChB,eAAe,EAChB;;AAED;EACE,2BAAqB;MAArB,wBAAqB;UAArB,qBAAqB;EACrB,0BAAW;EACX,qBAAc;EAAd,qBAAc;EAAd,cAAc;EACd,aAAa;EACb,WAAW,EAeZ;EApBD;IAQI,0BAAW;IACX,iBAAiB;IACjB,4BAA4B;IAC5B,WAAW,EACZ;EAZH;IAeI,wBAAwB;IACxB,6BAA6B;IAC7B,+BAA+B;IAC/B,uBAAuB,EACxB;;AAGH;EACE,0BAAoB;MAApB,uBAAoB;UAApB,oBAAoB;EACpB,wBAAwB;EACxB,mBAAmB;EACnB,qBAAc;EAAd,qBAAc;EAAd,cAAc,EAKf;EATD;IAOI,qBAAqB,EACtB;;AAGH;EACE,qCAAiD;EACjD,wBAAwB,EACzB","file":"search.scss","sourcesContent":[".searchForm {\n  display: flex;\n  flex: 1;\n  font-size: 1rem;\n  margin: 0 .5em;\n}\n\n.searchInput {\n  align-items: stretch;\n  color: rgba(0,0,0,0.3);\n  display: flex;\n  margin: auto;\n  z-index: 1;\n\n  & > i {\n    color: rgba(0,0,0, 0.4);\n    font-size: 0.9em;\n    margin: auto -2em auto auto;\n    z-index: 1;\n  }\n\n  & > input {\n    border: none !important;\n    background: white !important;\n    padding-left: 2.4em !important;\n    width: 20em !important;\n  }\n}\n\n.filters {\n  align-items: center;\n  background-color: white;\n  padding: .5em .8em;\n  display: flex;\n\n  & > i {\n    margin: 0 !important;\n  }\n}\n\n.filterButton {\n  background-color: darken(#2987CD, 14%) !important;\n  color: white !important;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"searchForm": "search__searchForm__JpHByftYa3",
		"searchInput": "search__searchInput__1vgOId3m8T",
		"filters": "search__filters__3Y5dXHizBH",
		"filterButton": "search__filterButton__1RZ58KRFhW"
	};

/***/ },

/***/ "./src/views/containers/topbar/user.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _lodash = __webpack_require__(11);
	
	var _redux = __webpack_require__(12);
	
	var _reactRedux = __webpack_require__(57);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	var _user = __webpack_require__("./src/views/containers/topbar/user.png");
	
	var _user2 = _interopRequireDefault(_user);
	
	var _settings = __webpack_require__("./src/views/containers/topbar/settings.jsx");
	
	var _settings2 = _interopRequireDefault(_settings);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TopBarUser = function (_React$Component) {
	  (0, _inherits3.default)(TopBarUser, _React$Component);
	
	  function TopBarUser() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, TopBarUser);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = TopBarUser.__proto__ || (0, _getPrototypeOf2.default)(TopBarUser)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	      isModalVisible: false
	    }, _this.handleSettingsToggle = function () {
	      var _this2;
	
	      return (_this2 = _this).__handleSettingsToggle__REACT_HOT_LOADER__.apply(_this2, arguments);
	    }, _this.handleLogout = function () {
	      var _this3;
	
	      return (_this3 = _this).__handleLogout__REACT_HOT_LOADER__.apply(_this3, arguments);
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(TopBarUser, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.validateUserFields(this.props);
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(props) {
	      this.validateUserFields(props);
	    }
	  }, {
	    key: '__handleSettingsToggle__REACT_HOT_LOADER__',
	    value: function __handleSettingsToggle__REACT_HOT_LOADER__() {
	      this.setState({ isModalVisible: !this.state.isModalVisible });
	    }
	  }, {
	    key: '__handleLogout__REACT_HOT_LOADER__',
	    value: function __handleLogout__REACT_HOT_LOADER__(evt) {
	      evt.preventDefault();
	
	      this.props.actions.logout();
	    }
	  }, {
	    key: 'validateUserFields',
	    value: function validateUserFields(props) {
	      var _this4 = this;
	
	      this.requiredFields = props.user.type === 'volunteer' ? ['name', 'state', 'city', 'skills'] : ['name', 'state', 'city'];
	
	      setTimeout(function () {
	        _this4.setState({
	          isModalVisible: _this4.requiredFields.map(function (attr) {
	            return props.user[attr];
	          }).some(function (val) {
	            return (0, _lodash.isEmpty)(val);
	          })
	        });
	      }, 1);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var settingsProps = {
	        user: this.props.user,
	        requiredFields: this.requiredFields,
	        isOpen: this.state.isModalVisible,
	        onClose: this.handleSettingsToggle
	      };
	
	      var trigger = _react2.default.createElement(
	        _flexElement2.default,
	        { align: 'center', justify: 'center' },
	        _react2.default.createElement(_semanticUiReact.Image, { avatar: true, src: _user2.default }),
	        _react2.default.createElement(_semanticUiReact.Icon, { name: 'caret down', style: { marginLeft: '0.3em' } })
	      );
	
	      return _react2.default.createElement(
	        _flexElement2.default,
	        { align: 'center', justify: 'flex-end', style: { marginLeft: 'auto' } },
	        _react2.default.createElement(
	          _semanticUiReact.Dropdown,
	          { icon: null, trigger: trigger, pointing: 'top right' },
	          _react2.default.createElement(
	            _semanticUiReact.Dropdown.Menu,
	            null,
	            _react2.default.createElement(_semanticUiReact.Dropdown.Item, { text: 'Configura\xE7\xF5es', icon: 'settings', onClick: this.handleSettingsToggle }),
	            _react2.default.createElement(_semanticUiReact.Dropdown.Item, { text: 'Sair', icon: 'sign out', onClick: this.handleLogout })
	          )
	        ),
	        _react2.default.createElement(_settings2.default, settingsProps)
	      );
	    }
	  }]);
	  return TopBarUser;
	}(_react2.default.Component);
	
	TopBarUser.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  user: _react2.default.PropTypes.object
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    user: _selectors2.default.getUser(state)
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(TopBarUser);
	
	exports.default = _default;
	;
	
	var _temp2 = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(TopBarUser, 'TopBarUser', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/user.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/user.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/user.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/user.jsx');
	}();

	;

/***/ },

/***/ "./src/views/containers/topbar/user.png":
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "user.png";

/***/ },

/***/ "./src/views/containers/topbar/settings.jsx":
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(59);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(60);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(61);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(62);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(63);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _lodash = __webpack_require__(11);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(57);
	
	var _redux = __webpack_require__(12);
	
	var _semanticUiReact = __webpack_require__(64);
	
	var _genUid = __webpack_require__("./src/helpers/gen-uid.js");
	
	var _genUid2 = _interopRequireDefault(_genUid);
	
	var _actions = __webpack_require__("./src/store/actions.js");
	
	var actionCreators = _interopRequireWildcard(_actions);
	
	var _selectors = __webpack_require__("./src/store/selectors/index.js");
	
	var _selectors2 = _interopRequireDefault(_selectors);
	
	var _flexElement = __webpack_require__("./src/views/components/flex-element/index.js");
	
	var _flexElement2 = _interopRequireDefault(_flexElement);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Settings = function (_React$PureComponent) {
	  (0, _inherits3.default)(Settings, _React$PureComponent);
	
	  function Settings(props) {
	    (0, _classCallCheck3.default)(this, Settings);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (Settings.__proto__ || (0, _getPrototypeOf2.default)(Settings)).call(this, props));
	
	    _this.handleChange = function () {
	      return _this.__handleChange__REACT_HOT_LOADER__.apply(_this, arguments);
	    };
	
	    _this.handleClose = function () {
	      return _this.__handleClose__REACT_HOT_LOADER__.apply(_this, arguments);
	    };
	
	    _this.handleSubmit = function () {
	      return _this.__handleSubmit__REACT_HOT_LOADER__.apply(_this, arguments);
	    };
	
	    _this.state = _this.initialState;
	    return _this;
	  }
	
	  (0, _createClass3.default)(Settings, [{
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(nextProps) {
	      if (nextProps.skills !== this.state.skills) {
	        this.setState({
	          isCreatingSkill: false,
	          skills: _lodash2.default.merge({}, nextProps.skills)
	        });
	      }
	    }
	  }, {
	    key: '__handleChange__REACT_HOT_LOADER__',
	    value: function __handleChange__REACT_HOT_LOADER__(e, _ref) {
	      var _this2 = this;
	
	      var name = _ref.name,
	          value = _ref.value;
	      var skills = this.state.skills;
	
	      var formData = _lodash2.default.merge({}, this.state.formData);
	
	      if (name === 'skills') {
	        (function () {
	          var newValue = {};
	          var newSkill = _lodash2.default.remove(value, function (attr) {
	            return !skills[attr];
	          })[0];
	
	          if (newSkill) {
	            (function () {
	              var uid = (0, _genUid2.default)('skills');
	
	              skills[uid] = { uid: uid, name: newSkill };
	
	              _this2.setState({ skills: skills }, function () {
	                _this2.props.actions.save('skills', skills[uid]);
	              });
	
	              newValue[uid] = uid;
	            })();
	          }
	
	          value.forEach(function (uid) {
	            return newValue[uid] = uid;
	          });
	          value = newValue;
	        })();
	      }
	
	      formData[name] = value;
	
	      this.setState({ formData: formData });
	    }
	  }, {
	    key: '__handleClose__REACT_HOT_LOADER__',
	    value: function __handleClose__REACT_HOT_LOADER__() {
	      var _props = this.props,
	          user = _props.user,
	          onClose = _props.onClose;
	
	
	      if (this.isValid(user)) {
	        this.setState(this.initialState, onClose);
	      }
	    }
	  }, {
	    key: '__handleSubmit__REACT_HOT_LOADER__',
	    value: function __handleSubmit__REACT_HOT_LOADER__(evt) {
	      var formData = this.state.formData;
	      var _props2 = this.props,
	          actions = _props2.actions,
	          user = _props2.user;
	
	
	      evt.preventDefault();
	
	      if (this.isValid(formData)) {
	        actions.updateProfile(_lodash2.default.merge({}, user, formData));
	      }
	    }
	  }, {
	    key: 'isValid',
	    value: function isValid(data) {
	      var isValid = !this.props.requiredFields.map(function (attr) {
	        return data[attr];
	      }).some(function (val) {
	        return _lodash2.default.isEmpty(val);
	      });
	
	      if (!isValid) {
	        this.props.actions.notifyError(data.uid ? ' necessrio completar os seus dados antes de continuar' : ' necessrio preencher os campos obrigatrios');
	      }
	
	      if (data.password && data.password !== data.password2) {
	        this.props.actions.notifyError('As senhas no conferem.');
	      }
	
	      return isValid;
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this3 = this;
	
	      var _props3 = this.props,
	          isOpen = _props3.isOpen,
	          isUpdating = _props3.isUpdating,
	          user = _props3.user;
	      var _state = this.state,
	          formData = _state.formData,
	          skills = _state.skills,
	          isCreatingSkill = _state.isCreatingSkill;
	
	      var options = _lodash2.default.values(skills).map(function (_ref2) {
	        var uid = _ref2.uid,
	            name = _ref2.name;
	        return { text: name, value: uid };
	      });
	
	      return _react2.default.createElement(
	        _semanticUiReact.Modal,
	        { open: isOpen, closeOnRootNodeClick: false, onClose: this.handleClose },
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Header,
	          null,
	          'Configura\xE7\xF5es'
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Content,
	          {
	            as: _semanticUiReact.Form,
	            ref: function ref(el) {
	              return _this3.form = el;
	            },
	            onSubmit: this.handleSubmit
	          },
	          _react2.default.createElement(_semanticUiReact.Form.Input, {
	            required: true,
	            name: 'name',
	            label: 'Nome Completo',
	            placeholder: 'Ex.: Jos\xE9 C\xEDcero',
	            disabled: isUpdating,
	            value: formData.name,
	            onChange: this.handleChange
	          }),
	          user.type === 'volunteer' && _react2.default.createElement(_semanticUiReact.Form.Select, {
	            fluid: true,
	            search: true,
	            required: true,
	            multiple: true,
	            selection: true,
	            allowAdditions: true,
	            name: 'skills',
	            label: 'Habilidades',
	            placeholder: 'Digite suas habilidades',
	            noResultsMessage: 'Nenhum resultado encontrado',
	            disabled: isUpdating,
	            loading: isCreatingSkill,
	            value: _lodash2.default.keys(formData.skills),
	            options: options,
	            onChange: this.handleChange
	          }),
	          _react2.default.createElement(
	            _semanticUiReact.Form.Group,
	            { widths: 'equal' },
	            _react2.default.createElement(_semanticUiReact.Form.Input, {
	              required: true,
	              name: 'state',
	              label: 'Estado',
	              placeholder: 'Ex.: Alagoas',
	              disabled: isUpdating,
	              value: formData.state,
	              onChange: this.handleChange
	            }),
	            _react2.default.createElement(_semanticUiReact.Form.Input, {
	              required: true,
	              name: 'city',
	              label: 'Cidade',
	              placeholder: 'Ex.: Macei\xF3',
	              disabled: isUpdating,
	              value: formData.city,
	              onChange: this.handleChange
	            })
	          )
	        ),
	        _react2.default.createElement(
	          _semanticUiReact.Modal.Actions,
	          { as: _flexElement2.default, justify: 'flex-end' },
	          _react2.default.createElement(_semanticUiReact.Button, {
	            content: 'Fechar',
	            disabled: isUpdating,
	            onClick: this.handleClose
	          }),
	          _react2.default.createElement(_semanticUiReact.Button, {
	            primary: true,
	            content: 'Salvar',
	            icon: 'save',
	            loading: isUpdating,
	            disabled: isUpdating,
	            onClick: this.handleSubmit
	          })
	        )
	      );
	    }
	  }, {
	    key: 'initialState',
	    get: function get() {
	      var _props4 = this.props,
	          skills = _props4.skills,
	          user = _props4.user;
	
	
	      return {
	        isCreatingSkill: false,
	        skills: _lodash2.default.merge({}, skills),
	        formData: {
	          name: user.name || '',
	          state: user.state || '',
	          city: user.city || '',
	          skills: user.skills || []
	        }
	      };
	    }
	  }]);
	  return Settings;
	}(_react2.default.PureComponent);
	
	Settings.propTypes = {
	  actions: _react2.default.PropTypes.object,
	  isOpen: _react2.default.PropTypes.bool,
	  isUpdating: _react2.default.PropTypes.bool,
	  requiredFields: _react2.default.PropTypes.array,
	  skills: _react2.default.PropTypes.object,
	  user: _react2.default.PropTypes.object,
	  onClose: _react2.default.PropTypes.func
	};
	
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    isUpdating: _selectors2.default.isUpdatingProfile(state),
	    skills: _selectors2.default.getEntities(state, 'skills')
	  };
	};
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(actionCreators, dispatch)
	  };
	};
	
	var _default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Settings);
	
	exports.default = _default;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(Settings, 'Settings', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/settings.jsx');
	
	  __REACT_HOT_LOADER__.register(mapStateToProps, 'mapStateToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/settings.jsx');
	
	  __REACT_HOT_LOADER__.register(mapDispatchToProps, 'mapDispatchToProps', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/settings.jsx');
	
	  __REACT_HOT_LOADER__.register(_default, 'default', 'D:/repo.git/djalmajr/agencia-amiga/src/views/containers/topbar/settings.jsx');
	}();

	;

/***/ },

/***/ "./src/views/containers/main.scss":
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/main.scss");
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__("./node_modules/style-loader/addStyles.js")(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/main.scss", function() {
				var newContent = __webpack_require__("./node_modules/css-loader/index.js?sourceMap&modules&localIdentName=[name]__[local]__[hash:base64:10]!./node_modules/postcss-loader/index.js!./node_modules/sass-loader/index.js?sourceMap!./src/views/containers/main.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },

/***/ 27:
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(2))(1652);

/***/ }

/******/ })
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA5MjliZmU4YmIzZTYyYzJkOTYyNCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGFpbmVycy9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1ob3QtbG9hZGVyL2xpYi9wYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvbGliL3BhdGNoLmRldi5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9leHRlcm5hbCBcIl9fX0FHRU5DSUFfQU1JR0FfX19cIiIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXByb3h5L21vZHVsZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1wcm94eS9tb2R1bGVzL3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcHJveHkvbW9kdWxlcy9jcmVhdGVDbGFzc1Byb3h5LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1wcm94eS9tb2R1bGVzL2NyZWF0ZVByb3RvdHlwZVByb3h5LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Fzc2lnbi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9kaWZmZXJlbmNlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL34vcmVhY3QtcHJveHkvbW9kdWxlcy9iaW5kQXV0b0JpbmRNZXRob2RzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcHJveHkvbW9kdWxlcy9kZWxldGVVbmtub3duQXV0b0JpbmRNZXRob2RzLmpzIiwid2VicGFjazovLy8uL34vZ2xvYmFsL3dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/NTlkNCIsIndlYnBhY2s6Ly8vLi9+L3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91cmwvfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5c3RyaW5nL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvZW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQtbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2Jyb3dzZXItY3J5cHRvLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvdXJsLmpzIiwid2VicGFjazovLy8uL34vdXJsLXBhcnNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3VybC1wYXJzZS9sb2xjYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWJ1Zy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9+L21zL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2V2ZW50L2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9ldmVudHRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9icm93c2VyL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9hamF4LWJhc2VkLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9zZW5kZXItcmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2J1ZmZlcmVkLXNlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9saWIvcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9yZWNlaXZlci94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvYWJzdHJhY3QteGhyLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL3hkci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9ldmVudHNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9yZWNlaXZlci9ldmVudHNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9icm93c2VyL2V2ZW50c291cmNlLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9pZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9qc29uMy9saWIvanNvbjMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2lmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL29iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9odG1sZmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9yZWNlaXZlci9odG1sZmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC94aHItcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC94ZHItcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL2pzb25wLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci9qc29ucC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9zaGltcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2V2ZW50L2V2ZW50LmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvbG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9jbG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2V2ZW50L3RyYW5zLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9pbmZvLXJlY2VpdmVyLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvY2tqcy1jbGllbnQvbGliL2luZm8taWZyYW1lLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1pZnJhbWUtcmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9pbmZvLWFqYXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2xpYi9pZnJhbWUtYm9vdHN0cmFwLmpzIiwid2VicGFjazovLy8uL34vc29ja2pzLWNsaWVudC9saWIvZmFjYWRlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90L29ubHktZGV2LXNlcnZlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2ctYXBwbHktcmVzdWx0LmpzIiwid2VicGFjazovLy8uL3NyYy9vdmVycmlkZXMuc2Nzcz9iZGNlIiwid2VicGFjazovLy8uL3NyYy9vdmVycmlkZXMuc2NzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtaG90LWxvYWRlci9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9jb25maWd1cmUtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVkdXgvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVkdXgtYXN5bmMtaW5pdGlhbC1zdGF0ZS9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC1zYWdhL2xpYi9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlZHV4LWltbXV0YWJsZS1zdGF0ZS1pbnZhcmlhbnQvZGlzdC9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9yZWR1Y2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9yZWR1Y2Vycy9hdXRoLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC1hY3Rpb25zL2xpYi9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3N0b3JlL2FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy91dWlkL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL2hlbHBlcnMvY3JlYXRlLWFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9yZWR1Y2Vycy9lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9yZWR1Y2Vycy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvcmVkdWNlcnMvZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3N0b3JlL3JlZHVjZXJzL3Byb2ZpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2FnYXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy92ZXJ0eCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2FnYXMvYXV0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4LXNhZ2EvZWZmZWN0cy5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlZHV4LXNhZ2EvbGliL2VmZmVjdHMuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvYXBpcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWhvdC1sb2FkZXIvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9maXJlYmFzZS9maXJlYmFzZS1icm93c2VyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL2hlbHBlcnMvZ2VuLXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9zYWdhcy9lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9zZWxlY3RvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9zZWxlY3RvcnMvYXV0aC5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3Jlc2VsZWN0L2xpYi9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9oZWxwZXJzL2NyZWF0ZS1nZXQtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9zZWxlY3RvcnMvZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2VsZWN0b3JzL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9zZWxlY3RvcnMvZmlsdGVyLmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvbGF0aW5pemUvbGF0aW5pemUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2FnYXMvcHJvZmlsZS5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9jYWNoZS1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2xvY2FsZm9yYWdlL2Rpc3QvbG9jYWxmb3JhZ2UuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvZGV2dG9vbHMuanN4Iiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVkdXgtZGV2dG9vbHMvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVkdXgtZGV2dG9vbHMtbG9nLW1vbml0b3IvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVkdXgtZGV2dG9vbHMtZG9jay1tb25pdG9yL2xpYi9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9hcHBsaWNhdGlvbi5qc3giLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGFpbmVycy9tYWluLmpzeCIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvc2VtYW50aWMtdWktcmVhY3QvZGlzdC9jb21tb25qcy9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9oZWxwZXJzL3JlcXVpcmUtYXV0aC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudC9mbGV4LWVsZW1lbnQuanN4Iiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9oZWxwZXJzL2NuYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQvZmxleC1lbGVtZW50LnNjc3M/MTdiNyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQvZmxleC1lbGVtZW50LnNjc3MiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29tcG9uZW50cy9kZWZhdWx0LXByb3BzLmpzeCIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXByb3AtdHlwZXMvbGliL2VsZW1lbnRUeXBlLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbXBvbmVudHMvdGhyZWUtY29sdW1ucy5qc3giLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL29yZ2FuaXphdGlvbi9wYW5lbC5qc3giLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL29yZ2FuaXphdGlvbi9kZXRhaWxzLmpzeCIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL3RhYnMvdGltZWxpbmUuanN4Iiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9jYW1wYWlnbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL29yZ2FuaXphdGlvbi90YWJzL2NhbXBhaWducy9jYW1wYWlnbnMuanN4Iiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9jYW1wYWlnbnMvY2FtcGFpZ24uanN4Iiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9jYW1wYWlnbnMvbW9kYWwuanN4Iiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9zZXJ2aWNlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL3RhYnMvc2VydmljZXMvc2VydmljZXMuanN4Iiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9zZXJ2aWNlcy9zZXJ2aWNlLmpzeCIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL3RhYnMvc2VydmljZXMvbW9kYWwuanN4Iiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC92b2x1bnRlZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL3ZvbHVudGVlci9wYW5lbC5qc3giLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL3ZvbHVudGVlci9kZXRhaWxzLmpzeCIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2Zha2VyL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC92b2x1bnRlZXIvcmVsYXRlZC5qc3giLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9idXNjYXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9idXNjYXIvZmlsdGVycy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL2ZpbHRlcnMuc2Nzcz8wZWJiIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L2J1c2Nhci9maWx0ZXJzLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9idXNjYXIvcmVzdWx0cy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL3Jlc3VsdHMuc2Nzcz84MmQ1Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L2J1c2Nhci9yZXN1bHRzLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9jYW1wYW5oYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL3BhbmVsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGVudC9jYW1wYW5oYS9wYW5lbC5zY3NzPzQwYTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvcGFuZWwuc2NzcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL2RldGFpbHMuanN4Iiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RpbWVzLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL2RldGFpbHMuc2Nzcz85MzY2Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL2RldGFpbHMuc2NzcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL2luZGV4LmpzIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vcGFuZWwuanN4Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL3BhbmVsLnNjc3M/MWFiNyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGVudC9vcmdhbml6YWNhby9wYW5lbC5zY3NzIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vZGV0YWlscy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vZGV0YWlscy5zY3NzPzk5MGQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vZGV0YWlscy5zY3NzIiwid2VicGFjazovLy8uL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vcGFuZWwuanN4Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vcGFuZWwuc2Nzcz8yMDA1Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vcGFuZWwuc2NzcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vZGV0YWlscy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9kZXRhaWxzLnNjc3M/ZjVjOCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL2RldGFpbHMuc2NzcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vcmVsYXRlZC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9yZWxhdGVkLnNjc3M/MDJkMyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3JlbGF0ZWQuc2NzcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L3VzdWFyaW8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL3BhbmVsLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL3BhbmVsLnNjc3M/NGFmZSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL3BhbmVsLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL2RldGFpbHMuanN4Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250ZW50L3VzdWFyaW8vZGV0YWlscy5zY3NzP2JlZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2NvbnRlbnQvdXN1YXJpby9kZXRhaWxzLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGFpbmVycy9sb2dpbi5qc3giLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGFpbmVycy9ub3RpZmljYXRpb24uanN4Iiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3Qtbm90aWZpY2F0aW9uLXN5c3RlbS9kaXN0L05vdGlmaWNhdGlvblN5c3RlbS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fXyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9zZWFyY2guanN4Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9zZWFyY2guc2Nzcz9lOGMwIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9zZWFyY2guc2NzcyIsIndlYnBhY2s6Ly8vLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci91c2VyLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvY29udGFpbmVycy90b3BiYXIvdXNlci5wbmciLCJ3ZWJwYWNrOi8vLy4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGFpbmVycy90b3BiYXIvc2V0dGluZ3MuanN4Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9jb250YWluZXJzL21haW4uc2Nzcz9hNmU0Iiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX18iXSwibmFtZXMiOlsibG9jYWxlIiwicm9vdEVsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic3RvcmUiLCJyZW5kZXIiLCJtb2R1bGUiLCJob3QiLCJhY2NlcHQiLCJOZXh0QXBwIiwicmVxdWlyZSIsImRlZmF1bHQiLCJERVYiLCJjb25maWd1cmVTdG9yZSIsInNhZ2FNaWRkbGV3YXJlIiwibWlkZGxld2FyZXMiLCJEZXZUb29scyIsImNvbXBvc2VFbmhhbmNlcnMiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJjb25jYXQiLCJpbnN0cnVtZW50IiwicnVuU2FnYSIsInJ1biIsIm5leHRSZWR1Y2VyIiwicmVwbGFjZVJlZHVjZXIiLCJzdWJzY3JpYmUiLCJnZXRTdGF0ZSIsImF1dGhEYXRhIiwiYXV0aCIsImVudGl0aWVzIiwiZmlsdGVyIiwiZ2xvYmFsIiwicHJvZmlsZSIsImFzeW5jU3RhdGUiLCJhY3Rpb25zIiwiaXNBdXRoZW50aWNhdGluZyIsImxvZ2luIiwiYXV0aG9yaXplIiwiaXNSZWdpc3RlcmluZyIsInJlZ2lzdGVyIiwidW5hdXRob3JpemUiLCJzdGF0ZSIsImVycm9yIiwicGF5bG9hZCIsImhhbmRsZU5vdGlmeSIsIm1lc3NhZ2UiLCJ1aWQiLCJsb2dvdXQiLCJub3RpZnkiLCJub3RpZnlFcnJvciIsIm5vdGlmeUluZm8iLCJub3RpZnlXYXJuaW5nIiwidXBkYXRlRmlsdGVyIiwidXBkYXRlUHJvZmlsZSIsInVwZGF0ZVRhYkZlZWQiLCJhZGRUb09yZyIsInJlYWQiLCJyZW1vdmUiLCJyZW1vdmVDYWNoZSIsInNhdmUiLCJyZWYiLCJkYXRhIiwidXBkYXRlQ2FjaGUiLCJjcmVhdGVBY3Rpb24iLCJuYW1lIiwiYXJncyIsImJ5SWQiLCJuZXdTdGF0ZSIsIm1lcmdlIiwiZW50aXR5IiwiZXJyIiwiZm9yRWFjaCIsInJlc3BvbnNlIiwidmFsIiwia2V5IiwiaXNGZXRjaGluZyIsImFzc2lnbiIsImlzUmVtb3ZpbmciLCJjcmVhdGVGaWx0ZXJSZWR1Y2VyIiwiZGVmYXVsdFZhbHVlIiwidmFsdWUiLCJxdWVyeSIsInNraWxscyIsImlzRmlsdGVyaW5nIiwic2VhcmNoRG9uZSIsIm5vdGlmaWNhdGlvbiIsImFjdGlvbiIsInBvc2l0aW9uIiwibGV2ZWwiLCJpc1VwZGF0aW5nUHJvZmlsZSIsImN1cnJlbnRUYWJGZWVkIiwiYXV0aFNhZ2EiLCJlbnRpdHlTYWdhIiwicHJvZmlsZVNhZ2EiLCJ0b1N0cmluZyIsInVwZGF0ZSIsImFwaSIsImVtYWlsIiwicGFzc3dvcmQiLCJ0b0pTT04iLCJjb25zb2xlIiwibG9nIiwiRXJyb3IiLCJ0eXBlIiwidXNlciIsIkpTT04iLCJwYXJzZSIsIm9uY2UiLCJkYXRhYmFzZSIsInNldCIsImNyZWF0ZWRBdCIsIlNlcnZlclZhbHVlIiwiVElNRVNUQU1QIiwidXBkYXRlZEF0IiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJyZXMiLCJjYXRjaCIsImN1cnJlbnRVc2VyIiwidXBkYXRlUGFzc3dvcmQiLCJzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCIsInNpZ25PdXQiLCJjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQiLCJpbml0aWFsaXplQXBwIiwiYXBpS2V5IiwiYXV0aERvbWFpbiIsImRhdGFiYXNlVVJMIiwic3RvcmFnZUJ1Y2tldCIsIm1lc3NhZ2luZ1NlbmRlcklkIiwiZmIiLCJDYWNoZSIsIktFWSIsIkZpbHRlciIsIk9QVElPTlMiLCJ0ZXh0IiwiaWNvbiIsImNoaWxkIiwicHVzaCIsImF0dHJzIiwidXNlcnMiLCJzbmFwc2hvdCIsImkiLCJhdHRyIiwiaGFzQ2hpbGQiLCJzbmFwIiwiaWQiLCJjb2RlIiwiZ2V0VXNlciIsImdldERhdGEiLCJnZXRBdXRoIiwiZm5HZXRVc2VyIiwiaXNBdXRoZW50aWNhdGVkIiwiaXNFbXB0eSIsInJlZHVjZXJOYW1lIiwiZ2V0RW50aXRpZXMiLCJnZXRFbnRpdHkiLCJnZXRFbnRpdGllc0J5SWRzIiwiY3VycnkiLCJpZHMiLCJyZWR1Y2UiLCJpc0xvYWRpbmdTdGF0ZSIsImxvYWRpbmciLCJnZXRDdXJyZW50VGFiRmVlZCIsImdldE5vdGlmaWNhdGlvbiIsIl9nZXREYXRhIiwiZm9ybWF0IiwidGl0bGUiLCJtZXRhIiwiaW1hZ2UiLCJkZXNjcmlwdGlvbiIsInJlc3VtZSIsImNyZWF0ZWRfYXQiLCJnZXRRdWVyeUZpbHRlciIsImdldEVudGl0eUZpbHRlciIsImdldFNraWxsc0ZpbHRlciIsImdldFJlc3VsdHMiLCJlbnRpdHlOYW1lcyIsImZuR2V0RW50aXRpZXMiLCJyZXN1bHRzIiwiaXRlbSIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJzZWFyY2giLCJsZW5ndGgiLCJpbnRlcnNlY3Rpb24iLCJ2YWx1ZXMiLCJ1c2VyRGF0YSIsImRpc3BsYXlOYW1lIiwibG9hZFN0YXRlIiwiZ2V0SXRlbSIsImN1cnJlbnRTdGF0ZSIsInNhdmVTdGF0ZSIsInNldEl0ZW0iLCJzaG93RGV2VG9vbHMiLCJwb3B1cCIsIm9wZW4iLCJsb2NhdGlvbiIsInJlbG9hZCIsInNldFRpbWVvdXQiLCJ3cml0ZSIsImdldEVsZW1lbnRCeUlkIiwiQXBwbGljYXRpb24iLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJvYmplY3QiLCJhY3Rpb25DcmVhdG9ycyIsIk1haW4iLCJoYXNTa2lsbHMiLCJpc0xvZ2dlZCIsInByb3BzIiwid3JhcHBlciIsImNvbG9yIiwiY29udGVudCIsIlB1cmVDb21wb25lbnQiLCJib29sIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwiZGlzcGF0Y2giLCJyZXF1aXJlQXV0aCIsIkNvbXBvc2VkQ29tcG9uZW50IiwiQXV0aCIsImlzQXV0aG9yaXplZCIsIm90aGVyUHJvcHMiLCJwYXRobmFtZSIsInJlZGlyZWN0IiwiRmxleEVsZW1lbnQiLCJjbGFzc2VzIiwiZmxleCIsImNvbHVtbiIsImRpc2FibGVkIiwiZnVsbCIsInJvdyIsImFsaWduIiwianVzdGlmeSIsImNsYXNzTmFtZSIsImNoaWxkcmVuIiwiY29tcG9uZW50IiwiaW5uZXJSZWYiLCJzdHlsZSIsIm9uQ2xpY2siLCJnZXRDbGFzc05hbWUiLCJjcmVhdGVFbGVtZW50Iiwib25lT2YiLCJmdW5jIiwiZGVmYXVsdFByb3BzIiwic3R5bGVzIiwicmVzdWx0IiwiYXJnIiwic3BsaXQiLCJjbmFtZSIsImpvaW4iLCJEZWZhdWx0UHJvcHMiLCJub2RlIiwic3RyaW5nIiwiRmVlZCIsIlVzdWFyaW8iLCJUaHJlZUNvbHVtbnMiLCJwYW5lbCIsInJlbGF0ZWQiLCJmb250U2l6ZSIsIm1hcmdpblJpZ2h0Iiwid2lkdGgiLCJQYW5lbCIsInZpZXdzIiwidGltZWxpbmUiLCJjYW1wYWlnbnMiLCJzZXJ2aWNlcyIsIkRldGFpbHMiLCJhY3RpdmUiLCJvblRhYkNsaWNrIiwiQ29tcG9uZW50IiwibWFwIiwiZXZ0IiwiZW1wdHlDb250YWluZXIiLCJoZWlnaHQiLCJlbXB0eUNvbnRlbnQiLCJtYXhXaWR0aCIsImVtcHR5SWNvbiIsImVtcHR5VGV4dCIsIm1hcmdpblRvcCIsInRleHRBbGlnbiIsIlRpbWVsaW5lIiwiZmVlZCIsImtleXMiLCJzb3J0IiwicmV2ZXJzZSIsImJvcmRlckJvdHRvbSIsInBhcnNlSW50IiwiZnJvbU5vdyIsImZvbnRXZWlnaHQiLCJwcmV0ZXh0IiwiZ2V0RmVlZCIsIkNhbXBhaWducyIsInNlbGVjdGVkSWQiLCJpc01vZGFsT3BlbiIsImhhbmRsZUNsb3NlIiwiaGFuZGxlQ3JlYXRlIiwiaGFuZGxlRWRpdCIsImhhbmRsZVJlbW92ZSIsImhhc0NhbXBhaWducyIsIm9sZENhbXBhaWducyIsIm5ld0xlbiIsIm9sZExlbiIsIm9wZXJhdGlvbiIsInNldFN0YXRlIiwiaXNPcGVuIiwibWFyZ2luQm90dG9tIiwibWFyZ2luIiwiZWRpdCIsImxvYWRlciIsIm1hcmdpbkxlZnQiLCJDYW1wYWlnbiIsImhhbmRsZU9wZW4iLCJvblJlbW92ZSIsImNhbXBhaWduIiwib25FZGl0IiwidHJpZ2dlciIsImRldGFpbHMiLCJzdWJzdHIiLCJpbml0aWFsU3RhdGUiLCJmb3JtRGF0YSIsIk1vZGFsQ2FtcGFpZ24iLCJoYW5kbGVDaGFuZ2UiLCJoYW5kbGVTdWJtaXQiLCJvbkNsb3NlIiwiZSIsImN1cnJlbnRUYXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsImlzVmFsaWQiLCJzb21lIiwiaXNTYXZpbmciLCJTZXJ2aWNlcyIsImhhc1NlcnZpY2VzIiwib2xkU2VydmljZXMiLCJTZXJ2aWNlIiwic2VydmljZSIsImlzQ3JlYXRpbmdTa2lsbCIsIm9wdGlvbnMiLCJxdHlBdmFpbGFibGUiLCJNb2RhbFNlcnZpY2UiLCJuZXdWYWx1ZSIsIm5ld1NraWxsIiwic3JjSW1nIiwibG9yZW0iLCJwYXJhZ3JhcGgiLCJwYXJhbXMiLCJSZWxhdGVkIiwiQnVzY2FyIiwiRmlsdGVycyIsImhhbmRsZUNsZWFyIiwiaGFuZGxlU2VhcmNoIiwiaGFuZGxlRmlsdGVyQ2xpY2siLCJkcm9wZG93biIsInNldFZhbHVlIiwiYXBwbHlTZWFyY2giLCJhcHBsaWVkRmlsdGVyIiwidHJhbnNpdGlvblRvIiwiY29udGV4dCIsInJvdXRlciIsInNsdWciLCJmaWx0cm8iLCJtZW51Iiwib3B0aW9uIiwibWVudUl0ZW0iLCJzZWxlY3RlZCIsInNlYXJjaEZvcm0iLCJlbCIsImNvbnRleHRUeXBlcyIsImlzUmVxdWlyZWQiLCJnZXRBcHBsaWVkRmlsdGVyIiwiUmVzdWx0cyIsImdldEZpbHRlciIsImNvbXBhcmF0b3IiLCJyZWNvcmRzIiwiY2FyZHMiLCJyZWNvcmQiLCJkYXRlIiwiY2FyZCIsIm5hdmlnYXRlVG8iLCJjYXJkSWNvbiIsInNsaWNlIiwiYXJyYXkiLCJnZXRTZWFyY2hSZXN1bHRzIiwiQ2FtcGFuaGEiLCJzZW50ZW5jZSIsImlkeCIsIk9yZ2FuaXphY2FvIiwiU2VydmljbyIsInNraWxsSUQiLCJMb2dpbiIsImhhbmRsZUxvZ2luIiwiaGFuZGxlUmVnaXN0ZXIiLCJpc0xvZ2dpbmciLCJOb3RpZmljYXRpb25Db250YWluZXIiLCJhZGROb3RpZmljYXRpb24iLCJ0b3BCYXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJwYWRkaW5nIiwibG9nbyIsIlRvcEJhciIsIlRvcEJhclNlYXJjaCIsIm9uVXBkYXRlRmlsdGVyIiwib25GaWx0ZXIiLCJzZWFyY2hJbnB1dCIsImZpbHRlcnMiLCJmaWx0ZXJCdXR0b24iLCJ1cGRhdGVzIiwiVG9wQmFyVXNlciIsImlzTW9kYWxWaXNpYmxlIiwiaGFuZGxlU2V0dGluZ3NUb2dnbGUiLCJoYW5kbGVMb2dvdXQiLCJ2YWxpZGF0ZVVzZXJGaWVsZHMiLCJyZXF1aXJlZEZpZWxkcyIsInNldHRpbmdzUHJvcHMiLCJTZXR0aW5ncyIsIm5leHRQcm9wcyIsInBhc3N3b3JkMiIsImlzVXBkYXRpbmciLCJmb3JtIiwiY2l0eSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBLDBHQUFrRztBQUNsRztBQUNBO0FBQ0E7O0FBRUEsb0RBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFHQUFvRyx3REFBd0QsU0FBUztBQUNySztBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUFzQztBQUN0QztBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ2pTQSxpRDs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLHlDQUF5QztBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7Ozs7QUM5TUEsaUQ7Ozs7Ozs7QUNBQSxpRDs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixrQkFBa0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDNUZBOztBQUVBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O21DQ2xzQkE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FDTEE7QUFDQTtBQUNBLDhCQUE2QixZQUFZLElBQUksSUFBSSxNQUFNLElBQUk7QUFDM0Q7Ozs7Ozs7O0FDSEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNqR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3hFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ2hCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE9B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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDN0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDeENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDaERBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM1Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdEZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ3hEQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBb0IsRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDckVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7OztBQ2hNQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7OztBQ2hCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQzs7QUFFckM7Ozs7Ozs7O0FDL0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0R0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDMUJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOzs7Ozs7OztBQzlEQTs7Ozs7Ozs7O0FDQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBGQUF5Rjs7QUFFekY7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDaENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7bUNDNUlBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLG1DQUFrQyxpREFBaUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLG9EQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7Ozs7Ozs7OztBQ3I0QkQ7Ozs7Ozs7OztBQ0FBOzs7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzFMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDeEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7QUN0RkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DOztBQUVuQzs7Ozs7Ozs7QUNoQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DOztBQUVuQzs7Ozs7Ozs7QUN0QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDakNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN0TEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbEdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQSxvQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDNVhBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDeEZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEMsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUN2QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQ3BFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQ2hDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaERBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFP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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O2FDNXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRkFBaUY7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHNCQUFzQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFVLElBQUk7QUFDZDtBQUNBLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLHdCQUF3QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQix1Q0FBdUM7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFVLE1BQU07QUFDaEIsV0FBVSxPQUFPO0FBQ2pCO0FBQ0EsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVUsTUFBTTtBQUNoQjtBQUNBLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxJQUFJO0FBQ2Q7QUFDQSxZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0EsV0FBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxN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QVMsZ0JBQU16SCxTQUFOLENBQWdCd0M7QUFQUixFOzs7QUErTXJCLEtBQU01QixrQkFBa0IsU0FBbEJBLGVBQWtCO0FBQUEsVUFBVTtBQUNoQzBNLGlCQUFZLG9CQUFVelUsaUJBQVYsQ0FBNEJoRCxLQUE1QixDQURvQjtBQUVoQ3lDLGFBQVEsb0JBQVV5RSxXQUFWLENBQXNCbEgsS0FBdEIsRUFBNkIsUUFBN0I7QUFGd0IsSUFBVjtBQUFBLEVBQXhCOztBQUtBLEtBQU1nTCxxQkFBcUIsU0FBckJBLGtCQUFxQjtBQUFBLFVBQWE7QUFDdEN2TCxjQUFTLCtCQUFtQjRLLGNBQW5CLEVBQW1DWSxRQUFuQztBQUQ2QixJQUFiO0FBQUEsRUFBM0I7O2dCQUllLHlCQUFRRixlQUFSLEVBQXlCQyxrQkFBekIsRUFBNkNzTSxRQUE3QyxDOzs7Ozs7Ozs7O2lDQXpOVEEsUTs7aUNBZ05Bdk0sZTs7aUNBS0FDLGtCOzs7Ozs7Ozs7Ozs7QUMvTk47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEU7Ozs7Ozs7QUNwQkEsaUQiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiX19fQUdFTkNJQV9BTUlHQV9fX1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJfX19BR0VOQ0lBX0FNSUdBX19fXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkFnZW5jaWFBbWlnYVwiXSA9IGZhY3RvcnkocmVxdWlyZShcIl9fX0FHRU5DSUFfQU1JR0FfX19cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkFnZW5jaWFBbWlnYVwiXSA9IGZhY3Rvcnkocm9vdFtcIl9fX0FHRU5DSUFfQU1JR0FfX19cIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0dmFyIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrID0gdGhpc1tcIndlYnBhY2tIb3RVcGRhdGVBZ2VuY2lhQW1pZ2FcIl07XG4gXHR0aGlzW1wid2VicGFja0hvdFVwZGF0ZUFnZW5jaWFBbWlnYVwiXSA9IGZ1bmN0aW9uIHdlYnBhY2tIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcbiBcdFx0aWYocGFyZW50SG90VXBkYXRlQ2FsbGJhY2spIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcbiBcdH1cblxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuIFx0XHRzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5cIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc1wiO1xuIFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkTWFuaWZlc3QoY2FsbGJhY2spIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0XHRpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpXG4gXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydFwiKSk7XG4gXHRcdHRyeSB7XG4gXHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiBcdFx0XHR2YXIgcmVxdWVzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzb25cIjtcbiBcdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgcmVxdWVzdFBhdGgsIHRydWUpO1xuIFx0XHRcdHJlcXVlc3QudGltZW91dCA9IDEwMDAwO1xuIFx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcbiBcdFx0fSBjYXRjaChlcnIpIHtcbiBcdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyKTtcbiBcdFx0fVxuIFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuIFx0XHRcdGlmKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkgcmV0dXJuO1xuIFx0XHRcdGlmKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gXHRcdFx0XHQvLyB0aW1lb3V0XG4gXHRcdFx0XHRjYWxsYmFjayhuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiB0aW1lZCBvdXQuXCIpKTtcbiBcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xuIFx0XHRcdFx0Ly8gbm8gdXBkYXRlIGF2YWlsYWJsZVxuIFx0XHRcdFx0Y2FsbGJhY2soKTtcbiBcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XG4gXHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXG4gXHRcdFx0XHRjYWxsYmFjayhuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiBmYWlsZWQuXCIpKTtcbiBcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0Ly8gc3VjY2Vzc1xuIFx0XHRcdFx0dHJ5IHtcbiBcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuIFx0XHRcdFx0fSBjYXRjaChlKSB7XG4gXHRcdFx0XHRcdGNhbGxiYWNrKGUpO1xuIFx0XHRcdFx0XHRyZXR1cm47XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRjYWxsYmFjayhudWxsLCB1cGRhdGUpO1xuIFx0XHRcdH1cbiBcdFx0fTtcbiBcdH1cblxuXG4gXHQvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iZWY0NWIwL3NyYy9zaGFyZWQvdXRpbHMvY2FuRGVmaW5lUHJvcGVydHkuanNcbiBcdHZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuIFx0dHJ5IHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInhcIiwge1xuIFx0XHRcdGdldDogZnVuY3Rpb24oKSB7fVxuIFx0XHR9KTtcbiBcdFx0Y2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xuIFx0fSBjYXRjaCh4KSB7XG4gXHRcdC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuIFx0fVxuXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcIjkyOWJmZThiYjNlNjJjMmQ5NjI0XCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RDdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlUmVxdWlyZShtb2R1bGVJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRpZighbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xuIFx0XHR2YXIgZm4gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gXHRcdFx0aWYobWUuaG90LmFjdGl2ZSkge1xuIFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuIFx0XHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPCAwKVxuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcbiBcdFx0XHRcdFx0aWYobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA8IDApXG4gXHRcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcbiBcdFx0XHRcdH0gZWxzZSBob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XG4gXHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlcXVlc3QgKyBcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgKyBtb2R1bGVJZCk7XG4gXHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFtdO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhyZXF1ZXN0KTtcbiBcdFx0fTtcbiBcdFx0Zm9yKHZhciBuYW1lIGluIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX193ZWJwYWNrX3JlcXVpcmVfXywgbmFtZSkpIHtcbiBcdFx0XHRcdGlmKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgKGZ1bmN0aW9uKG5hbWUpIHtcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG4gXHRcdFx0XHRcdFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdO1xuIFx0XHRcdFx0XHRcdFx0fSxcbiBcdFx0XHRcdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiBcdFx0XHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXSA9IHZhbHVlO1xuIFx0XHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdH07XG4gXHRcdFx0XHRcdH0obmFtZSkpKTtcbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdGZuW25hbWVdID0gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHRmdW5jdGlvbiBlbnN1cmUoY2h1bmtJZCwgY2FsbGJhY2spIHtcbiBcdFx0XHRpZihob3RTdGF0dXMgPT09IFwicmVhZHlcIilcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xuIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkLCBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgZm4pO1xuIFx0XHRcdFx0fSBmaW5hbGx5IHtcbiBcdFx0XHRcdFx0ZmluaXNoQ2h1bmtMb2FkaW5nKCk7XG4gXHRcdFx0XHR9XG5cbiBcdFx0XHRcdGZ1bmN0aW9uIGZpbmlzaENodW5rTG9hZGluZygpIHtcbiBcdFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xuIFx0XHRcdFx0XHRpZihob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiKSB7XG4gXHRcdFx0XHRcdFx0aWYoIWhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSkge1xuIFx0XHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdGlmKGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiYgaG90V2FpdGluZ0ZpbGVzID09PSAwKSB7XG4gXHRcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdFx0aWYoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwiZVwiLCB7XG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0dmFsdWU6IGVuc3VyZVxuIFx0XHRcdH0pO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdGZuLmUgPSBlbnN1cmU7XG4gXHRcdH1cbiBcdFx0cmV0dXJuIGZuO1xuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0XHR2YXIgaG90ID0ge1xuIFx0XHRcdC8vIHByaXZhdGUgc3R1ZmZcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG4gXHRcdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG5cbiBcdFx0XHQvLyBNb2R1bGUgQVBJXG4gXHRcdFx0YWN0aXZlOiB0cnVlLFxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xuIFx0XHRcdFx0aWYodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIilcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrO1xuIFx0XHRcdFx0ZWxzZVxuIFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjaztcbiBcdFx0XHR9LFxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xuIFx0XHRcdFx0aWYodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIilcbiBcdFx0XHRcdFx0aG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm51bWJlclwiKVxuIFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZVxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XG4gXHRcdFx0fSxcbiBcdFx0XHRkaXNwb3NlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG4gXHRcdFx0fSxcbiBcdFx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuIFx0XHRcdH0sXG4gXHRcdFx0cmVtb3ZlRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHR2YXIgaWR4ID0gaG90Ll9kaXNwb3NlSGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0fSxcblxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxuIFx0XHRcdGFwcGx5OiBob3RBcHBseSxcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGlmKCFsKSByZXR1cm4gaG90U3RhdHVzO1xuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG4gXHRcdFx0fSxcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHR2YXIgaWR4ID0gaG90U3RhdHVzSGFuZGxlcnMuaW5kZXhPZihsKTtcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSBob3RTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHR9LFxuXG4gXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXG4gXHRcdFx0ZGF0YTogaG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXG4gXHRcdH07XG4gXHRcdHJldHVybiBob3Q7XG4gXHR9XG5cbiBcdHZhciBob3RTdGF0dXNIYW5kbGVycyA9IFtdO1xuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xuXG4gXHRmdW5jdGlvbiBob3RTZXRTdGF0dXMobmV3U3RhdHVzKSB7XG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhvdFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxuIFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzW2ldLmNhbGwobnVsbCwgbmV3U3RhdHVzKTtcbiBcdH1cblxuIFx0Ly8gd2hpbGUgZG93bmxvYWRpbmdcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xuIFx0dmFyIGhvdENodW5rc0xvYWRpbmcgPSAwO1xuIFx0dmFyIGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90QXZhaWxpYmxlRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3RDYWxsYmFjaztcblxuIFx0Ly8gVGhlIHVwZGF0ZSBpbmZvXG4gXHR2YXIgaG90VXBkYXRlLCBob3RVcGRhdGVOZXdIYXNoO1xuXG4gXHRmdW5jdGlvbiB0b01vZHVsZUlkKGlkKSB7XG4gXHRcdHZhciBpc051bWJlciA9ICgraWQpICsgXCJcIiA9PT0gaWQ7XG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSwgY2FsbGJhY2spIHtcbiBcdFx0aWYoaG90U3RhdHVzICE9PSBcImlkbGVcIikgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XG4gXHRcdGlmKHR5cGVvZiBhcHBseSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gXHRcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGZhbHNlO1xuIFx0XHRcdGNhbGxiYWNrID0gYXBwbHk7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGFwcGx5O1xuIFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRpZihlcnIpIHRocm93IGVycjtcbiBcdFx0XHR9O1xuIFx0XHR9XG4gXHRcdGhvdFNldFN0YXR1cyhcImNoZWNrXCIpO1xuIFx0XHRob3REb3dubG9hZE1hbmlmZXN0KGZ1bmN0aW9uKGVyciwgdXBkYXRlKSB7XG4gXHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiBcdFx0XHRpZighdXBkYXRlKSB7XG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gXHRcdFx0XHRyZXR1cm47XG4gXHRcdFx0fVxuXG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcbiBcdFx0XHRob3RBdmFpbGlibGVGaWxlc01hcCA9IHt9O1xuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xuIFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB1cGRhdGUuYy5sZW5ndGg7IGkrKylcbiBcdFx0XHRcdGhvdEF2YWlsaWJsZUZpbGVzTWFwW3VwZGF0ZS5jW2ldXSA9IHRydWU7XG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xuXG4gXHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcbiBcdFx0XHRob3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xuIFx0XHRcdHZhciBjaHVua0lkID0gMDtcbiBcdFx0XHR7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZS1ibG9ja3NcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xuIFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xuIFx0XHRcdH1cbiBcdFx0fSk7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdFx0aWYoIWhvdEF2YWlsaWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcbiBcdFx0XHRyZXR1cm47XG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XG4gXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0aG90VXBkYXRlW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0aWYoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XG4gXHRcdGlmKCFob3RBdmFpbGlibGVGaWxlc01hcFtjaHVua0lkXSkge1xuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xuIFx0XHRcdGhvdFdhaXRpbmdGaWxlcysrO1xuIFx0XHRcdGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdH1cbiBcdH1cblxuIFx0ZnVuY3Rpb24gaG90VXBkYXRlRG93bmxvYWRlZCgpIHtcbiBcdFx0aG90U2V0U3RhdHVzKFwicmVhZHlcIik7XG4gXHRcdHZhciBjYWxsYmFjayA9IGhvdENhbGxiYWNrO1xuIFx0XHRob3RDYWxsYmFjayA9IG51bGw7XG4gXHRcdGlmKCFjYWxsYmFjaykgcmV0dXJuO1xuIFx0XHRpZihob3RBcHBseU9uVXBkYXRlKSB7XG4gXHRcdFx0aG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSwgY2FsbGJhY2spO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcbiBcdFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHRvTW9kdWxlSWQoaWQpKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdFx0Y2FsbGJhY2sobnVsbCwgb3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zLCBjYWxsYmFjaykge1xuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xuIFx0XHRpZih0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gXHRcdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuIFx0XHRcdG9wdGlvbnMgPSB7fTtcbiBcdFx0fSBlbHNlIGlmKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcbiBcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKGVycikge1xuIFx0XHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XG4gXHRcdFx0fTtcbiBcdFx0fSBlbHNlIHtcbiBcdFx0XHRvcHRpb25zID0ge307XG4gXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcbiBcdFx0XHRcdGlmKGVycikgdGhyb3cgZXJyO1xuIFx0XHRcdH07XG4gXHRcdH1cblxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZSkge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbbW9kdWxlXTtcbiBcdFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuIFx0XHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xuIFx0XHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiBcdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYoIW1vZHVsZSB8fCBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQpXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xuIFx0XHRcdFx0aWYobW9kdWxlLmhvdC5fc2VsZkRlY2xpbmVkKSB7XG4gXHRcdFx0XHRcdHJldHVybiBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArIG1vZHVsZUlkKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmKG1vZHVsZUlkID09PSAwKSB7XG4gXHRcdFx0XHRcdHJldHVybjtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICsgbW9kdWxlSWQgKyBcIiBpbiBcIiArIHBhcmVudElkKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRpZihvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgPj0gMCkgY29udGludWU7XG4gXHRcdFx0XHRcdGlmKHBhcmVudC5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcbiBcdFx0XHRcdFx0cXVldWUucHVzaChwYXJlbnRJZCk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuXG4gXHRcdFx0cmV0dXJuIFtvdXRkYXRlZE1vZHVsZXMsIG91dGRhdGVkRGVwZW5kZW5jaWVzXTtcbiBcdFx0fVxuXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcbiBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xuIFx0XHRcdFx0aWYoYS5pbmRleE9mKGl0ZW0pIDwgMClcbiBcdFx0XHRcdFx0YS5wdXNoKGl0ZW0pO1xuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXG4gXHRcdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cbiBcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcbiBcdFx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcbiBcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcbiBcdFx0XHRcdHZhciBtb2R1bGVJZCA9IHRvTW9kdWxlSWQoaWQpO1xuIFx0XHRcdFx0dmFyIHJlc3VsdCA9IGdldEFmZmVjdGVkU3R1ZmYobW9kdWxlSWQpO1xuIFx0XHRcdFx0aWYoIXJlc3VsdCkge1xuIFx0XHRcdFx0XHRpZihvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXG4gXHRcdFx0XHRcdFx0Y29udGludWU7XG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xuIFx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIikpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XG4gXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhyZXN1bHQpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBob3RVcGRhdGVbbW9kdWxlSWRdO1xuIFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHRbMF0pO1xuIFx0XHRcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiByZXN1bHRbMV0pIHtcbiBcdFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdFsxXSwgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSA9IFtdO1xuIFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSwgcmVzdWx0WzFdW21vZHVsZUlkXSk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXG4gXHRcdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdHZhciBtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZClcbiBcdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxuIFx0XHRcdFx0fSk7XG4gXHRcdH1cblxuIFx0XHQvLyBOb3cgaW4gXCJkaXNwb3NlXCIgcGhhc2VcbiBcdFx0aG90U2V0U3RhdHVzKFwiZGlzcG9zZVwiKTtcbiBcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XG4gXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiBcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZS5wb3AoKTtcbiBcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0aWYoIW1vZHVsZSkgY29udGludWU7XG5cbiBcdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG4gXHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXG4gXHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcbiBcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gXHRcdFx0XHR2YXIgY2IgPSBkaXNwb3NlSGFuZGxlcnNbal07XG4gXHRcdFx0XHRjYihkYXRhKTtcbiBcdFx0XHR9XG4gXHRcdFx0aG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdID0gZGF0YTtcblxuIFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXG4gXHRcdFx0bW9kdWxlLmhvdC5hY3RpdmUgPSBmYWxzZTtcblxuIFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxuIFx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcblxuIFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXG4gXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuIFx0XHRcdFx0aWYoIWNoaWxkKSBjb250aW51ZTtcbiBcdFx0XHRcdHZhciBpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcbiBcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxuIFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuIFx0XHRcdFx0XHR2YXIgaWR4ID0gbW9kdWxlLmNoaWxkcmVuLmluZGV4T2YoZGVwZW5kZW5jeSk7XG4gXHRcdFx0XHRcdGlmKGlkeCA+PSAwKSBtb2R1bGUuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTm90IGluIFwiYXBwbHlcIiBwaGFzZVxuIFx0XHRob3RTZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuIFx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XG5cbiBcdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXG4gXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcHBsaWVkVXBkYXRlLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcbiBcdFx0dmFyIGVycm9yID0gbnVsbDtcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG4gXHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gW107XG4gXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXTtcbiBcdFx0XHRcdFx0dmFyIGNiID0gbW9kdWxlLmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwZW5kZW5jeV07XG4gXHRcdFx0XHRcdGlmKGNhbGxiYWNrcy5pbmRleE9mKGNiKSA+PSAwKSBjb250aW51ZTtcbiBcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goY2IpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHR2YXIgY2IgPSBjYWxsYmFja3NbaV07XG4gXHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0Y2Iob3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xuIFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xuIFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcbiBcdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xuIFx0XHRcdHZhciBtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcbiBcdFx0XHR0cnkge1xuIFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcbiBcdFx0XHRcdGlmKHR5cGVvZiBpdGVtLmVycm9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gXHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcbiBcdFx0XHRcdFx0fSBjYXRjaChlcnIpIHtcbiBcdFx0XHRcdFx0XHRpZighZXJyb3IpXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fSBlbHNlIGlmKCFlcnJvcilcbiBcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gaGFuZGxlIGVycm9ycyBpbiBhY2NlcHQgaGFuZGxlcnMgYW5kIHNlbGYgYWNjZXB0ZWQgbW9kdWxlIGxvYWRcbiBcdFx0aWYoZXJyb3IpIHtcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xuIFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gXHRcdH1cblxuIFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRjYWxsYmFjayhudWxsLCBvdXRkYXRlZE1vZHVsZXMpO1xuIFx0fVxuXG4gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2UsXG4gXHRcdFx0aG90OiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpLFxuIFx0XHRcdHBhcmVudHM6IGhvdEN1cnJlbnRQYXJlbnRzLFxuIFx0XHRcdGNoaWxkcmVuOiBbXVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJodHRwOi8vbG9jYWxob3N0OjQwMDAvanMvXCI7XG5cbiBcdC8vIF9fd2VicGFja19oYXNoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18uaCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaG90Q3VycmVudEhhc2g7IH07XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIGhvdENyZWF0ZVJlcXVpcmUoMCkoMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOTI5YmZlOGJiM2U2MmMyZDk2MjQiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tYWluX193cmFwcGVyX18zX3RmRk1qMk1QIHtcXG4gIGJhY2tncm91bmQ6ICNmMGYwZjA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwOyB9XFxuXFxuLm1haW5fX2NvbnRlbnRfXzF1aGFfNEZUdUwge1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBwYWRkaW5nOiAuOGVtOyB9XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy92aWV3cy9jb250YWluZXJzL3NyYy92aWV3cy9jb250YWluZXJzL21haW4uc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLG9CQUFvQjtFQUNwQixtQkFBbUI7RUFDbkIsaUJBQWlCO0VBQ2pCLGdCQUFnQjtFQUNoQixPQUFPO0VBQ1AsUUFBUTtFQUNSLFNBQVM7RUFDVCxVQUFVLEVBQ1g7O0FBRUQ7RUFDRSxlQUFlO0VBQ2YsY0FBYyxFQUNmXCIsXCJmaWxlXCI6XCJtYWluLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLndyYXBwZXIge1xcbiAgYmFja2dyb3VuZDogI2YwZjBmMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBmb250LXNpemU6IDFyZW07XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3R0b206IDA7XFxufVxcblxcbi5jb250ZW50IHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbiAgcGFkZGluZzogLjhlbTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJ3cmFwcGVyXCI6IFwibWFpbl9fd3JhcHBlcl9fM190ZkZNajJNUFwiLFxuXHRcImNvbnRlbnRcIjogXCJtYWluX19jb250ZW50X18xdWhhXzRGVHVMXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vfi9wb3N0Y3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRhaW5lcnMvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGFpbmVycy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZXNsaW50LWRpc2FibGUgZ2xvYmFsLXJlcXVpcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIW1vZHVsZS5ob3QgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcGF0Y2gucHJvZCcpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BhdGNoLmRldicpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1ob3QtbG9hZGVyL2xpYi9wYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmVhY3QtaG90LWxvYWRlci9saWIvcGF0Y2guanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNyZWF0ZVByb3h5ID0gcmVxdWlyZSgncmVhY3QtcHJveHknKS5kZWZhdWx0O1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJ2dsb2JhbCcpO1xuXG52YXIgQ29tcG9uZW50TWFwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnRNYXAodXNlV2Vha01hcCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnRNYXApO1xuXG4gICAgaWYgKHVzZVdlYWtNYXApIHtcbiAgICAgIHRoaXMud20gPSBuZXcgV2Vha01hcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNsb3RzID0ge307XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbXBvbmVudE1hcCwgW3tcbiAgICBrZXk6ICdnZXRTbG90JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2xvdCh0eXBlKSB7XG4gICAgICB2YXIga2V5ID0gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICAgICAgaWYgKCF0aGlzLnNsb3RzW2tleV0pIHtcbiAgICAgICAgdGhpcy5zbG90c1trZXldID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zbG90c1trZXldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldCh0eXBlKSB7XG4gICAgICBpZiAodGhpcy53bSkge1xuICAgICAgICByZXR1cm4gdGhpcy53bS5nZXQodHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbG90ID0gdGhpcy5nZXRTbG90KHR5cGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbG90Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzbG90W2ldLmtleSA9PT0gdHlwZSkge1xuICAgICAgICAgIHJldHVybiBzbG90W2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy53bSkge1xuICAgICAgICB0aGlzLndtLnNldCh0eXBlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2xvdCA9IHRoaXMuZ2V0U2xvdCh0eXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbG90Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNsb3RbaV0ua2V5ID09PSB0eXBlKSB7XG4gICAgICAgICAgICBzbG90W2ldLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNsb3QucHVzaCh7IGtleTogdHlwZSwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyh0eXBlKSB7XG4gICAgICBpZiAodGhpcy53bSkge1xuICAgICAgICByZXR1cm4gdGhpcy53bS5oYXModHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbG90ID0gdGhpcy5nZXRTbG90KHR5cGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbG90Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzbG90W2ldLmtleSA9PT0gdHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbXBvbmVudE1hcDtcbn0oKTtcblxudmFyIHByb3hpZXNCeUlEID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dElEID0gdm9pZCAwO1xudmFyIGhhc0NyZWF0ZWRFbGVtZW50c0J5VHlwZSA9IHZvaWQgMDtcbnZhciBpZHNCeVR5cGUgPSB2b2lkIDA7XG5cbnZhciBob29rcyA9IHtcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIHVuaXF1ZUxvY2FsTmFtZSwgZmlsZU5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF1bmlxdWVMb2NhbE5hbWUgfHwgIWZpbGVOYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdW5pcXVlTG9jYWxOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZmlsZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpZCA9IGZpbGVOYW1lICsgJyMnICsgdW5pcXVlTG9jYWxOYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgIGlmICghaWRzQnlUeXBlLmhhcyh0eXBlKSAmJiBoYXNDcmVhdGVkRWxlbWVudHNCeVR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dElEW2lkXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJRFtpZF0gPSB0cnVlO1xuICAgICAgICB2YXIgYmFzZU5hbWUgPSBmaWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWN0IEhvdCBMb2FkZXI6ICcgKyB1bmlxdWVMb2NhbE5hbWUgKyAnIGluICcgKyBmaWxlTmFtZSArICcgd2lsbCBub3QgaG90IHJlbG9hZCAnICsgKCdjb3JyZWN0bHkgYmVjYXVzZSAnICsgYmFzZU5hbWUgKyAnIHVzZXMgPCcgKyB1bmlxdWVMb2NhbE5hbWUgKyAnIC8+IGR1cmluZyAnKSArICgnbW9kdWxlIGRlZmluaXRpb24uIEZvciBob3QgcmVsb2FkaW5nIHRvIHdvcmssIG1vdmUgJyArIHVuaXF1ZUxvY2FsTmFtZSArICcgJykgKyAoJ2ludG8gYSBzZXBhcmF0ZSBmaWxlIGFuZCBpbXBvcnQgaXQgZnJvbSAnICsgYmFzZU5hbWUgKyAnLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1lbWJlciB0aGUgSUQuXG4gICAgaWRzQnlUeXBlLnNldCh0eXBlLCBpZCk7XG5cbiAgICAvLyBXZSB1c2UgUmVhY3QgUHJveHkgdG8gZ2VuZXJhdGUgY2xhc3NlcyB0aGF0IGJlaGF2ZSBhbG1vc3RcbiAgICAvLyB0aGUgc2FtZSB3YXkgYXMgdGhlIG9yaWdpbmFsIGNsYXNzZXMgYnV0IGFyZSB1cGRhdGFibGUgd2l0aFxuICAgIC8vIG5ldyB2ZXJzaW9ucyB3aXRob3V0IGRlc3Ryb3lpbmcgb3JpZ2luYWwgaW5zdGFuY2VzLlxuICAgIGlmICghcHJveGllc0J5SURbaWRdKSB7XG4gICAgICBwcm94aWVzQnlJRFtpZF0gPSBjcmVhdGVQcm94eSh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveGllc0J5SURbaWRdLnVwZGF0ZSh0eXBlKTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCh1c2VXZWFrTWFwKSB7XG4gICAgcHJveGllc0J5SUQgPSB7fTtcbiAgICBkaWRXYXJuQWJvdXRJRCA9IHt9O1xuICAgIGhhc0NyZWF0ZWRFbGVtZW50c0J5VHlwZSA9IG5ldyBDb21wb25lbnRNYXAodXNlV2Vha01hcCk7XG4gICAgaWRzQnlUeXBlID0gbmV3IENvbXBvbmVudE1hcCh1c2VXZWFrTWFwKTtcbiAgfVxufTtcblxuaG9va3MucmVzZXQodHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicpO1xuXG5mdW5jdGlvbiByZXNvbHZlVHlwZSh0eXBlKSB7XG4gIC8vIFdlIG9ubHkgY2FyZSBhYm91dCBjb21wb3NpdGUgY29tcG9uZW50c1xuICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGhhc0NyZWF0ZWRFbGVtZW50c0J5VHlwZS5zZXQodHlwZSwgdHJ1ZSk7XG5cbiAgLy8gV2hlbiBhdmFpbGFibGUsIGdpdmUgcHJveHkgY2xhc3MgdG8gUmVhY3QgaW5zdGVhZCBvZiB0aGUgcmVhbCBjbGFzcy5cbiAgdmFyIGlkID0gaWRzQnlUeXBlLmdldCh0eXBlKTtcbiAgaWYgKCFpZCkge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgdmFyIHByb3h5ID0gcHJveGllc0J5SURbaWRdO1xuICBpZiAoIXByb3h5KSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICByZXR1cm4gcHJveHkuZ2V0KCk7XG59XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3QuY3JlYXRlRWxlbWVudDtcbmZ1bmN0aW9uIHBhdGNoZWRDcmVhdGVFbGVtZW50KHR5cGUpIHtcbiAgLy8gVHJpY2sgUmVhY3QgaW50byByZW5kZXJpbmcgYSBwcm94eSBzbyB0aGF0XG4gIC8vIGl0cyBzdGF0ZSBpcyBwcmVzZXJ2ZWQgd2hlbiB0aGUgY2xhc3MgY2hhbmdlcy5cbiAgLy8gVGhpcyB3aWxsIHVwZGF0ZSB0aGUgcHJveHkgaWYgaXQncyBmb3IgYSBrbm93biB0eXBlLlxuICB2YXIgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZVR5cGUodHlwZSk7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gY3JlYXRlRWxlbWVudC5hcHBseSh1bmRlZmluZWQsIFtyZXNvbHZlZFR5cGVdLmNvbmNhdChhcmdzKSk7XG59XG5wYXRjaGVkQ3JlYXRlRWxlbWVudC5pc1BhdGNoZWRCeVJlYWN0SG90TG9hZGVyID0gdHJ1ZTtcblxuZnVuY3Rpb24gcGF0Y2hlZENyZWF0ZUZhY3RvcnkodHlwZSkge1xuICAvLyBQYXRjaCBSZWFjdC5jcmVhdGVGYWN0b3J5IHRvIHVzZSBwYXRjaGVkIGNyZWF0ZUVsZW1lbnRcbiAgLy8gYmVjYXVzZSB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgaW50ZXJuYWwsXG4gIC8vIHVucGF0Y2hlZCBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudFxuICB2YXIgZmFjdG9yeSA9IHBhdGNoZWRDcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufVxucGF0Y2hlZENyZWF0ZUZhY3RvcnkuaXNQYXRjaGVkQnlSZWFjdEhvdExvYWRlciA9IHRydWU7XG5cbmlmICh0eXBlb2YgZ2xvYmFsLl9fUkVBQ1RfSE9UX0xPQURFUl9fID09PSAndW5kZWZpbmVkJykge1xuICBSZWFjdC5jcmVhdGVFbGVtZW50ID0gcGF0Y2hlZENyZWF0ZUVsZW1lbnQ7XG4gIFJlYWN0LmNyZWF0ZUZhY3RvcnkgPSBwYXRjaGVkQ3JlYXRlRmFjdG9yeTtcbiAgZ2xvYmFsLl9fUkVBQ1RfSE9UX0xPQURFUl9fID0gaG9va3M7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWhvdC1sb2FkZXIvbGliL3BhdGNoLmRldi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmVhY3QtaG90LWxvYWRlci9saWIvcGF0Y2guZGV2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDk2NCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX19fQUdFTkNJQV9BTUlHQV9fXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIl9fX0FHRU5DSUFfQU1JR0FfX19cIlxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3VwcG9ydHNQcm90b0Fzc2lnbm1lbnQgPSByZXF1aXJlKCcuL3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50Jyk7XG5cbnZhciBfc3VwcG9ydHNQcm90b0Fzc2lnbm1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHNQcm90b0Fzc2lnbm1lbnQpO1xuXG52YXIgX2NyZWF0ZUNsYXNzUHJveHkgPSByZXF1aXJlKCcuL2NyZWF0ZUNsYXNzUHJveHknKTtcblxudmFyIF9jcmVhdGVDbGFzc1Byb3h5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzUHJveHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5pZiAoISgwLCBfc3VwcG9ydHNQcm90b0Fzc2lnbm1lbnQyLmRlZmF1bHQpKCkpIHtcbiAgY29uc29sZS53YXJuKCdUaGlzIEphdmFTY3JpcHQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBfX3Byb3RvX18uICcgKyAnVGhpcyBtZWFucyB0aGF0IHJlYWN0LXByb3h5IGlzIHVuYWJsZSB0byBwcm94eSBSZWFjdCBjb21wb25lbnRzLiAnICsgJ0ZlYXR1cmVzIHRoYXQgcmVseSBvbiByZWFjdC1wcm94eSwgc3VjaCBhcyByZWFjdC10cmFuc2Zvcm0taG1yLCAnICsgJ3dpbGwgbm90IGZ1bmN0aW9uIGFzIGV4cGVjdGVkLicpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfY3JlYXRlQ2xhc3NQcm94eTIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcHJveHkvbW9kdWxlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmVhY3QtcHJveHkvbW9kdWxlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHN1cHBvcnRzUHJvdG9Bc3NpZ25tZW50O1xudmFyIHggPSB7fTtcbnZhciB5ID0geyBzdXBwb3J0czogdHJ1ZSB9O1xudHJ5IHtcbiAgeC5fX3Byb3RvX18gPSB5O1xufSBjYXRjaCAoZXJyKSB7fVxuXG5mdW5jdGlvbiBzdXBwb3J0c1Byb3RvQXNzaWdubWVudCgpIHtcbiAgcmV0dXJuIHguc3VwcG9ydHMgfHwgZmFsc2U7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1wcm94eS9tb2R1bGVzL3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yZWFjdC1wcm94eS9tb2R1bGVzL3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVDbGFzc1Byb3h5O1xuXG52YXIgX2ZpbmQgPSByZXF1aXJlKCdsb2Rhc2gvZmluZCcpO1xuXG52YXIgX2ZpbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmluZCk7XG5cbnZhciBfY3JlYXRlUHJvdG90eXBlUHJveHkgPSByZXF1aXJlKCcuL2NyZWF0ZVByb3RvdHlwZVByb3h5Jyk7XG5cbnZhciBfY3JlYXRlUHJvdG90eXBlUHJveHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUHJvdG90eXBlUHJveHkpO1xuXG52YXIgX2JpbmRBdXRvQmluZE1ldGhvZHMgPSByZXF1aXJlKCcuL2JpbmRBdXRvQmluZE1ldGhvZHMnKTtcblxudmFyIF9iaW5kQXV0b0JpbmRNZXRob2RzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBdXRvQmluZE1ldGhvZHMpO1xuXG52YXIgX2RlbGV0ZVVua25vd25BdXRvQmluZE1ldGhvZHMgPSByZXF1aXJlKCcuL2RlbGV0ZVVua25vd25BdXRvQmluZE1ldGhvZHMnKTtcblxudmFyIF9kZWxldGVVbmtub3duQXV0b0JpbmRNZXRob2RzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbGV0ZVVua25vd25BdXRvQmluZE1ldGhvZHMpO1xuXG52YXIgX3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50ID0gcmVxdWlyZSgnLi9zdXBwb3J0c1Byb3RvQXNzaWdubWVudCcpO1xuXG52YXIgX3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBSRVNFUlZFRF9TVEFUSUNTID0gWydsZW5ndGgnLCAnZGlzcGxheU5hbWUnLCAnbmFtZScsICdhcmd1bWVudHMnLCAnY2FsbGVyJywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddO1xuXG5mdW5jdGlvbiBpc0VxdWFsRGVzY3JpcHRvcihhLCBiKSB7XG4gIGlmICghYSAmJiAhYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghYSB8fCAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgIGlmIChhW2tleV0gIT09IGJba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZTtcbiAgcmV0dXJuIGRpc3BsYXlOYW1lICYmIGRpc3BsYXlOYW1lICE9PSAnUmVhY3RDb21wb25lbnQnID8gZGlzcGxheU5hbWUgOiAnVW5rbm93bic7XG59XG5cbi8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgYSBXZWFrTWFwIGJ1dCB3ZSBoYWQgaXNzdWVzIHdpdGggUmVhY3QgTmF0aXZlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhZWFyb24vcmVhY3QtcHJveHkvaXNzdWVzLzUwI2lzc3VlY29tbWVudC0xOTI5MjgwNjZcbnZhciBhbGxQcm94aWVzID0gW107XG5mdW5jdGlvbiBmaW5kUHJveHkoQ29tcG9uZW50KSB7XG4gIHZhciBwYWlyID0gKDAsIF9maW5kMi5kZWZhdWx0KShhbGxQcm94aWVzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpO1xuXG4gICAgdmFyIGtleSA9IF9yZWYyWzBdO1xuICAgIHJldHVybiBrZXkgPT09IENvbXBvbmVudDtcbiAgfSk7XG4gIHJldHVybiBwYWlyID8gcGFpclsxXSA6IG51bGw7XG59XG5mdW5jdGlvbiBhZGRQcm94eShDb21wb25lbnQsIHByb3h5KSB7XG4gIGFsbFByb3hpZXMucHVzaChbQ29tcG9uZW50LCBwcm94eV0pO1xufVxuXG5mdW5jdGlvbiBwcm94eUNsYXNzKEluaXRpYWxDb21wb25lbnQpIHtcbiAgLy8gUHJldmVudCBkb3VibGUgd3JhcHBpbmcuXG4gIC8vIEdpdmVuIGEgcHJveHkgY2xhc3MsIHJldHVybiB0aGUgZXhpc3RpbmcgcHJveHkgbWFuYWdpbmcgaXQuXG4gIHZhciBleGlzdGluZ1Byb3h5ID0gZmluZFByb3h5KEluaXRpYWxDb21wb25lbnQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG5cbiAgdmFyIEN1cnJlbnRDb21wb25lbnQgPSB1bmRlZmluZWQ7XG4gIHZhciBQcm94eUNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIHNhdmVkRGVzY3JpcHRvcnMgPSB7fTtcblxuICBmdW5jdGlvbiBpbnN0YW50aWF0ZShmYWN0b3J5LCBjb250ZXh0LCBwYXJhbXMpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gZmFjdG9yeSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb21wb25lbnQuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5hdGl2ZSBFUzYgY2xhc3MgaW5zdGFudGlhdGlvblxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KGNvbXBvbmVudCwgW251bGxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGFyYW1zKSkpKSgpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGluc3RhbmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoUkVTRVJWRURfU1RBVElDUy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0W2tleV0gPSBpbnN0YW5jZVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoSW5pdGlhbENvbXBvbmVudCk7XG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIGEgcHJveHkgY29uc3RydWN0b3Igd2l0aCBtYXRjaGluZyBuYW1lXG4gICAgUHJveHlDb21wb25lbnQgPSBuZXcgRnVuY3Rpb24oJ2ZhY3RvcnknLCAnaW5zdGFudGlhdGUnLCAncmV0dXJuIGZ1bmN0aW9uICcgKyBkaXNwbGF5TmFtZSArICcoKSB7XFxuICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlKGZhY3RvcnksIHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfScpKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBDdXJyZW50Q29tcG9uZW50O1xuICAgIH0sIGluc3RhbnRpYXRlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gU29tZSBlbnZpcm9ubWVudHMgbWF5IGZvcmJpZCBkeW5hbWljIGV2YWx1YXRpb25cbiAgICBQcm94eUNvbXBvbmVudCA9IGZ1bmN0aW9uIFByb3h5Q29tcG9uZW50KCkge1xuICAgICAgcmV0dXJuIGluc3RhbnRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEN1cnJlbnRDb21wb25lbnQ7XG4gICAgICB9LCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJveHlDb21wb25lbnQsICduYW1lJywge1xuICAgICAgdmFsdWU6IGRpc3BsYXlOYW1lXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge31cblxuICAvLyBQcm94eSB0b1N0cmluZygpIHRvIHRoZSBjdXJyZW50IGNvbnN0cnVjdG9yXG4gIFByb3h5Q29tcG9uZW50LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEN1cnJlbnRDb21wb25lbnQudG9TdHJpbmcoKTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlUHJveHkgPSB1bmRlZmluZWQ7XG4gIGlmIChJbml0aWFsQ29tcG9uZW50LnByb3RvdHlwZSAmJiBJbml0aWFsQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgLy8gUG9pbnQgcHJveHkgY29uc3RydWN0b3IgdG8gdGhlIHByb3h5IHByb3RvdHlwZVxuICAgIHByb3RvdHlwZVByb3h5ID0gKDAsIF9jcmVhdGVQcm90b3R5cGVQcm94eTIuZGVmYXVsdCkoKTtcbiAgICBQcm94eUNvbXBvbmVudC5wcm90b3R5cGUgPSBwcm90b3R5cGVQcm94eS5nZXQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShOZXh0Q29tcG9uZW50KSB7XG4gICAgaWYgKHR5cGVvZiBOZXh0Q29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgY29uc3RydWN0b3IuJyk7XG4gICAgfVxuICAgIGlmIChOZXh0Q29tcG9uZW50ID09PSBDdXJyZW50Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBwcm94eSBjeWNsZXNcbiAgICB2YXIgZXhpc3RpbmdQcm94eSA9IGZpbmRQcm94eShOZXh0Q29tcG9uZW50KTtcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZShleGlzdGluZ1Byb3h5Ll9fZ2V0Q3VycmVudCgpKTtcbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoZSBuZXh0IGNvbnN0cnVjdG9yIHNvIHdlIGNhbGwgaXRcbiAgICB2YXIgUHJldmlvdXNDb21wb25lbnQgPSBDdXJyZW50Q29tcG9uZW50O1xuICAgIEN1cnJlbnRDb21wb25lbnQgPSBOZXh0Q29tcG9uZW50O1xuXG4gICAgLy8gVHJ5IHRvIGluZmVyIGRpc3BsYXlOYW1lXG4gICAgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShOZXh0Q29tcG9uZW50KTtcbiAgICBQcm94eUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJveHlDb21wb25lbnQsICduYW1lJywge1xuICAgICAgICB2YWx1ZTogZGlzcGxheU5hbWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIC8vIFNldCB1cCB0aGUgc2FtZSBwcm90b3R5cGUgZm9yIGluaGVyaXRlZCBzdGF0aWNzXG4gICAgUHJveHlDb21wb25lbnQuX19wcm90b19fID0gTmV4dENvbXBvbmVudC5fX3Byb3RvX187XG5cbiAgICAvLyBDb3B5IG92ZXIgc3RhdGljIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYWRkZWQgYXQgcnVudGltZVxuICAgIGlmIChQcmV2aW91c0NvbXBvbmVudCkge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoUHJldmlvdXNDb21wb25lbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoUkVTRVJWRURfU1RBVElDUy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUHJldmlvdXNDb21wb25lbnQsIGtleSk7XG4gICAgICAgIHZhciBzYXZlZERlc2NyaXB0b3IgPSBzYXZlZERlc2NyaXB0b3JzW2tleV07XG5cbiAgICAgICAgaWYgKCFpc0VxdWFsRGVzY3JpcHRvcihwcmV2RGVzY3JpcHRvciwgc2F2ZWREZXNjcmlwdG9yKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZXh0Q29tcG9uZW50LCBrZXksIHByZXZEZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBuZXdseSBkZWZpbmVkIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTmV4dENvbXBvbmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoUkVTRVJWRURfU1RBVElDUy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2RGVzY3JpcHRvciA9IFByZXZpb3VzQ29tcG9uZW50ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUHJldmlvdXNDb21wb25lbnQsIGtleSk7XG4gICAgICB2YXIgc2F2ZWREZXNjcmlwdG9yID0gc2F2ZWREZXNjcmlwdG9yc1trZXldO1xuXG4gICAgICAvLyBTa2lwIHJlZGVmaW5lZCBkZXNjcmlwdG9yc1xuICAgICAgaWYgKHByZXZEZXNjcmlwdG9yICYmIHNhdmVkRGVzY3JpcHRvciAmJiAhaXNFcXVhbERlc2NyaXB0b3Ioc2F2ZWREZXNjcmlwdG9yLCBwcmV2RGVzY3JpcHRvcikpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5leHRDb21wb25lbnQsIGtleSwgcHJldkRlc2NyaXB0b3IpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJveHlDb21wb25lbnQsIGtleSwgcHJldkRlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2RGVzY3JpcHRvciAmJiAhc2F2ZWREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm94eUNvbXBvbmVudCwga2V5LCBwcmV2RGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHREZXNjcmlwdG9yID0gX2V4dGVuZHMoe30sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTmV4dENvbXBvbmVudCwga2V5KSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc2F2ZWREZXNjcmlwdG9yc1trZXldID0gbmV4dERlc2NyaXB0b3I7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJveHlDb21wb25lbnQsIGtleSwgbmV4dERlc2NyaXB0b3IpO1xuICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWZpbmVkXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoUHJveHlDb21wb25lbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKFJFU0VSVkVEX1NUQVRJQ1MuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU2tpcCBzdGF0aWNzIHRoYXQgZXhpc3Qgb24gdGhlIG5leHQgY2xhc3NcbiAgICAgIGlmIChOZXh0Q29tcG9uZW50Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU2tpcCBub24tY29uZmlndXJhYmxlIHN0YXRpY3NcbiAgICAgIHZhciBwcm94eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFByb3h5Q29tcG9uZW50LCBrZXkpO1xuICAgICAgaWYgKHByb3h5RGVzY3JpcHRvciAmJiAhcHJveHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2RGVzY3JpcHRvciA9IFByZXZpb3VzQ29tcG9uZW50ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUHJldmlvdXNDb21wb25lbnQsIGtleSk7XG4gICAgICB2YXIgc2F2ZWREZXNjcmlwdG9yID0gc2F2ZWREZXNjcmlwdG9yc1trZXldO1xuXG4gICAgICAvLyBTa2lwIHJlZGVmaW5lZCBkZXNjcmlwdG9yc1xuICAgICAgaWYgKHByZXZEZXNjcmlwdG9yICYmIHNhdmVkRGVzY3JpcHRvciAmJiAhaXNFcXVhbERlc2NyaXB0b3Ioc2F2ZWREZXNjcmlwdG9yLCBwcmV2RGVzY3JpcHRvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgUHJveHlDb21wb25lbnRba2V5XTtcbiAgICB9KTtcblxuICAgIGlmIChwcm90b3R5cGVQcm94eSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm90b3R5cGUgcHJveHkgd2l0aCBuZXcgbWV0aG9kc1xuICAgICAgdmFyIG1vdW50ZWRJbnN0YW5jZXMgPSBwcm90b3R5cGVQcm94eS51cGRhdGUoTmV4dENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG4gICAgICAvLyBTZXQgdXAgdGhlIGNvbnN0cnVjdG9yIHByb3BlcnR5IHNvIGFjY2Vzc2luZyB0aGUgc3RhdGljcyB3b3JrXG4gICAgICBQcm94eUNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXh0Q29tcG9uZW50O1xuXG4gICAgICAvLyBXZSBtaWdodCBoYXZlIGFkZGVkIG5ldyBtZXRob2RzIHRoYXQgbmVlZCB0byBiZSBhdXRvLWJvdW5kXG4gICAgICBtb3VudGVkSW5zdGFuY2VzLmZvckVhY2goX2JpbmRBdXRvQmluZE1ldGhvZHMyLmRlZmF1bHQpO1xuICAgICAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKF9kZWxldGVVbmtub3duQXV0b0JpbmRNZXRob2RzMi5kZWZhdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBQcm94eUNvbXBvbmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIEN1cnJlbnRDb21wb25lbnQ7XG4gIH1cblxuICB1cGRhdGUoSW5pdGlhbENvbXBvbmVudCk7XG5cbiAgdmFyIHByb3h5ID0geyBnZXQ6IGdldCwgdXBkYXRlOiB1cGRhdGUgfTtcbiAgYWRkUHJveHkoUHJveHlDb21wb25lbnQsIHByb3h5KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICdfX2dldEN1cnJlbnQnLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGdldEN1cnJlbnRcbiAgfSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWxsYmFjayhDb21wb25lbnQpIHtcbiAgdmFyIEN1cnJlbnRDb21wb25lbnQgPSBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBDdXJyZW50Q29tcG9uZW50O1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoTmV4dENvbXBvbmVudCkge1xuICAgICAgQ3VycmVudENvbXBvbmVudCA9IE5leHRDb21wb25lbnQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc1Byb3h5KENvbXBvbmVudCkge1xuICByZXR1cm4gQ29tcG9uZW50Ll9fcHJvdG9fXyAmJiAoMCwgX3N1cHBvcnRzUHJvdG9Bc3NpZ25tZW50Mi5kZWZhdWx0KSgpID8gcHJveHlDbGFzcyhDb21wb25lbnQpIDogY3JlYXRlRmFsbGJhY2soQ29tcG9uZW50KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcHJveHkvbW9kdWxlcy9jcmVhdGVDbGFzc1Byb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yZWFjdC1wcm94eS9tb2R1bGVzL2NyZWF0ZUNsYXNzUHJveHkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTg5NSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9maW5kLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVByb3RvdHlwZVByb3h5O1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2xvZGFzaC9hc3NpZ24nKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxudmFyIF9kaWZmZXJlbmNlID0gcmVxdWlyZSgnbG9kYXNoL2RpZmZlcmVuY2UnKTtcblxudmFyIF9kaWZmZXJlbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RpZmZlcmVuY2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVQcm90b3R5cGVQcm94eSgpIHtcbiAgdmFyIHByb3h5ID0ge307XG4gIHZhciBjdXJyZW50ID0gbnVsbDtcbiAgdmFyIG1vdW50ZWRJbnN0YW5jZXMgPSBbXTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHByb3hpZWQgdG9TdHJpbmcoKSBtZXRob2QgcG9pbnRpbmcgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbidzIHRvU3RyaW5nKCkuXG4gICAqL1xuICBmdW5jdGlvbiBwcm94eVRvU3RyaW5nKG5hbWUpIHtcbiAgICAvLyBXcmFwIHRvIGFsd2F5cyBjYWxsIHRoZSBjdXJyZW50IHZlcnNpb25cbiAgICByZXR1cm4gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRbbmFtZV0udG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnPG1ldGhvZCB3YXMgZGVsZXRlZD4nO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHByb3hpZWQgbWV0aG9kIHRoYXQgY2FsbHMgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2hlbmV2ZXIgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gcHJveHlNZXRob2QobmFtZSkge1xuICAgIC8vIFdyYXAgdG8gYWx3YXlzIGNhbGwgdGhlIGN1cnJlbnQgdmVyc2lvblxuICAgIHZhciBwcm94aWVkTWV0aG9kID0gZnVuY3Rpb24gcHJveGllZE1ldGhvZCgpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3VycmVudFtuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDb3B5IHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLCBpZiBhbnlcbiAgICAoMCwgX2Fzc2lnbjIuZGVmYXVsdCkocHJveGllZE1ldGhvZCwgY3VycmVudFtuYW1lXSk7XG4gICAgcHJveGllZE1ldGhvZC50b1N0cmluZyA9IHByb3h5VG9TdHJpbmcobmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94aWVkTWV0aG9kLCAnbmFtZScsIHtcbiAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIHJldHVybiBwcm94aWVkTWV0aG9kO1xuICB9XG5cbiAgLyoqXG4gICAqIEF1Z21lbnRzIHRoZSBvcmlnaW5hbCBjb21wb25lbnREaWRNb3VudCB3aXRoIGluc3RhbmNlIHRyYWNraW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcHJveGllZENvbXBvbmVudERpZE1vdW50KCkge1xuICAgIG1vdW50ZWRJbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjdXJyZW50LmNvbXBvbmVudERpZE1vdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIHByb3hpZWRDb21wb25lbnREaWRNb3VudC50b1N0cmluZyA9IHByb3h5VG9TdHJpbmcoJ2NvbXBvbmVudERpZE1vdW50Jyk7XG5cbiAgLyoqXG4gICAqIEF1Z21lbnRzIHRoZSBvcmlnaW5hbCBjb21wb25lbnRXaWxsVW5tb3VudCB3aXRoIGluc3RhbmNlIHRyYWNraW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcHJveGllZENvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciBpbmRleCA9IG1vdW50ZWRJbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgICAvLyBVbmxlc3Mgd2UncmUgaW4gYSB3ZWlyZCBlbnZpcm9ubWVudCB3aXRob3V0IGNvbXBvbmVudERpZE1vdW50XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbW91bnRlZEluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN1cnJlbnQuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjdXJyZW50LmNvbXBvbmVudFdpbGxVbm1vdW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIHByb3hpZWRDb21wb25lbnRXaWxsVW5tb3VudC50b1N0cmluZyA9IHByb3h5VG9TdHJpbmcoJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBwcm9wZXJ0eSBvbiB0aGUgcHJveHkuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVQcm94eVByb3BlcnR5KG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksIG5hbWUsIGRlc2NyaXB0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBwcm9wZXJ0eSwgYXR0ZW1wdGluZyB0byBrZWVwIHRoZSBvcmlnaW5hbCBkZXNjcmlwdG9yIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVQcm94eVByb3BlcnR5V2l0aFZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF9yZWYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnQsIG5hbWUpIHx8IHt9O1xuXG4gICAgdmFyIF9yZWYkZW51bWVyYWJsZSA9IF9yZWYuZW51bWVyYWJsZTtcbiAgICB2YXIgZW51bWVyYWJsZSA9IF9yZWYkZW51bWVyYWJsZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGVudW1lcmFibGU7XG4gICAgdmFyIF9yZWYkd3JpdGFibGUgPSBfcmVmLndyaXRhYmxlO1xuICAgIHZhciB3cml0YWJsZSA9IF9yZWYkd3JpdGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJHdyaXRhYmxlO1xuXG5cbiAgICBkZWZpbmVQcm94eVByb3BlcnR5KG5hbWUsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUsXG4gICAgICB3cml0YWJsZTogd3JpdGFibGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGF1dG8tYmluZCBtYXAgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBtYXAsIGJ1dCBkaXJlY3RlZCBhdCBwcm94eS5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUF1dG9CaW5kTWFwKCkge1xuICAgIGlmICghY3VycmVudC5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX19yZWFjdEF1dG9CaW5kTWFwID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBjdXJyZW50Ll9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm94eVtuYW1lXSA9PT0gJ2Z1bmN0aW9uJyAmJiBjdXJyZW50Ll9fcmVhY3RBdXRvQmluZE1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBfX3JlYWN0QXV0b0JpbmRNYXBbbmFtZV0gPSBwcm94eVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX19yZWFjdEF1dG9CaW5kTWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXV0by1iaW5kIG1hcCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG1hcCwgYnV0IGRpcmVjdGVkIGF0IHByb3h5LlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQXV0b0JpbmRQYWlycygpIHtcbiAgICB2YXIgX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIG5hbWUgPSBjdXJyZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzW2ldO1xuICAgICAgdmFyIG1ldGhvZCA9IHByb3h5W25hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfX3JlYWN0QXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIG1ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fcmVhY3RBdXRvQmluZFBhaXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHVwZGF0ZWQgcHJvdG90eXBlLlxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlKG5leHQpIHtcbiAgICAvLyBTYXZlIGN1cnJlbnQgc291cmNlIG9mIHRydXRoXG4gICAgY3VycmVudCA9IG5leHQ7XG5cbiAgICAvLyBGaW5kIGNoYW5nZWQgcHJvcGVydHkgbmFtZXNcbiAgICB2YXIgY3VycmVudE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudCk7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3h5KTtcbiAgICB2YXIgcmVtb3ZlZE5hbWVzID0gKDAsIF9kaWZmZXJlbmNlMi5kZWZhdWx0KShwcmV2aW91c05hbWUsIGN1cnJlbnROYW1lcyk7XG5cbiAgICAvLyBSZW1vdmUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IGFyZSBubyBsb25nZXIgdGhlcmVcbiAgICByZW1vdmVkTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgZGVsZXRlIHByb3h5W25hbWVdO1xuICAgIH0pO1xuXG4gICAgLy8gQ29weSBldmVyeSBkZXNjcmlwdG9yXG4gICAgY3VycmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdXJyZW50LCBuYW1lKTtcbiAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGdW5jdGlvbnMgcmVxdWlyZSBhZGRpdGlvbmFsIHdyYXBwaW5nIHNvIHRoZXkgY2FuIGJlIGJvdW5kIGxhdGVyXG4gICAgICAgIGRlZmluZVByb3h5UHJvcGVydHlXaXRoVmFsdWUobmFtZSwgcHJveHlNZXRob2QobmFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXIgdmFsdWVzIGNhbiBiZSBjb3BpZWQgZGlyZWN0bHlcbiAgICAgICAgZGVmaW5lUHJveHlQcm9wZXJ0eShuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRyYWNrIG1vdW50aW5nIGFuZCB1bm1vdW50aW5nXG4gICAgZGVmaW5lUHJveHlQcm9wZXJ0eVdpdGhWYWx1ZSgnY29tcG9uZW50RGlkTW91bnQnLCBwcm94aWVkQ29tcG9uZW50RGlkTW91bnQpO1xuICAgIGRlZmluZVByb3h5UHJvcGVydHlXaXRoVmFsdWUoJ2NvbXBvbmVudFdpbGxVbm1vdW50JywgcHJveGllZENvbXBvbmVudFdpbGxVbm1vdW50KTtcblxuICAgIGlmIChjdXJyZW50Lmhhc093blByb3BlcnR5KCdfX3JlYWN0QXV0b0JpbmRNYXAnKSkge1xuICAgICAgZGVmaW5lUHJveHlQcm9wZXJ0eVdpdGhWYWx1ZSgnX19yZWFjdEF1dG9CaW5kTWFwJywgY3JlYXRlQXV0b0JpbmRNYXAoKSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQuaGFzT3duUHJvcGVydHkoJ19fcmVhY3RBdXRvQmluZFBhaXJzJykpIHtcbiAgICAgIGRlZmluZVByb3h5UHJvcGVydHlXaXRoVmFsdWUoJ19fcmVhY3RBdXRvQmluZFBhaXJzJywgY3JlYXRlQXV0b0JpbmRQYWlycygpKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpblxuICAgIHByb3h5Ll9fcHJvdG9fXyA9IG5leHQ7XG5cbiAgICByZXR1cm4gbW91bnRlZEluc3RhbmNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1cC10by1kYXRlIHByb3h5IHByb3RvdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIGdldDogZ2V0XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFjdC1wcm94eS9tb2R1bGVzL2NyZWF0ZVByb3RvdHlwZVByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yZWFjdC1wcm94eS9tb2R1bGVzL2NyZWF0ZVByb3RvdHlwZVByb3h5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDIxMDYpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXNzaWduLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE1NjUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvZGlmZmVyZW5jZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBiaW5kQXV0b0JpbmRNZXRob2RzO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgUmVhY3Qgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIE9yaWdpbmFsOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvNjUwOGIxYWQyNzNhNmYzNzFlOGQ5MGFlNjc2ZTUzOTAxOTk0NjFiNC9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2NsYXNzL1JlYWN0Q2xhc3MuanMjTDY1MC1MNzEzXG4gKi9cblxuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG5cbiAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lLFxuICAgICAgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuXG4gIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAnICsgY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybignYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAnICsgY29tcG9uZW50TmFtZSk7XG4gICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgfVxuXG4gICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuXG4gICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gIH07XG5cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzRnJvbU1hcChjb21wb25lbnQpIHtcbiAgZm9yICh2YXIgYXV0b0JpbmRLZXkgaW4gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgIGlmICghY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcC5oYXNPd25Qcm9wZXJ0eShhdXRvQmluZEtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUd2Vhazogc2tpcCBtZXRob2RzIHRoYXQgYXJlIGFscmVhZHkgYm91bmQuXG4gICAgLy8gVGhpcyBpcyB0byBwcmVzZXJ2ZSBtZXRob2QgcmVmZXJlbmNlIGluIGNhc2UgaXQgaXMgdXNlZFxuICAgIC8vIGFzIGEgc3Vic2NyaXB0aW9uIGhhbmRsZXIgdGhhdCBuZWVkcyB0byBiZSBkZXRhY2hlZCBsYXRlci5cbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KGF1dG9CaW5kS2V5KSAmJiBjb21wb25lbnRbYXV0b0JpbmRLZXldLl9fcmVhY3RCb3VuZENvbnRleHQgPT09IGNvbXBvbmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1ldGhvZCA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXBbYXV0b0JpbmRLZXldO1xuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnMpIHtcbiAgICBiaW5kQXV0b0JpbmRNZXRob2RzRnJvbUFycmF5KGNvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgIGJpbmRBdXRvQmluZE1ldGhvZHNGcm9tTWFwKGNvbXBvbmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kc0Zyb21BcnJheShjb21wb25lbnQpIHtcbiAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gIGlmICghcGFpcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG5cbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KGF1dG9CaW5kS2V5KSAmJiBjb21wb25lbnRbYXV0b0JpbmRLZXldLl9fcmVhY3RCb3VuZENvbnRleHQgPT09IGNvbXBvbmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcblxuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LXByb3h5L21vZHVsZXMvYmluZEF1dG9CaW5kTWV0aG9kcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmVhY3QtcHJveHkvbW9kdWxlcy9iaW5kQXV0b0JpbmRNZXRob2RzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlbGV0ZVVua25vd25BdXRvQmluZE1ldGhvZHM7XG5mdW5jdGlvbiBzaG91bGREZWxldGVDbGFzc2ljSW5zdGFuY2VNZXRob2QoY29tcG9uZW50LCBuYW1lKSB7XG4gIGlmIChjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwICYmIGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAvLyBJdCdzIGEga25vd24gYXV0b2JvdW5kIGZ1bmN0aW9uLCBrZWVwIGl0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycyAmJiBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgLy8gSXQncyBhIGtub3duIGF1dG9ib3VuZCBmdW5jdGlvbiwga2VlcCBpdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRbbmFtZV0uX19yZWFjdEJvdW5kQXJndW1lbnRzICE9PSBudWxsKSB7XG4gICAgLy8gSXQncyBhIGZ1bmN0aW9uIGJvdW5kIHRvIHNwZWNpZmljIGFyZ3MsIGtlZXAgaXRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJdCdzIGEgY2FjaGVkIGJvdW5kIG1ldGhvZCBmb3IgYSBmdW5jdGlvblxuICAvLyB0aGF0IHdhcyBkZWxldGVkIGJ5IHVzZXIsIHNvIHdlIGRlbGV0ZSBpdCBmcm9tIGNvbXBvbmVudC5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNob3VsZERlbGV0ZU1vZGVybkluc3RhbmNlTWV0aG9kKGNvbXBvbmVudCwgbmFtZSkge1xuICB2YXIgcHJvdG90eXBlID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICB2YXIgcHJvdG90eXBlRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBuYW1lKTtcblxuICBpZiAoIXByb3RvdHlwZURlc2NyaXB0b3IgfHwgIXByb3RvdHlwZURlc2NyaXB0b3IuZ2V0KSB7XG4gICAgLy8gVGhpcyBpcyBkZWZpbml0ZWx5IG5vdCBhbiBhdXRvYmluZGluZyBnZXR0ZXJcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvdG90eXBlRGVzY3JpcHRvci5nZXQoKS5sZW5ndGggIT09IGNvbXBvbmVudFtuYW1lXS5sZW5ndGgpIHtcbiAgICAvLyBUaGUgbGVuZ3RoIGRvZXNuJ3QgbWF0Y2gsIGJhaWwgb3V0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGhpcyBzZWVtcyBsaWtlIGEgbWV0aG9kIGJvdW5kIHVzaW5nIGFuIGF1dG9iaW5kaW5nIGdldHRlciBvbiB0aGUgcHJvdG90eXBlXG4gIC8vIEhvcGVmdWxseSB3ZSB3b24ndCBydW4gaW50byB0b28gbWFueSBmYWxzZSBwb3NpdGl2ZXMuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzaG91bGREZWxldGVJbnN0YW5jZU1ldGhvZChjb21wb25lbnQsIG5hbWUpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbXBvbmVudCwgbmFtZSk7XG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIE5vdCBhIGZ1bmN0aW9uLCBvciBzb21ldGhpbmcgZmFuY3k6IGJhaWwgb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXAgfHwgY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzKSB7XG4gICAgLy8gQ2xhc3NpY1xuICAgIHJldHVybiBzaG91bGREZWxldGVDbGFzc2ljSW5zdGFuY2VNZXRob2QoY29tcG9uZW50LCBuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNb2Rlcm5cbiAgICByZXR1cm4gc2hvdWxkRGVsZXRlTW9kZXJuSW5zdGFuY2VNZXRob2QoY29tcG9uZW50LCBuYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZXMgYXV0b2JvdW5kIG1ldGhvZHMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gKlxuICogRm9yIGNsYXNzaWMgUmVhY3QgY2xhc3Nlcywgd2Ugb25seSBkZWxldGUgdGhlIG1ldGhvZHMgdGhhdCBubyBsb25nZXIgZXhpc3QgaW4gbWFwLlxuICogVGhpcyBtZWFucyB0aGUgdXNlciBhY3R1YWxseSBkZWxldGVkIHRoZW0gaW4gY29kZS5cbiAqXG4gKiBGb3IgbW9kZXJuIGNsYXNzZXMsIHdlIGRlbGV0ZSBtZXRob2RzIHRoYXQgZXhpc3Qgb24gcHJvdG90eXBlIHdpdGggdGhlIHNhbWUgbGVuZ3RoLFxuICogYW5kIHdoaWNoIGhhdmUgZ2V0dGVycyBvbiBwcm90b3R5cGUsIGJ1dCBhcmUgbm9ybWFsIHZhbHVlcyBvbiB0aGUgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIHVzdWFsbHkgYW4gaW5kaWNhdGlvbiB0aGF0IGFuIGF1dG9iaW5kaW5nIGRlY29yYXRvciBpcyBiZWluZyB1c2VkLFxuICogYW5kIHRoZSBnZXR0ZXIgd2lsbCByZS1nZW5lcmF0ZSB0aGUgbWVtb2l6ZWQgaGFuZGxlciBvbiBuZXh0IGFjY2Vzcy5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlVW5rbm93bkF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29tcG9uZW50KTtcblxuICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHNob3VsZERlbGV0ZUluc3RhbmNlTWV0aG9kKGNvbXBvbmVudCwgbmFtZSkpIHtcbiAgICAgIGRlbGV0ZSBjb21wb25lbnRbbmFtZV07XG4gICAgfVxuICB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhY3QtcHJveHkvbW9kdWxlcy9kZWxldGVVbmtub3duQXV0b0JpbmRNZXRob2RzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yZWFjdC1wcm94eS9tb2R1bGVzL2RlbGV0ZVVua25vd25BdXRvQmluZE1ldGhvZHMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsb2JhbC93aW5kb3cuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibnVsbFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/aHR0cDovbG9jYWxob3N0OjQwMDAiLCJ2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKSB7XG5cdC8vIGBkb2N1bWVudC5jdXJyZW50U2NyaXB0YCBpcyB0aGUgbW9zdCBhY2N1cmF0ZSB3YXkgdG8gZmluZCB0aGUgY3VycmVudCBzY3JpcHQsXG5cdC8vIGJ1dCBpcyBub3Qgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vycy5cblx0aWYoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG5cdC8vIEZhbGwgYmFjayB0byBnZXR0aW5nIGFsbCBzY3JpcHRzIGluIHRoZSBkb2N1bWVudC5cblx0dmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcblx0dmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcblx0aWYoY3VycmVudFNjcmlwdClcblx0XHRyZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG5cdC8vIEZhaWwgYXMgdGhlcmUgd2FzIG5vIHNjcmlwdCB0byB1c2UuXG5cdHRocm93IG5ldyBFcnJvcihcIltXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlXCIpO1xufVxuXG52YXIgdXJsUGFydHM7XG5pZih0eXBlb2YgX19yZXNvdXJjZVF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIF9fcmVzb3VyY2VRdWVyeSkge1xuXHQvLyBJZiB0aGlzIGJ1bmRsZSBpcyBpbmxpbmVkLCB1c2UgdGhlIHJlc291cmNlIHF1ZXJ5IHRvIGdldCB0aGUgY29ycmVjdCB1cmwuXG5cdHVybFBhcnRzID0gdXJsLnBhcnNlKF9fcmVzb3VyY2VRdWVyeS5zdWJzdHIoMSkpO1xufSBlbHNlIHtcblx0Ly8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cblx0dmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7XG5cdHNjcmlwdEhvc3QgPSBzY3JpcHRIb3N0LnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCJcIik7XG5cdHVybFBhcnRzID0gdXJsLnBhcnNlKChzY3JpcHRIb3N0ID8gc2NyaXB0SG9zdCA6IFwiL1wiKSwgZmFsc2UsIHRydWUpO1xufVxuXG52YXIgaG90ID0gZmFsc2U7XG52YXIgaW5pdGlhbCA9IHRydWU7XG52YXIgY3VycmVudEhhc2ggPSBcIlwiO1xudmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIGxvZyhsZXZlbCwgbXNnKSB7XG5cdGlmKGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIpXG5cdFx0cmV0dXJuIGNvbnNvbGUubG9nKG1zZyk7XG5cdGlmKFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKVxuXHRcdHJldHVybiBjb25zb2xlLndhcm4obXNnKTtcblx0aWYoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpXG5cdFx0cmV0dXJuIGNvbnNvbGUuZXJyb3IobXNnKTtcbn1cblxudmFyIG9uU29ja2V0TXNnID0ge1xuXHRob3Q6IGZ1bmN0aW9uKCkge1xuXHRcdGhvdCA9IHRydWU7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC5cIik7XG5cdH0sXG5cdGludmFsaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGxvZyhcImluZm9cIiwgXCJbV0RTXSBBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi5cIik7XG5cdH0sXG5cdGhhc2g6IGZ1bmN0aW9uKGhhc2gpIHtcblx0XHRjdXJyZW50SGFzaCA9IGhhc2g7XG5cdH0sXG5cdFwic3RpbGwtb2tcIjogZnVuY3Rpb24oKSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIE5vdGhpbmcgY2hhbmdlZC5cIilcblx0fSxcblx0XCJsb2ctbGV2ZWxcIjogZnVuY3Rpb24obGV2ZWwpIHtcblx0XHRsb2dMZXZlbCA9IGxldmVsO1xuXHR9LFxuXHRvazogZnVuY3Rpb24oKSB7XG5cdFx0aWYoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTtcblx0XHRyZWxvYWRBcHAoKTtcblx0fSxcblx0d2FybmluZ3M6IGZ1bmN0aW9uKHdhcm5pbmdzKSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIFdhcm5pbmdzIHdoaWxlIGNvbXBpbGluZy5cIik7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHdhcm5pbmdzLmxlbmd0aDsgaSsrKVxuXHRcdFx0Y29uc29sZS53YXJuKHN0cmlwQW5zaSh3YXJuaW5nc1tpXSkpO1xuXHRcdGlmKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7XG5cdFx0cmVsb2FkQXBwKCk7XG5cdH0sXG5cdGVycm9yczogZnVuY3Rpb24oZXJyb3JzKSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuXCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspXG5cdFx0XHRjb25zb2xlLmVycm9yKHN0cmlwQW5zaShlcnJvcnNbaV0pKTtcblx0XHRpZihpbml0aWFsKSByZXR1cm4gaW5pdGlhbCA9IGZhbHNlO1xuXHRcdHJlbG9hZEFwcCgpO1xuXHR9LFxuXHRcInByb3h5LWVycm9yXCI6IGZ1bmN0aW9uKGVycm9ycykge1xuXHRcdGxvZyhcImluZm9cIiwgXCJbV0RTXSBQcm94eSBlcnJvci5cIik7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKylcblx0XHRcdGxvZyhcImVycm9yXCIsIHN0cmlwQW5zaShlcnJvcnNbaV0pKTtcblx0XHRpZihpbml0aWFsKSByZXR1cm4gaW5pdGlhbCA9IGZhbHNlO1xuXHR9LFxuXHRjbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0bG9nKFwiZXJyb3JcIiwgXCJbV0RTXSBEaXNjb25uZWN0ZWQhXCIpO1xuXHR9XG59O1xuXG52YXIgaG9zdG5hbWUgPSB1cmxQYXJ0cy5ob3N0bmFtZTtcbnZhciBwcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sO1xuXG5pZih1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSB7XG5cdC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG5cdC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG5cdC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG5cdGlmKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSAmJiAhIX53aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpKSB7XG5cdFx0aG9zdG5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG5cdH1cbn1cblxuLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuLy8gYSBwcm90b2NvbCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZCBVUkwuXG4vLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3Nhcnlcbi8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuaWYoaG9zdG5hbWUgJiYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuXHRwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbn1cblxudmFyIHNvY2tldFVybCA9IHVybC5mb3JtYXQoe1xuXHRwcm90b2NvbDogcHJvdG9jb2wsXG5cdGF1dGg6IHVybFBhcnRzLmF1dGgsXG5cdGhvc3RuYW1lOiBob3N0bmFtZSxcblx0cG9ydDogKHVybFBhcnRzLnBvcnQgPT09ICcwJykgPyB3aW5kb3cubG9jYXRpb24ucG9ydCA6IHVybFBhcnRzLnBvcnQsXG5cdHBhdGhuYW1lOiB1cmxQYXJ0cy5wYXRoID09IG51bGwgfHwgdXJsUGFydHMucGF0aCA9PT0gJy8nID8gXCIvc29ja2pzLW5vZGVcIiA6IHVybFBhcnRzLnBhdGhcbn0pO1xuXG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1zZyk7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcCgpIHtcblx0aWYoaG90KSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIEFwcCBob3QgdXBkYXRlLi4uXCIpO1xuXHRcdHdpbmRvdy5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIiArIGN1cnJlbnRIYXNoLCBcIipcIik7XG5cdH0gZWxzZSB7XG5cdFx0bG9nKFwiaW5mb1wiLCBcIltXRFNdIEFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi5cIik7XG5cdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuXHR9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/aHR0cDovL2xvY2FsaG9zdDo0MDAwXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2luZGV4LmpzP2h0dHA6L2xvY2FsaG9zdDo0MDAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VybC91cmwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3VybC91cmwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdXJsL34vcHVueWNvZGUvcHVueWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnlzdHJpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9xdWVyeXN0cmluZy9kZWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nL2VuY29kZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHJpcC1hbnNpL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtT1JaY2YtbnFyeT0+PF0vZztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5zaS1yZWdleC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU29ja0pTID0gcmVxdWlyZShcInNvY2tqcy1jbGllbnRcIik7XG5cbnZhciByZXRyaWVzID0gMDtcbnZhciBzb2NrID0gbnVsbDtcblxuZnVuY3Rpb24gc29ja2V0KHVybCwgaGFuZGxlcnMpIHtcblx0c29jayA9IG5ldyBTb2NrSlModXJsKTtcblxuXHRzb2NrLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHJpZXMgPSAwO1xuXHR9XG5cblx0c29jay5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYocmV0cmllcyA9PT0gMClcblx0XHRcdGhhbmRsZXJzLmNsb3NlKCk7XG5cblx0XHQvLyBUcnkgdG8gcmVjb25uZWN0LlxuXHRcdHNvY2sgPSBudWxsO1xuXG5cdFx0Ly8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuXHRcdGlmKHJldHJpZXMgPD0gMTApIHtcblx0XHRcdC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG5cdFx0XHQvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG5cdFx0XHR2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcblx0XHRcdHJldHJpZXMgKz0gMTtcblxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c29ja2V0KHVybCwgaGFuZGxlcnMpO1xuXHRcdFx0fSwgcmV0cnlJbk1zKTtcblx0XHR9XG5cdH07XG5cblx0c29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG5cdFx0Ly8gVGhpcyBhc3N1bWVzIHRoYXQgYWxsIGRhdGEgc2VudCB2aWEgdGhlIHdlYnNvY2tldCBpcyBKU09OLlxuXHRcdHZhciBtc2cgPSBKU09OLnBhcnNlKGUuZGF0YSk7XG5cdFx0aWYoaGFuZGxlcnNbbXNnLnR5cGVdKVxuXHRcdFx0aGFuZGxlcnNbbXNnLnR5cGVdKG1zZy5kYXRhKTtcblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb2NrZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9lbnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvZW50cnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQtbGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0LWxpc3QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIFdlYnNvY2tldERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3dlYnNvY2tldCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsLCBpZ25vcmUsIG9wdGlvbnMpIHtcbiAgaWYgKCFXZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XG4gIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICB1cmwgPSAnd3NzJyArIHVybC5zbGljZSg1KTtcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICB9XG4gIHRoaXMudXJsID0gdXJsO1xuXG4gIHRoaXMud3MgPSBuZXcgV2Vic29ja2V0RHJpdmVyKHRoaXMudXJsLCBbXSwgb3B0aW9ucyk7XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlIGV2ZW50JywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICB9O1xuICAvLyBGaXJlZm94IGhhcyBhbiBpbnRlcmVzdGluZyBidWcuIElmIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgLy8gY3JlYXRlZCBhZnRlciBvbnVubG9hZCwgaXQgc3RheXMgYWxpdmUgZXZlbiB3aGVuIHVzZXJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgLy8gbGV0J3Mgbm90IG9wZW4gdGhlIHdzIGNvbm5lY3Rpb24gYXQgYWxsLiBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NranMvc29ja2pzLWNsaWVudC9pc3N1ZXMvMjhcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQnKTtcbiAgICBzZWxmLndzLmNsb3NlKCk7XG4gIH0pO1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvciBldmVudCcsIGUpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xufVxuXG5pbmhlcml0cyhXZWJTb2NrZXRUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG1zZyA9ICdbJyArIGRhdGEgKyAnXSc7XG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcbiAgdGhpcy53cy5zZW5kKG1zZyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICBpZiAodGhpcy53cykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC93ZWJzb2NrZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC93ZWJzb2NrZXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi91dGlscy9ldmVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBjcnlwdG86dHJ1ZSAqL1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyBUaGlzIHN0cmluZyBoYXMgbGVuZ3RoIDMyLCBhIHBvd2VyIG9mIDIsIHNvIHRoZSBtb2R1bHVzIGRvZXNuJ3QgaW50cm9kdWNlIGFcbi8vIGJpYXMuXG52YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmc6IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBtYXggPSBfcmFuZG9tU3RyaW5nQ2hhcnMubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGgpO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXQucHVzaChfcmFuZG9tU3RyaW5nQ2hhcnMuc3Vic3RyKGJ5dGVzW2ldICUgbWF4LCAxKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG4gIH1cblxuLCBudW1iZXI6IGZ1bmN0aW9uKG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuICB9XG5cbiwgbnVtYmVyU3RyaW5nOiBmdW5jdGlvbihtYXgpIHtcbiAgICB2YXIgdCA9ICgnJyArIChtYXggLSAxKSkubGVuZ3RoO1xuICAgIHZhciBwID0gbmV3IEFycmF5KHQgKyAxKS5qb2luKCcwJyk7XG4gICAgcmV0dXJuIChwICsgdGhpcy5udW1iZXIobWF4KSkuc2xpY2UoLXQpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3JhbmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdXRpbHMvcmFuZG9tLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2Jyb3dzZXItY3J5cHRvLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi91dGlscy9icm93c2VyLWNyeXB0by5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy91cmwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3VybC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIGxvbGNhdGlvbiA9IHJlcXVpcmUoJy4vbG9sY2F0aW9uJylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBuZXcgVVJMKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbMl0gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblVSTC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgICB1cmwucGF0aG5hbWUgPSB2YWx1ZS5sZW5ndGggJiYgdmFsdWUuY2hhckF0KDApICE9PSAnLycgPyAnLycgKyB2YWx1ZSA6IHZhbHVlO1xuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuVVJMLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVVJMLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVSTC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVSTC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91cmwtcGFyc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3VybC1wYXJzZS9pbmRleC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZXF1aXJlcy1wb3J0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yZXF1aXJlcy1wb3J0L2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9XG4gICwgVVJMO1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIFVSTCA9IFVSTCB8fCByZXF1aXJlKCcuLycpO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVVJMKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVVJMKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91cmwtcGFyc2UvbG9sY2F0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy91cmwtcGFyc2UvbG9sY2F0aW9uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgLy9cbiAgLy8gTGl0dGxlIG5pZnR5IHBhcnNpbmcgaGFjaywgbGV2ZXJhZ2UgdGhlIGZhY3QgdGhhdCBSZWdFeHAuZXhlYyBpbmNyZW1lbnRzXG4gIC8vIHRoZSBsYXN0SW5kZXggcHJvcGVydHkgc28gd2UgY2FuIGNvbnRpbnVlIGV4ZWN1dGluZyB0aGlzIGxvb3AgdW50aWwgd2UndmVcbiAgLy8gcGFyc2VkIGFsbCByZXN1bHRzLlxuICAvL1xuICBmb3IgKDtcbiAgICBwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpO1xuICAgIHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQocGFydFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRbMl0pXG4gICk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcXVlcnlzdHJpbmdpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5naWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZWJ1Zy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RlYnVnL2RlYnVnLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9lbWl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi9ldmVudC9lbWl0dGVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgLy8gIzRcbiAgaWYgKGFyci5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgYXJyID0gYXJyLmNvbmNhdChbbGlzdGVuZXJdKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpZHggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9ldmVudHRhcmdldC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvZXZlbnQvZXZlbnR0YXJnZXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJpdmVyID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuaWYgKERyaXZlcikge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBEcml2ZXIodXJsKTtcblx0fTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvYnJvd3Nlci93ZWJzb2NrZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9icm93c2VyL3dlYnNvY2tldC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpXG4gIDtcblxuZnVuY3Rpb24gWGhyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXG4gIGlmIChicm93c2VyLmlzT3BlcmEoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbi8vIFNhZmFyaSBnZXRzIGNvbmZ1c2VkIHdoZW4gYSBzdHJlYW1pbmcgYWpheCByZXF1ZXN0IGlzIHN0YXJ0ZWRcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbi8vIE9ubHkgcmVxdWlyZSBib2R5IHdoZW4gdXNlZCBpbiBhIGJyb3dzZXJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5uZWVkQm9keSA9ICEhZ2xvYmFsLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGhyLXN0cmVhbWluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9zZW5kZXItcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICB2YXIgb3B0ID0ge307XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XG4gICAgfVxuICAgIHZhciBhamF4VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh1cmwsICcveGhyX3NlbmQnKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XG4gICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwICYmIHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICB4by5jbG9zZSgpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIEFqYXhCYXNlZFRyYW5zcG9ydCh0cmFuc1VybCwgdXJsU3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEJhc2VkVHJhbnNwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9saWIvYWpheC1iYXNlZC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9hamF4LWJhc2VkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICAgIHRoaXMucG9sbCA9IG51bGw7XG4gIH1cbiAgdGhpcy5zdG9wKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9saWIvc2VuZGVyLXJlY2VpdmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL3NlbmRlci1yZWNlaXZlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3N0b3AnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAodGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFN0b3AoKTtcbiAgICB0aGlzLnNlbmRTdG9wID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNlbmRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2J1ZmZlcmVkLXNlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9idWZmZXJlZC1zZW5kZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpwb2xsaW5nJyk7XG59XG5cbmZ1bmN0aW9uIFBvbGxpbmcoUmVjZWl2ZXIsIHJlY2VpdmVVcmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcocmVjZWl2ZVVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLlJlY2VpdmVyID0gUmVjZWl2ZXI7XG4gIHRoaXMucmVjZWl2ZVVybCA9IHJlY2VpdmVVcmw7XG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gIHRoaXMuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbn1cblxuaW5oZXJpdHMoUG9sbGluZywgRXZlbnRFbWl0dGVyKTtcblxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY2hlZHVsZVJlY2VpdmVyJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XG5cbiAgcG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcblxuICBwb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ2Nsb3NlJywgY29kZSwgcmVhc29uLCBzZWxmLnBvbGxJc0Nsb3NpbmcpO1xuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xuXG4gICAgaWYgKCFzZWxmLnBvbGxJc0Nsb3NpbmcpIHtcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xuICAgICAgICBzZWxmLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xuICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5wb2xsSXNDbG9zaW5nID0gdHJ1ZTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2xpYi9wb2xsaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL3BvbGxpbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIveGhyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIveGhyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItY29ycy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItY29ycy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gJ3RydWUnO1xuICB9XG4gIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xuICAgICAgdmFyIHRleHQsIHN0YXR1cztcbiAgICAgIGRlYnVnKCdyZWFkeVN0YXRlJywgeC5yZWFkeVN0YXRlKTtcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwICYmIHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWcoJ2NodW5rJyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSByZXR1cm5zIHRoaXMgZm9yIGEgYmFkIHBvcnRcbiAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMDA1IHx8IHN0YXR1cyA9PT0gMTIwMjkpIHtcbiAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgc2VsZi54aHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgLy8gSUUgbmVlZHMgdGhpcyBmaWVsZCB0byBiZSBhIGZ1bmN0aW9uXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XG4gIGlmICh0aGlzLnhoci5vbnRpbWVvdXQpIHtcbiAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIVhIUjtcbi8vIG92ZXJyaWRlIFhNTEh0dHBSZXF1ZXN0IGZvciBJRTYvN1xuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoIUFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgJiYgKGF4byBpbiBnbG9iYWwpKSB7XG4gIGRlYnVnKCdvdmVycmlkaW5nIHhtbGh0dHByZXF1ZXN0Jyk7XG4gIFhIUiA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtheG9dKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xufVxuXG52YXIgY29ycyA9IGZhbHNlO1xudHJ5IHtcbiAgY29ycyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYSFIoKTtcbn0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxufVxuXG5BYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMgPSBjb3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9icm93c2VyL2Fic3RyYWN0LXhoci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvYWJzdHJhY3QteGhyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdXRpbHMvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbi8vIEFjY29yZGluZyB0bzpcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcbi8vICAgaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG5cbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5jb29raWVfbmVlZGVkIHx8IGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gWERST2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lU2NoZW1lO1xufTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXN0cmVhbWluZyc7XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGRyLXN0cmVhbWluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xufVxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG5cbmZ1bmN0aW9uIFhEUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhYRFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcoJ19zdGFydCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4ZHIgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gIC8vIElFIGNhY2hlcyBldmVuIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29udGltZW91dCcpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gIH07XG4gIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnbG9hZCcpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfTtcbiAgdGhpcy54ZHIgPSB4ZHI7XG4gIHRoaXMudW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICB0aGlzLnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLnhkci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdGhpcy5fZXJyb3IoKTtcbiAgfVxufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJywgYWJvcnQpO1xuICBpZiAoIXRoaXMueGRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhkciA9IG51bGw7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuWERST2JqZWN0LmVuYWJsZWQgPSAhIShnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgYnJvd3Nlci5oYXNEb21haW4oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9zZW5kZXIveGRyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL3hkci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9ldmVudHNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2V2ZW50c291cmNlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZXMgPSB0aGlzLmVzID0gbmV3IEV2ZW50U291cmNlRHJpdmVyKHVybCk7XG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGVjb2RlVVJJKGUuZGF0YSkpO1xuICB9O1xuICBlcy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvcicsIGVzLnJlYWR5U3RhdGUsIGUpO1xuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cbiAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgIHZhciByZWFzb24gPSAoZXMucmVhZHlTdGF0ZSAhPT0gMiA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UocmVhc29uKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIHZhciBlcyA9IHRoaXMuZXM7XG4gIGlmIChlcykge1xuICAgIGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgIGVzLmNsb3NlKCk7XG4gICAgdGhpcy5lcyA9IG51bGw7XG4gIH1cbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIFNhZmFyaSBhbmQgY2hyb21lIDwgMTUgY3Jhc2ggaWYgd2UgY2xvc2Ugd2luZG93IGJlZm9yZVxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0sIDIwMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlUmVjZWl2ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL2V2ZW50c291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIvZXZlbnRzb3VyY2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvZXZlbnRzb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9icm93c2VyL2V2ZW50c291cmNlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xuICAgIElmcmFtZVRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0cmFuc1VybCwgYmFzZVVybCk7XG4gIH1cblxuICBpbmhlcml0cyhJZnJhbWVXcmFwVHJhbnNwb3J0LCBJZnJhbWVUcmFuc3BvcnQpO1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlmcmFtZUluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoe30sIGluZm8pO1xuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRyYW5zcG9ydC5lbmFibGVkKGlmcmFtZUluZm8pICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG4gIH07XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS0nICsgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZmFjYWRlVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIHJldHVybiBJZnJhbWVXcmFwVHJhbnNwb3J0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXG4vLyB0aGVtIHdvcmsgY3Jvc3MtZG9tYWluIHdlIHNoYWxsIHVzZSBpZnJhbWUsIHNlcnZlZCBmcm9tIHRoZVxuLy8gcmVtb3RlIGRvbWFpbi4gTmV3IGJyb3dzZXJzIGhhdmUgY2FwYWJpbGl0aWVzIHRvIGNvbW11bmljYXRlIHdpdGhcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9pZnJhbWUnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnRyYW5zcG9ydDppZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSWZyYW1lVHJhbnNwb3J0KHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcbiAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgdGhpcy50cmFuc1VybCA9IHRyYW5zVXJsO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy53aW5kb3dJZCA9IHJhbmRvbS5zdHJpbmcoOCk7XG5cbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcbiAgZGVidWcodHJhbnNwb3J0LCB0cmFuc1VybCwgaWZyYW1lVXJsKTtcblxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcbiAgICBkZWJ1ZygnZXJyIGNhbGxiYWNrJyk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdVbmFibGUgdG8gbG9hZCBhbiBpZnJhbWUgKCcgKyByICsgJyknKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xuXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XG4gIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbn1cblxuaW5oZXJpdHMoSWZyYW1lVHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICBldmVudFV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKCdjJyk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGUub3JpZ2luLCB0aGlzLm9yaWdpbikpIHtcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICBjYXNlICdzJzpcbiAgICB0aGlzLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAvLyB3aW5kb3cgZ2xvYmFsIGRlcGVuZGVuY3lcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcbiAgICAgIHZlcnNpb25cbiAgICAsIHRoaXMudHJhbnNwb3J0XG4gICAgLCB0aGlzLnRyYW5zVXJsXG4gICAgLCB0aGlzLmJhc2VVcmxcbiAgICBdKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3QnOlxuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2MnOlxuICAgIHZhciBjZGF0YTtcbiAgICB0cnkge1xuICAgICAgY2RhdGEgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgZGVidWcoJ3Bvc3RNZXNzYWdlJywgdHlwZSwgZGF0YSk7XG4gIHRoaXMuaWZyYW1lT2JqLnBvc3QoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAsIHR5cGU6IHR5cGVcbiAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gIH0pLCB0aGlzLm9yaWdpbik7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcbklmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2lmcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2lmcmFtZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanNvbjMvbGliL2pzb24zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9qc29uMy9saWIvanNvbjMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAnMS4xLjEnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3ZlcnNpb24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3ZlcnNpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6aWZyYW1lJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXUHJlZml4OiAnX2pwJ1xuLCBjdXJyZW50V2luZG93SWQ6IG51bGxcblxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IHt9O1xuICAgIH1cbiAgfVxuXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKGdsb2JhbC5wYXJlbnQgIT09IGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OMy5zdHJpbmdpZnkoe1xuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXG4gICAgICAsIHR5cGU6IHR5cGVcbiAgICAgICwgZGF0YTogZGF0YSB8fCAnJ1xuICAgICAgfSksICcqJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdDYW5ub3QgcG9zdE1lc3NhZ2UsIG5vIHBhcmVudCB3aW5kb3cuJywgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAvLyB3aXRoaW4gaWZyYW1lLiBXaXRob3V0IHRoZSB0aW1lb3V0IGl0IGdvZXMgc3RyYWlnaHQgdG9cbiAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIGRlYnVnKCdwb3N0JywgbXNnLCBvcmlnaW4pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ29ubG9hZCcpO1xuICAgICAgLy8gYG9ubG9hZGAgaXMgdHJpZ2dlcmVkIGJlZm9yZSBzY3JpcHRzIG9uIHRoZSBpZnJhbWUgYXJlXG4gICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uZXJyb3IoJ29ubG9hZCB0aW1lb3V0Jyk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9O1xuICAgIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxuXG4vKiBqc2hpbnQgdW5kZWY6IGZhbHNlLCBuZXdjYXA6IGZhbHNlICovXG4vKiBlc2xpbnQgbm8tdW5kZWY6IDAsIG5ldy1jYXA6IDAgKi9cbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuICAgIHZhciBkb2MgPSBuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgaWZyYW1lO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBnbG9iYWwuZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgK1xuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgZG9jLnBhcmVudFdpbmRvd1ttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSBmYWxzZTtcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdvYmplY3QnKSAmJiAoIWJyb3dzZXIuaXNLb25xdWVyb3IoKSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvaWZyYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi91dGlscy9pZnJhbWUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL29iamVjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICA7XG5cbmZ1bmN0aW9uIEh0bWxGaWxlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5IdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcbn07XG5cbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xuSHRtbEZpbGVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2h0bWxmaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvaHRtbGZpbGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL2h0bWxmaWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIvaHRtbGZpbGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC94aHItcG9sbGluZy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3hoci1wb2xsaW5nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG5mdW5jdGlvbiBYZHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQveGRyLXBvbGxpbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC94ZHItcG9sbGluZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbWVzc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXG4gICwgSnNvbnBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvanNvbnAnKVxuICAsIGpzb25wU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXIvanNvbnAnKVxuICA7XG5cbmZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcbn1cblxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xuSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG5Kc29uUFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xufVxuXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdmFyIHVybFdpdGhJZCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1dGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NyZWF0ZVNjcmlwdCh1cmxXaXRoSWQpO1xuXG4gIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICB9LCBKc29ucFJlY2VpdmVyLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhKc29ucFJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0pTT05QIHVzZXIgYWJvcnRlZCByZWFkJyk7XG4gICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgIHRoaXMuX2Fib3J0KGVycik7XG4gIH1cbn07XG5cbkpzb25wUmVjZWl2ZXIudGltZW91dCA9IDM1MDAwO1xuSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQgPSAxMDAwO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuXG4gIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAnbmV0d29yaycpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuYWJvcnRpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICBpZiAodGhpcy5zY3JpcHQyKSB7XG4gICAgdGhpcy5zY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQyKTtcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgLy8gdGhlIHNjcmlwdC5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fc2NyaXB0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmVycm9yVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5sb2FkZWRPa2F5KSB7XG4gICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgfVxuICB9LCBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gIGRlYnVnKCdfY3JlYXRlU2NyaXB0JywgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICBzY3JpcHQuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gIHNjcmlwdC5vbmVycm9yID0gdGhpcy5fc2NyaXB0RXJyb3IuYmluZCh0aGlzKTtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgfTtcblxuICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2Ugb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICBzY3JpcHQyID0gdGhpcy5zY3JpcHQyID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICBpZiAoc2NyaXB0Mikge1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIvanNvbnAuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3RyYW5zcG9ydC9yZWNlaXZlci9qc29ucC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjpqc29ucCcpO1xufVxuXG52YXIgZm9ybSwgYXJlYTtcblxuZnVuY3Rpb24gY3JlYXRlSWZyYW1lKGlkKSB7XG4gIGRlYnVnKCdjcmVhdGVJZnJhbWUnLCBpZCk7XG4gIHRyeSB7XG4gICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgcmV0dXJuIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8aWZyYW1lIG5hbWU9XCInICsgaWQgKyAnXCI+Jyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5uYW1lID0gaWQ7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtKCkge1xuICBkZWJ1ZygnY3JlYXRlRm9ybScpO1xuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICBmb3JtLmFjY2VwdENoYXJzZXQgPSAnVVRGLTgnO1xuXG4gIGFyZWEgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgYXJlYS5uYW1lID0gJ2QnO1xuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcbiAgaWYgKCFmb3JtKSB7XG4gICAgY3JlYXRlRm9ybSgpO1xuICB9XG4gIHZhciBpZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIGZvcm0udGFyZ2V0ID0gaWQ7XG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xuXG4gIHZhciBpZnJhbWUgPSBjcmVhdGVJZnJhbWUoaWQpO1xuICBpZnJhbWUuaWQgPSBpZDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICB0cnkge1xuICAgIGFyZWEudmFsdWUgPSBwYXlsb2FkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc2VyaW91c2x5IGJyb2tlbiBicm93c2VycyBnZXQgaGVyZVxuICB9XG4gIGZvcm0uc3VibWl0KCk7XG5cbiAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uKGVycikge1xuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcbiAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFuaW5nIHVwJywgaWQpO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgfSwgNTAwKTtcbiAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgIC8vIGZhaWxlZCB0byBzdWJtaXQgb3VyIGZvcm0uXG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcbiAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGlkLCBpZnJhbWUucmVhZHlTdGF0ZSwgZSk7XG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL2pzb25wLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi90cmFuc3BvcnQvc2VuZGVyL2pzb25wLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9zaGltcycpO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuL3V0aWxzL3JhbmRvbScpXG4gICwgZXNjYXBlID0gcmVxdWlyZSgnLi91dGlscy9lc2NhcGUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCB0cmFuc3BvcnQgPSByZXF1aXJlKCcuL3V0aWxzL3RyYW5zcG9ydCcpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbHMvYnJvd3NlcicpXG4gICwgbG9nID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50dGFyZ2V0JylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgLCBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpXG4gICwgVHJhbnNwb3J0TWVzc2FnZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC90cmFucy1tZXNzYWdlJylcbiAgLCBJbmZvUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8tcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6bWFpbicpO1xufVxuXG52YXIgdHJhbnNwb3J0cztcblxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbmZ1bmN0aW9uIFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja0pTKSkge1xuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XG4gIH1cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgdGhpcy5leHRlbnNpb25zID0gJyc7XG4gIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAvLyBub24tc3RhbmRhcmQgZXh0ZW5zaW9uXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgbG9nLndhcm4oXCIncHJvdG9jb2xzX3doaXRlbGlzdCcgaXMgREVQUkVDQVRFRC4gVXNlICd0cmFuc3BvcnRzJyBpbnN0ZWFkLlwiKTtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0ID0gb3B0aW9ucy50cmFuc3BvcnRzO1xuICB0aGlzLl90cmFuc3BvcnRPcHRpb25zID0gb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzZXNzaW9uSWQgPSBvcHRpb25zLnNlc3Npb25JZCB8fCA4O1xuICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyIHx8IHJhbmRvbS5udW1iZXJTdHJpbmcoMTAwMCk7XG5cbiAgLy8gU3RlcCAxIG9mIFdTIHNwZWMgLSBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIHVybC4gSXNzdWUgIzhcbiAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCB8fCAhcGFyc2VkVXJsLnByb3RvY29sKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCAnXCIgKyB1cmwgKyBcIicgaXMgaW52YWxpZFwiKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVGhlIFVSTCBtdXN0IG5vdCBjb250YWluIGEgZnJhZ21lbnQnKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwncyBzY2hlbWUgbXVzdCBiZSBlaXRoZXIgJ2h0dHA6JyBvciAnaHR0cHM6Jy4gJ1wiICsgcGFyc2VkVXJsLnByb3RvY29sICsgXCInIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgfVxuXG4gIHZhciBzZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAvLyBTdGVwIDIgLSBkb24ndCBhbGxvdyBzZWN1cmUgb3JpZ2luIHdpdGggYW4gaW5zZWN1cmUgcHJvdG9jb2xcbiAgaWYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzJyAmJiAhc2VjdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBBbiBpbnNlY3VyZSBTb2NrSlMgY29ubmVjdGlvbiBtYXkgbm90IGJlIGluaXRpYXRlZCBmcm9tIGEgcGFnZSBsb2FkZWQgb3ZlciBIVFRQUycpO1xuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9ICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMDtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL21haW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuNS40LjIwXG4vLyB3aGl0ZXNwYWNlIGZyb206IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG52YXIgd3MgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnICtcbiAgICAnXFx1MjAyOVxcdUZFRkYnO1xudmFyIHplcm9XaWR0aCA9ICdcXHUyMDBiJztcbnZhciB3c1JlZ2V4Q2hhcnMgPSAnWycgKyB3cyArICddJztcbnZhciB0cmltQmVnaW5SZWdleHAgPSBuZXcgUmVnRXhwKCdeJyArIHdzUmVnZXhDaGFycyArIHdzUmVnZXhDaGFycyArICcqJyk7XG52YXIgdHJpbUVuZFJlZ2V4cCA9IG5ldyBSZWdFeHAod3NSZWdleENoYXJzICsgd3NSZWdleENoYXJzICsgJyokJyk7XG52YXIgaGFzVHJpbVdoaXRlc3BhY2VCdWcgPSBTdHJpbmdQcm90b3R5cGUudHJpbSAmJiAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKTtcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgLy8gaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHRcbiAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGl0ZXNwYWNlLWRldmlhdGlvbnMvXG4gICAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcykucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKS5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbiAgICB9XG59LCBoYXNUcmltV2hpdGVzcGFjZUJ1Zyk7XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi9zaGltcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG52YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZ1xuICAsIGV4dHJhTG9va3VwO1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbExvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICB2YXIgaTtcbiAgdmFyIHVucm9sbGVkID0ge307XG4gIHZhciBjID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gIH1cbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT04zLnN0cmluZ2lmeShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhRXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKCFleHRyYUVzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xuICAgICAgZXh0cmFMb29rdXAgPSB1bnJvbGxMb29rdXAoZXh0cmFFc2NhcGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBxdW90ZWQucmVwbGFjZShleHRyYUVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGV4dHJhTG9va3VwW2FdO1xuICAgIH0pO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL2VzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdXRpbHMvZXNjYXBlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp0cmFuc3BvcnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHJldHVybiB7XG4gICAgZmlsdGVyVG9FbmFibGVkOiBmdW5jdGlvbih0cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKSB7XG4gICAgICB2YXIgdHJhbnNwb3J0cyA9IHtcbiAgICAgICAgbWFpbjogW11cbiAgICAgICwgZmFjYWRlOiBbXVxuICAgICAgfTtcbiAgICAgIGlmICghdHJhbnNwb3J0c1doaXRlbGlzdCkge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW107XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnRzV2hpdGVsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW3RyYW5zcG9ydHNXaGl0ZWxpc3RdO1xuICAgICAgfVxuXG4gICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgaWYgKCF0cmFucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy50cmFuc3BvcnROYW1lID09PSAnd2Vic29ja2V0JyAmJiBpbmZvLndlYnNvY2tldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQgZnJvbSBzZXJ2ZXInLCAnd2Vic29ja2V0Jyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zcG9ydHNXaGl0ZWxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0LmluZGV4T2YodHJhbnMudHJhbnNwb3J0TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMuZW5hYmxlZChpbmZvKSkge1xuICAgICAgICAgIGRlYnVnKCdlbmFibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xuICAgICAgICAgIGlmICh0cmFucy5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHMuZmFjYWRlLnB1c2godHJhbnMuZmFjYWRlVHJhbnNwb3J0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gICAgfVxuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi91dGlscy90cmFuc3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL3V0aWxzL3RyYW5zcG9ydC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2dPYmplY3QgPSB7fTtcblsnbG9nJywgJ2RlYnVnJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICB2YXIgbGV2ZWxFeGlzdHM7XG5cbiAgdHJ5IHtcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9IDogKGxldmVsID09PSAnbG9nJyA/IGZ1bmN0aW9uICgpIHt9IDogbG9nT2JqZWN0LmxvZyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdXRpbHMvbG9nLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi91dGlscy9sb2cuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBFdmVudChldmVudFR5cGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xufVxuXG5FdmVudC5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xuICB0aGlzLmJ1YmJsZXMgPSBjYW5CdWJibGU7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHt9O1xuXG5FdmVudC5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuRXZlbnQuQVRfVEFSR0VUID0gMjtcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9ldmVudC9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvZXZlbnQvZXZlbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5sb2NhdGlvbiB8fCB7XG4gIG9yaWdpbjogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAnXG4sIHByb3RvY29sOiAnaHR0cCdcbiwgaG9zdDogJ2xvY2FsaG9zdCdcbiwgcG9ydDogODBcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xuLCBoYXNoOiAnJ1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9sb2NhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvbG9jYXRpb24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL2V2ZW50L2Nsb3NlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi9ldmVudC9jbG9zZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvbGliL2V2ZW50L3RyYW5zLW1lc3NhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL2V2ZW50L3RyYW5zLW1lc3NhZ2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1yZWNlaXZlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvaW5mby1yZWNlaXZlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NranMtY2xpZW50L2xpYi9pbmZvLWlmcmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvaW5mby1pZnJhbWUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcblxuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pcikge1xuICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICB0aGlzLmlyID0gbnVsbDtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXJJZnJhbWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1pZnJhbWUtcmVjZWl2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvbGliL2luZm8taWZyYW1lLXJlY2VpdmVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1hamF4Jyk7XG59XG5cbmZ1bmN0aW9uIEluZm9BamF4KHVybCwgQWpheE9iamVjdCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0MCA9ICtuZXcgRGF0ZSgpO1xuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ0dFVCcsIHVybCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICB2YXIgaW5mbywgcnR0O1xuICAgIGlmIChzdGF0dXMgPT09IDIwMCkge1xuICAgICAgcnR0ID0gKCtuZXcgRGF0ZSgpKSAtIHQwO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmZvID0gSlNPTjMucGFyc2UodGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdFV0aWxzLmlzT2JqZWN0KGluZm8pKSB7XG4gICAgICAgIGluZm8gPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvQWpheCwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0FqYXgucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMueG8uY2xvc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0FqYXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvaW5mby1hamF4LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi9pbmZvLWFqYXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHBbMV07XG4gICAgICAgIHZhciB0cmFuc1VybCA9IHBbMl07XG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcbiAgICAgICAgZGVidWcodmVyc2lvbiwgdHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgIC8vIGNoYW5nZSB0aGlzIHRvIHNlbXZlciBsb2dpY1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvaWZyYW1lLWJvb3RzdHJhcC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9saWIvaWZyYW1lLWJvb3RzdHJhcC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9saWIvZmFjYWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2xpYi9mYWNhZGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8qZ2xvYmFscyB3aW5kb3cgX193ZWJwYWNrX2hhc2hfXyAqL1xuaWYobW9kdWxlLmhvdCkge1xuXHR2YXIgbGFzdERhdGE7XG5cdHZhciB1cFRvRGF0ZSA9IGZ1bmN0aW9uIHVwVG9EYXRlKCkge1xuXHRcdHJldHVybiBsYXN0RGF0YS5pbmRleE9mKF9fd2VicGFja19oYXNoX18pID49IDA7XG5cdH07XG5cdHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKCkge1xuXHRcdG1vZHVsZS5ob3QuY2hlY2soZnVuY3Rpb24oZXJyLCB1cGRhdGVkTW9kdWxlcykge1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGlmKG1vZHVsZS5ob3Quc3RhdHVzKCkgaW4ge1xuXHRcdFx0XHRcdFx0YWJvcnQ6IDEsXG5cdFx0XHRcdFx0XHRmYWlsOiAxXG5cdFx0XHRcdFx0fSkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIENhbm5vdCBjaGVjayBmb3IgdXBkYXRlLiBOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIpO1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIFwiICsgZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSBVcGRhdGUgY2hlY2sgZmFpbGVkOiBcIiArIGVyci5zdGFjayB8fCBlcnIubWVzc2FnZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighdXBkYXRlZE1vZHVsZXMpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gQ2Fubm90IGZpbmQgdXBkYXRlLiBOZWVkIHRvIGRvIGEgZnVsbCByZWxvYWQhXCIpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSAoUHJvYmFibHkgYmVjYXVzZSBvZiByZXN0YXJ0aW5nIHRoZSB3ZWJwYWNrLWRldi1zZXJ2ZXIpXCIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG1vZHVsZS5ob3QuYXBwbHkoe1xuXHRcdFx0XHRpZ25vcmVVbmFjY2VwdGVkOiB0cnVlXG5cdFx0XHR9LCBmdW5jdGlvbihlcnIsIHJlbmV3ZWRNb2R1bGVzKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGlmKG1vZHVsZS5ob3Quc3RhdHVzKCkgaW4ge1xuXHRcdFx0XHRcdFx0XHRhYm9ydDogMSxcblx0XHRcdFx0XHRcdFx0ZmFpbDogMVxuXHRcdFx0XHRcdFx0fSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gQ2Fubm90IGFwcGx5IHVwZGF0ZS4gTmVlZCB0byBkbyBhIGZ1bGwgcmVsb2FkIVwiKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIFwiICsgZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gVXBkYXRlIGZhaWxlZDogXCIgKyBlcnIuc3RhY2sgfHwgZXJyLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZighdXBUb0RhdGUoKSkge1xuXHRcdFx0XHRcdGNoZWNrKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXF1aXJlKFwiLi9sb2ctYXBwbHktcmVzdWx0XCIpKHVwZGF0ZWRNb2R1bGVzLCByZW5ld2VkTW9kdWxlcyk7XG5cblx0XHRcdFx0aWYodXBUb0RhdGUoKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gQXBwIGlzIHVwIHRvIGRhdGUuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fTtcblx0dmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG5cdH0gOiBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdFx0d2luZG93LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHR9O1xuXHRhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmKHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmIGV2ZW50LmRhdGEuaW5kZXhPZihcIndlYnBhY2tIb3RVcGRhdGVcIikgPT09IDApIHtcblx0XHRcdGxhc3REYXRhID0gZXZlbnQuZGF0YTtcblx0XHRcdGlmKCF1cFRvRGF0ZSgpICYmIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gQ2hlY2tpbmcgZm9yIHVwZGF0ZXMgb24gdGhlIHNlcnZlci4uLlwiKTtcblx0XHRcdFx0Y2hlY2soKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRjb25zb2xlLmxvZyhcIltITVJdIFdhaXRpbmcgZm9yIHVwZGF0ZSBzaWduYWwgZnJvbSBXRFMuLi5cIik7XG59IGVsc2Uge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9ob3Qvb25seS1kZXYtc2VydmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9vbmx5LWRldi1zZXJ2ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXBkYXRlZE1vZHVsZXMsIHJlbmV3ZWRNb2R1bGVzKSB7XG5cdHZhciB1bmFjY2VwdGVkTW9kdWxlcyA9IHVwZGF0ZWRNb2R1bGVzLmZpbHRlcihmdW5jdGlvbihtb2R1bGVJZCkge1xuXHRcdHJldHVybiByZW5ld2VkTW9kdWxlcyAmJiByZW5ld2VkTW9kdWxlcy5pbmRleE9mKG1vZHVsZUlkKSA8IDA7XG5cdH0pO1xuXG5cdGlmKHVuYWNjZXB0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcblx0XHRjb25zb2xlLndhcm4oXCJbSE1SXSBUaGUgZm9sbG93aW5nIG1vZHVsZXMgY291bGRuJ3QgYmUgaG90IHVwZGF0ZWQ6IChUaGV5IHdvdWxkIG5lZWQgYSBmdWxsIHJlbG9hZCEpXCIpO1xuXHRcdHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIltITVJdICAtIFwiICsgbW9kdWxlSWQpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYoIXJlbmV3ZWRNb2R1bGVzIHx8IHJlbmV3ZWRNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gTm90aGluZyBob3QgdXBkYXRlZC5cIik7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS5sb2coXCJbSE1SXSBVcGRhdGVkIG1vZHVsZXM6XCIpO1xuXHRcdHJlbmV3ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlSWQpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG5cdFx0fSk7XG5cdH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvaG90L2xvZy1hcHBseS1yZXN1bHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2xvZy1hcHBseS1yZXN1bHQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL292ZXJyaWRlcy5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vb3ZlcnJpZGVzLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL292ZXJyaWRlcy5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9vdmVycmlkZXMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvb3ZlcnJpZGVzLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudWkuZHJvcGRvd24gLm1lbnUgLnNlbGVjdGVkLml0ZW0sXFxuLnVpLmRyb3Bkb3duIC5tZW51ID4gLml0ZW06aG92ZXIsXFxuLnVpLmRyb3Bkb3duLnNlbGVjdGVkIHtcXG4gIGJhY2tncm91bmQ6ICNlMmVmZjkgIWltcG9ydGFudDsgfVxcblxcbi51aS5jYXJkID4gLmV4dHJhLFxcbi51aS5jYXJkcyA+IC5jYXJkID4gLmV4dHJhIHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIDAuMSkgIWltcG9ydGFudDsgfVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvc3JjL292ZXJyaWRlcy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUNBOzs7RUFHRSwrQkFBNEMsRUFDN0M7O0FBRUQ7O0VBRUUsb0RBQWlELEVBQ2xEXCIsXCJmaWxlXCI6XCJvdmVycmlkZXMuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvLyBPdmVycmlkZXNcXG46Z2xvYmFsKC51aS5kcm9wZG93biAubWVudSAuc2VsZWN0ZWQuaXRlbSksXFxuOmdsb2JhbCgudWkuZHJvcGRvd24gLm1lbnUgPiAuaXRlbTpob3ZlciksXFxuOmdsb2JhbCgudWkuZHJvcGRvd24uc2VsZWN0ZWQpIHtcXG4gIGJhY2tncm91bmQ6IGxpZ2h0ZW4oIzI5ODdDRCwgNDUlKSAhaW1wb3J0YW50O1xcbn1cXG5cXG46Z2xvYmFsKC51aS5jYXJkID4gLmV4dHJhKSxcXG46Z2xvYmFsKC51aS5jYXJkcyA+IC5jYXJkID4gLmV4dHJhKSB7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgwLDAsMCwgMC4xKSAhaW1wb3J0YW50O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL34vcG9zdGNzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyP3NvdXJjZU1hcCEuL3NyYy9vdmVycmlkZXMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vc3JjL292ZXJyaWRlcy5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBBcHBDb250YWluZXIgfSBmcm9tICdyZWFjdC1ob3QtbG9hZGVyJztcbmltcG9ydCBjb25maWd1cmVTdG9yZSBmcm9tICcuL3N0b3JlL2NvbmZpZ3VyZS1zdG9yZSc7XG5pbXBvcnQgQXBwbGljYXRpb24gZnJvbSAnLi9hcHBsaWNhdGlvbic7XG5cbm1vbWVudC5sb2NhbGUoJ3B0LWJyJyk7XG5cbmNvbnN0IHJvb3RFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN3cmFwcGVyJyk7XG5jb25zdCBzdG9yZSA9IGNvbmZpZ3VyZVN0b3JlKCk7XG5cblJlYWN0RE9NLnJlbmRlcihcbiAgPEFwcENvbnRhaW5lcj5cbiAgICA8QXBwbGljYXRpb24gc3RvcmU9e3N0b3JlfSAvPlxuICA8L0FwcENvbnRhaW5lcj4sXG4gIHJvb3RFbCxcbik7XG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KCcuL2FwcGxpY2F0aW9uJywgKCkgPT4ge1xuICAgIGNvbnN0IE5leHRBcHAgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uJykuZGVmYXVsdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgUmVhY3RET00ucmVuZGVyKFxuICAgICAgPEFwcENvbnRhaW5lcj5cbiAgICAgICAgPE5leHRBcHAgc3RvcmU9e3N0b3JlfSAvPlxuICAgICAgPC9BcHBDb250YWluZXI+LFxuICAgICAgcm9vdEVsLFxuICAgICk7XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvaW5kZXguanN4IiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTAxMyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTEyNCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMjcwKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtaG90LWxvYWRlci9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBhcHBseU1pZGRsZXdhcmUsIGNyZWF0ZVN0b3JlLCBjb21wb3NlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgbWlkZGxld2FyZSwgb3V0ZXJSZWR1Y2VyIH0gZnJvbSAncmVkdXgtYXN5bmMtaW5pdGlhbC1zdGF0ZSc7XG5pbXBvcnQgY3JlYXRlU2FnYU1pZGRsZXdhcmUgZnJvbSAncmVkdXgtc2FnYSc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3JlZHV4LWltbXV0YWJsZS1zdGF0ZS1pbnZhcmlhbnQnO1xuaW1wb3J0IHJlZHVjZXJzIGZyb20gJy4vcmVkdWNlcnMnO1xuaW1wb3J0IHJvb3RTYWdhIGZyb20gJy4vc2FnYXMnO1xuaW1wb3J0IHsgbG9hZFN0YXRlLCBzYXZlU3RhdGUgfSBmcm9tICcuL2NhY2hlLXN0YXRlJztcblxuY29uc3QgREVWID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuY29uc3QgY29uZmlndXJlU3RvcmUgPSAoKSA9PiB7XG4gIGNvbnN0IHNhZ2FNaWRkbGV3YXJlID0gY3JlYXRlU2FnYU1pZGRsZXdhcmUoKTtcbiAgbGV0IG1pZGRsZXdhcmVzID0gW3NhZ2FNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKGxvYWRTdGF0ZSldO1xuXG4gIGlmIChERVYpIHtcbiAgICBjb25zdCB7IERldlRvb2xzIH0gPSByZXF1aXJlKCcuLi9kZXZ0b29scycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgY29uc3QgY29tcG9zZUVuaGFuY2VycyA9IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX187XG5cbiAgICBtaWRkbGV3YXJlcyA9IG1pZGRsZXdhcmVzLmNvbmNhdChbaW52YXJpYW50KCldKTtcbiAgICBtaWRkbGV3YXJlcyA9IGFwcGx5TWlkZGxld2FyZSguLi5taWRkbGV3YXJlcyk7XG4gICAgbWlkZGxld2FyZXMgPSBjb21wb3NlRW5oYW5jZXJzID9cbiAgICAgIGNvbXBvc2VFbmhhbmNlcnMobWlkZGxld2FyZXMpIDpcbiAgICAgIGNvbXBvc2UobWlkZGxld2FyZXMsIERldlRvb2xzLmluc3RydW1lbnQoKSk7XG4gIH0gZWxzZSB7XG4gICAgbWlkZGxld2FyZXMgPSBhcHBseU1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShvdXRlclJlZHVjZXIocmVkdWNlcnMpLCBtaWRkbGV3YXJlcyk7XG5cbiAgc3RvcmUucnVuU2FnYSA9IHNhZ2FNaWRkbGV3YXJlLnJ1bjtcblxuICBpZiAobW9kdWxlLmhvdCkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KCcuL3JlZHVjZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbmV4dFJlZHVjZXIgPSByZXF1aXJlKCcuL3JlZHVjZXJzJykuZGVmYXVsdDtcblxuICAgICAgc3RvcmUucmVwbGFjZVJlZHVjZXIob3V0ZXJSZWR1Y2VyKG5leHRSZWR1Y2VyKSk7XG4gICAgfSk7XG4gIH1cblxuICBzdG9yZS5zdWJzY3JpYmUodGhyb3R0bGUoKCkgPT4ge1xuICAgIGNvbnN0IHsgYXV0aDogeyBhdXRoRGF0YSB9IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgc2F2ZVN0YXRlKHsgYXV0aDogeyBhdXRoRGF0YSB9IH0pO1xuICB9LCAyMDAwKSk7XG5cbiAgc3RvcmUucnVuU2FnYShyb290U2FnYSk7XG5cbiAgcmV0dXJuIHN0b3JlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29uZmlndXJlU3RvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9jb25maWd1cmUtc3RvcmUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNzU0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgyMTg0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTM1Mik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTU1OCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlZHV4LWFzeW5jLWluaXRpYWwtc3RhdGUvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxODEyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVkdXgtc2FnYS9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE4MDgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC1pbW11dGFibGUtc3RhdGUtaW52YXJpYW50L2Rpc3QvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGlubmVyUmVkdWNlciB9IGZyb20gJ3JlZHV4LWFzeW5jLWluaXRpYWwtc3RhdGUnO1xuaW1wb3J0ICogYXMgYXV0aCBmcm9tICcuL2F1dGgnO1xuaW1wb3J0ICogYXMgZW50aXRpZXMgZnJvbSAnLi9lbnRpdGllcyc7XG5pbXBvcnQgKiBhcyBmaWx0ZXIgZnJvbSAnLi9maWx0ZXInO1xuaW1wb3J0ICogYXMgZ2xvYmFsIGZyb20gJy4vZ2xvYmFsJztcbmltcG9ydCAqIGFzIHByb2ZpbGUgZnJvbSAnLi9wcm9maWxlJztcblxuZXhwb3J0IGRlZmF1bHQgY29tYmluZVJlZHVjZXJzKHtcbiAgYXN5bmNTdGF0ZTogaW5uZXJSZWR1Y2VyLFxuICBhdXRoOiBjb21iaW5lUmVkdWNlcnMoYXV0aCksXG4gIGVudGl0aWVzOiBjb21iaW5lUmVkdWNlcnMoZW50aXRpZXMpLFxuICBmaWx0ZXI6IGNvbWJpbmVSZWR1Y2VycyhmaWx0ZXIpLFxuICBnbG9iYWw6IGNvbWJpbmVSZWR1Y2VycyhnbG9iYWwpLFxuICBwcm9maWxlOiBjb21iaW5lUmVkdWNlcnMocHJvZmlsZSksXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3N0b3JlL3JlZHVjZXJzL2luZGV4LmpzIiwiaW1wb3J0IHsgaGFuZGxlQWN0aW9ucyB9IGZyb20gJ3JlZHV4LWFjdGlvbnMnO1xuaW1wb3J0IGVtcHR5T2JqZWN0IGZyb20gJ2ZianMvbGliL2VtcHR5T2JqZWN0JztcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucyc7XG5cbmV4cG9ydCBjb25zdCBpc0F1dGhlbnRpY2F0aW5nID0gaGFuZGxlQWN0aW9ucyh7XG4gIFthY3Rpb25zLmxvZ2luXTogKCkgPT4gdHJ1ZSxcbiAgW2FjdGlvbnMuYXV0aG9yaXplXTogKCkgPT4gZmFsc2UsXG59LCBmYWxzZSk7XG5cbmV4cG9ydCBjb25zdCBpc1JlZ2lzdGVyaW5nID0gaGFuZGxlQWN0aW9ucyh7XG4gIFthY3Rpb25zLnJlZ2lzdGVyXTogKCkgPT4gdHJ1ZSxcbiAgW2FjdGlvbnMuYXV0aG9yaXplXTogKCkgPT4gZmFsc2UsXG59LCBmYWxzZSk7XG5cbmV4cG9ydCBjb25zdCBhdXRoRGF0YSA9IGhhbmRsZUFjdGlvbnMoe1xuICBbYWN0aW9ucy51bmF1dGhvcml6ZV06ICgpID0+IGVtcHR5T2JqZWN0LFxuICBbYWN0aW9ucy5hdXRob3JpemVdOiAoc3RhdGUsIHsgZXJyb3IsIHBheWxvYWQgfSkgPT4gKGVycm9yID8ge30gOiBwYXlsb2FkKSxcbn0sIGVtcHR5T2JqZWN0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3N0b3JlL3JlZHVjZXJzL2F1dGguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTc5NSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNDExKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVkdXgtYWN0aW9ucy9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDk4Myk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyB2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IGNyZWF0ZUFjdGlvbiBmcm9tICd+L2hlbHBlcnMvY3JlYXRlLWFjdGlvbic7XG5cbmNvbnN0IGhhbmRsZU5vdGlmeSA9IChtZXNzYWdlKSA9PiB7XG4gIG1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyB7IG1lc3NhZ2UgfSA6IG1lc3NhZ2U7XG4gIG1lc3NhZ2UudWlkID0gdjQoKTtcblxuICByZXR1cm4gbWVzc2FnZTtcbn07XG5cbi8vIEF1dGhcbmV4cG9ydCBjb25zdCBsb2dpbiA9IGNyZWF0ZUFjdGlvbignbG9naW4nKTtcbmV4cG9ydCBjb25zdCBsb2dvdXQgPSBjcmVhdGVBY3Rpb24oJ2xvZ291dCcpO1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyID0gY3JlYXRlQWN0aW9uKCdyZWdpc3RlcicpO1xuZXhwb3J0IGNvbnN0IGF1dGhvcml6ZSA9IGNyZWF0ZUFjdGlvbignYXV0aG9yaXplJyk7XG5leHBvcnQgY29uc3QgdW5hdXRob3JpemUgPSBjcmVhdGVBY3Rpb24oJ3VuYXV0aG9yaXplJyk7XG5cbi8vIEFwcCBBY3Rpb25zXG5leHBvcnQgY29uc3Qgbm90aWZ5ID0gY3JlYXRlQWN0aW9uKCdub3RpZnknLCBoYW5kbGVOb3RpZnkpO1xuZXhwb3J0IGNvbnN0IG5vdGlmeUVycm9yID0gY3JlYXRlQWN0aW9uKCdub3RpZnknLCBoYW5kbGVOb3RpZnkpO1xuZXhwb3J0IGNvbnN0IG5vdGlmeUluZm8gPSBjcmVhdGVBY3Rpb24oJ25vdGlmeScsIGhhbmRsZU5vdGlmeSk7XG5leHBvcnQgY29uc3Qgbm90aWZ5V2FybmluZyA9IGNyZWF0ZUFjdGlvbignbm90aWZ5JywgaGFuZGxlTm90aWZ5KTtcbmV4cG9ydCBjb25zdCBmaWx0ZXIgPSBjcmVhdGVBY3Rpb24oJ2ZpbHRlcicpO1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUZpbHRlciA9IGNyZWF0ZUFjdGlvbigndXBkYXRlLWZpbHRlcicpO1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb2ZpbGUgPSBjcmVhdGVBY3Rpb24oJ3VwZGF0ZS1wcm9maWxlJyk7XG5leHBvcnQgY29uc3QgdXBkYXRlVGFiRmVlZCA9IGNyZWF0ZUFjdGlvbigndXBkYXRlLXRhYi1mZWVkJyk7XG5cbi8vIEVudGl0eSBBY3Rpb25zXG5leHBvcnQgY29uc3QgYWRkVG9PcmcgPSBjcmVhdGVBY3Rpb24oJ2FkZC10by1vcmcnKTtcbmV4cG9ydCBjb25zdCByZWFkID0gY3JlYXRlQWN0aW9uKCdyZWFkJyk7XG5leHBvcnQgY29uc3QgcmVtb3ZlID0gY3JlYXRlQWN0aW9uKCdyZW1vdmUnKTtcbmV4cG9ydCBjb25zdCByZW1vdmVDYWNoZSA9IGNyZWF0ZUFjdGlvbigncmVtb3ZlLWNhY2hlJyk7XG5leHBvcnQgY29uc3Qgc2F2ZSA9IGNyZWF0ZUFjdGlvbignc2F2ZScsIChyZWYsIGRhdGEpID0+ICh7IHJlZiwgZGF0YSB9KSk7XG5leHBvcnQgY29uc3QgdXBkYXRlQ2FjaGUgPSBjcmVhdGVBY3Rpb24oJ3VwZGF0ZS1jYWNoZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvYWN0aW9ucy5qcyIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDIxNzMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy91dWlkL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyB2NCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uIGFzIGNyZWF0ZVJlZHV4QWN0aW9ucyB9IGZyb20gJ3JlZHV4LWFjdGlvbnMnO1xuXG5jb25zdCBjcmVhdGVBY3Rpb24gPSAobmFtZSwgLi4uYXJncykgPT4gY3JlYXRlUmVkdXhBY3Rpb25zKGAke25hbWV9LSR7djQoKX1gLCAuLi5hcmdzKTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQWN0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvaGVscGVycy9jcmVhdGUtYWN0aW9uLmpzIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGhhbmRsZUFjdGlvbnMgfSBmcm9tICdyZWR1eC1hY3Rpb25zJztcbmltcG9ydCBlbXB0eU9iamVjdCBmcm9tICdmYmpzL2xpYi9lbXB0eU9iamVjdCc7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMnO1xuXG5leHBvcnQgY29uc3QgYnlJZCA9IGhhbmRsZUFjdGlvbnMoe1xuICBbYWN0aW9ucy51bmF1dGhvcml6ZV06ICgpID0+IGVtcHR5T2JqZWN0LFxuICBbYWN0aW9ucy5yZW1vdmVDYWNoZV06IChzdGF0ZSwgeyBlcnJvciwgcGF5bG9hZCB9KSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3U3RhdGUgPSBfLm1lcmdlKHt9LCBzdGF0ZSk7XG5cbiAgICB0cnkge1xuICAgICAgZGVsZXRlIG5ld1N0YXRlW3BheWxvYWQuZW50aXR5XVtwYXlsb2FkLnVpZF07XG5cbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gIH0sXG4gIFthY3Rpb25zLnVwZGF0ZUNhY2hlXTogKHN0YXRlLCB7IGVycm9yLCBwYXlsb2FkIH0pID0+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IF8ubWVyZ2Uoe30sIHN0YXRlKTtcblxuICAgIF8uZm9yRWFjaChwYXlsb2FkLnJlc3BvbnNlLCAodmFsLCBrZXkpID0+IHtcbiAgICAgIGlmICghbmV3U3RhdGVbcGF5bG9hZC5lbnRpdHldKSB7XG4gICAgICAgIG5ld1N0YXRlW3BheWxvYWQuZW50aXR5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBuZXdTdGF0ZVtwYXlsb2FkLmVudGl0eV1ba2V5XSA9IHZhbDtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfSxcbn0sIGVtcHR5T2JqZWN0KTtcblxuZXhwb3J0IGNvbnN0IGlzRmV0Y2hpbmcgPSBoYW5kbGVBY3Rpb25zKHtcbiAgW2FjdGlvbnMudW5hdXRob3JpemVdOiAoKSA9PiAoe30pLFxuICBbYWN0aW9ucy5yZWFkXTogKHN0YXRlLCB7IHBheWxvYWQgfSkgPT4gXy5hc3NpZ24oe30sIHN0YXRlLCB7IFtwYXlsb2FkLmVudGl0eV06IHRydWUgfSksXG4gIFthY3Rpb25zLmFkZFRvT3JnXTogKHN0YXRlLCB7IHBheWxvYWQgfSkgPT4gXy5hc3NpZ24oe30sIHN0YXRlLCB7IFtwYXlsb2FkLmVudGl0eV06IHRydWUgfSksXG4gIFthY3Rpb25zLnVwZGF0ZUNhY2hlXTogKHN0YXRlLCB7IGVycm9yLCBwYXlsb2FkIH0pID0+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy5hc3NpZ24oe30sIHN0YXRlLCB7IFtwYXlsb2FkLmVudGl0eV06IGZhbHNlIH0pO1xuICB9LFxufSwgZW1wdHlPYmplY3QpO1xuXG5leHBvcnQgY29uc3QgaXNSZW1vdmluZyA9IGhhbmRsZUFjdGlvbnMoe1xuICBbYWN0aW9ucy51bmF1dGhvcml6ZV06ICgpID0+IGVtcHR5T2JqZWN0LFxuICBbYWN0aW9ucy5yZW1vdmVdOiAoc3RhdGUsIHsgcGF5bG9hZCB9KSA9PiBfLmFzc2lnbih7fSwgc3RhdGUsIHsgW3BheWxvYWQuZW50aXR5XTogdHJ1ZSB9KSxcbiAgW2FjdGlvbnMucmVtb3ZlQ2FjaGVdOiAoc3RhdGUsIHsgcGF5bG9hZCB9KSA9PiB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBfLm1lcmdlKHt9LCBzdGF0ZSk7XG5cbiAgICBkZWxldGUgbmV3U3RhdGVbcGF5bG9hZC5lbnRpdHldW3BheWxvYWQudWlkXTtcblxuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfSxcbn0sIGVtcHR5T2JqZWN0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3N0b3JlL3JlZHVjZXJzL2VudGl0aWVzLmpzIiwiaW1wb3J0IHsgaGFuZGxlQWN0aW9ucyB9IGZyb20gJ3JlZHV4LWFjdGlvbnMnO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tICcuLi9hY3Rpb25zJztcblxuY29uc3QgY3JlYXRlRmlsdGVyUmVkdWNlciA9IChuYW1lLCBkZWZhdWx0VmFsdWUpID0+IChcbiAgaGFuZGxlQWN0aW9ucyh7XG4gICAgW2FjdGlvbnMudW5hdXRob3JpemVdOiAoKSA9PiBkZWZhdWx0VmFsdWUsXG4gICAgW2FjdGlvbnMudXBkYXRlRmlsdGVyXTogKHN0YXRlLCB7IHBheWxvYWQgfSkgPT5cbiAgICAgIChuYW1lID09PSBwYXlsb2FkLm5hbWUgPyBwYXlsb2FkLnZhbHVlIDogc3RhdGUpLFxuICB9LCBkZWZhdWx0VmFsdWUpXG4pO1xuXG5leHBvcnQgY29uc3QgcXVlcnkgPSBjcmVhdGVGaWx0ZXJSZWR1Y2VyKCdxdWVyeScsICcnKTtcbmV4cG9ydCBjb25zdCBza2lsbHMgPSBjcmVhdGVGaWx0ZXJSZWR1Y2VyKCdza2lsbHMnLCBbXSk7XG5leHBvcnQgY29uc3QgZW50aXR5ID0gY3JlYXRlRmlsdGVyUmVkdWNlcignZW50aXR5JywgJ3VzZXJzJyk7XG5leHBvcnQgY29uc3QgaXNGaWx0ZXJpbmcgPSBoYW5kbGVBY3Rpb25zKHtcbiAgW2FjdGlvbnMudW5hdXRob3JpemVdOiAoKSA9PiBmYWxzZSxcbiAgW2FjdGlvbnMuZmlsdGVyXTogKCkgPT4gdHJ1ZSxcbiAgW2FjdGlvbnMuc2VhcmNoRG9uZV06ICgpID0+IGZhbHNlLFxufSwgZmFsc2UpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvcmVkdWNlcnMvZmlsdGVyLmpzIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGhhbmRsZUFjdGlvbnMgfSBmcm9tICdyZWR1eC1hY3Rpb25zJztcbmltcG9ydCBlbXB0eU9iamVjdCBmcm9tICdmYmpzL2xpYi9lbXB0eU9iamVjdCc7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMnO1xuXG5leHBvcnQgY29uc3Qgbm90aWZpY2F0aW9uID0gaGFuZGxlQWN0aW9ucyh7XG4gIFthY3Rpb25zLm5vdGlmeV06IChzdGF0ZSwgYWN0aW9uKSA9PiBfLm1lcmdlKHsgcG9zaXRpb246ICdicicsIGxldmVsOiAnc3VjY2VzcycgfSwgYWN0aW9uLnBheWxvYWQpLFxuICBbYWN0aW9ucy5ub3RpZnlFcnJvcl06IChzdGF0ZSwgYWN0aW9uKSA9PiBfLm1lcmdlKHsgcG9zaXRpb246ICdicicsIGxldmVsOiAnZXJyb3InIH0sIGFjdGlvbi5wYXlsb2FkKSxcbiAgW2FjdGlvbnMubm90aWZ5SW5mb106IChzdGF0ZSwgYWN0aW9uKSA9PiBfLm1lcmdlKHsgcG9zaXRpb246ICdicicsIGxldmVsOiAnaW5mbycgfSwgYWN0aW9uLnBheWxvYWQpLFxuICBbYWN0aW9ucy5ub3RpZnlXYXJuaW5nXTogKHN0YXRlLCBhY3Rpb24pID0+IF8ubWVyZ2UoeyBwb3NpdGlvbjogJ2JyJywgbGV2ZWw6ICd3YXJuaW5nJyB9LCBhY3Rpb24ucGF5bG9hZCksXG59LCBlbXB0eU9iamVjdCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9yZWR1Y2Vycy9nbG9iYWwuanMiLCJpbXBvcnQgeyBoYW5kbGVBY3Rpb25zIH0gZnJvbSAncmVkdXgtYWN0aW9ucyc7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMnO1xuXG5leHBvcnQgY29uc3QgaXNVcGRhdGluZ1Byb2ZpbGUgPSBoYW5kbGVBY3Rpb25zKHtcbiAgW2FjdGlvbnMudW5hdXRob3JpemVdOiAoKSA9PiBmYWxzZSxcbiAgW2FjdGlvbnMudXBkYXRlUHJvZmlsZV06ICgpID0+IHRydWUsXG4gIFthY3Rpb25zLnVwZGF0ZUNhY2hlXTogKHN0YXRlLCB7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5lbnRpdHkgIT09ICd1c2VycycsXG59LCBmYWxzZSk7XG5cbmV4cG9ydCBjb25zdCBjdXJyZW50VGFiRmVlZCA9IGhhbmRsZUFjdGlvbnMoe1xuICBbYWN0aW9ucy51bmF1dGhvcml6ZV06ICgpID0+ICd0aW1lbGluZScsXG4gIFthY3Rpb25zLnVwZGF0ZVRhYkZlZWRdOiAoc3RhdGUsIHsgcGF5bG9hZCB9KSA9PiBwYXlsb2FkLFxufSwgJ3RpbWVsaW5lJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9yZWR1Y2Vycy9wcm9maWxlLmpzIiwiaW1wb3J0IHsgdGFrZUV2ZXJ5IH0gZnJvbSAncmVkdXgtc2FnYSc7XG5pbXBvcnQgKiBhcyBhdXRoU2FnYSBmcm9tICcuL2F1dGgnO1xuaW1wb3J0ICogYXMgZW50aXR5U2FnYSBmcm9tICcuL2VudGl0aWVzJztcbmltcG9ydCAqIGFzIHByb2ZpbGVTYWdhIGZyb20gJy4vcHJvZmlsZSc7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gJy4uL2FjdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiogKCkge1xuICAvLyBBdXRoXG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLmxvZ2luLnRvU3RyaW5nKCksIGF1dGhTYWdhLmxvZ2luKTtcbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMubG9nb3V0LnRvU3RyaW5nKCksIGF1dGhTYWdhLmxvZ291dCk7XG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLnJlZ2lzdGVyLnRvU3RyaW5nKCksIGF1dGhTYWdhLnJlZ2lzdGVyKTtcblxuICAvLyBFbnRpdGllc1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5yZWFkLnRvU3RyaW5nKCksIGVudGl0eVNhZ2EucmVhZCk7XG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLnJlbW92ZS50b1N0cmluZygpLCBlbnRpdHlTYWdhLnJlbW92ZSk7XG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLnNhdmUudG9TdHJpbmcoKSwgZW50aXR5U2FnYS5zYXZlKTtcblxuICAvLyBQcm9maWxlXG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLmFkZFRvT3JnLnRvU3RyaW5nKCksIHByb2ZpbGVTYWdhLmFkZFRvT3JnKTtcbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMudXBkYXRlUHJvZmlsZS50b1N0cmluZygpLCBwcm9maWxlU2FnYS51cGRhdGUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2FnYXMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID1cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIDQuMC41XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBfaXNBcnJheSA9IHVuZGVmaW5lZDtcbmlmICghQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdW5kZWZpbmVkO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdW5kZWZpbmVkO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICh7fSkudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgdmFyIHZlcnR4ID0gcigndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdW5kZWZpbmVkO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gIGlmIChfc3RhdGUpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX2FyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbnZhciBHRVRfVEhFTl9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgcmV0dXJuIEdFVF9USEVOX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJCkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQgPT09IHRoZW4gJiYgbWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3Rvci5yZXNvbHZlID09PSByZXNvbHZlKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJCA9PT0gR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJCkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICBfcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGdldFRoZW4odmFsdWUpKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB1bmRlZmluZWQsXG4gICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIEVycm9yT2JqZWN0KCkge1xuICB0aGlzLmVycm9yID0gbnVsbDtcbn1cblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBFcnJvck9iamVjdCgpO1xuXG5mdW5jdGlvbiB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgZXJyb3IgPSB1bmRlZmluZWQsXG4gICAgICBzdWNjZWVkZWQgPSB1bmRlZmluZWQsXG4gICAgICBmYWlsZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdmFsdWUgPSB0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICBfcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICBfcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIF9yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9yZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgIHRoaXMuX2VudW1lcmF0ZSgpO1xuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3JlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufTtcblxuRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB2YXIgX2lucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2VhY2hFbnRyeShfaW5wdXRbaV0sIGkpO1xuICB9XG59O1xuXG5FbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBpKSB7XG4gIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgdmFyIHJlc29sdmUkJCA9IGMucmVzb2x2ZTtcblxuICBpZiAocmVzb2x2ZSQkID09PSByZXNvbHZlKSB7XG4gICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocHJvbWlzZSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlJCQoZW50cnkpO1xuICAgICAgfSksIGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkKGVudHJ5KSwgaSk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiAoc3RhdGUsIGksIHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gUEVORElORykge1xuICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgX3JlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gIH1cbn07XG5cbkVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICBfcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBuZWVkc1Jlc29sdmVyKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTmV3KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xufVxuXG4vKipcbiAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgVGVybWlub2xvZ3lcbiAgLS0tLS0tLS0tLS1cblxuICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICBCYXNpYyBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tXG5cbiAgYGBganNcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBvbiBzdWNjZXNzXG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAvLyBvbiBmYWlsdXJlXG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgQWR2YW5jZWQgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgYGBganNcbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gIGBgYGpzXG4gIFByb21pc2UuYWxsKFtcbiAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0pO1xuICBgYGBcblxuICBAY2xhc3MgUHJvbWlzZVxuICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEBjb25zdHJ1Y3RvclxuKi9cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbmVlZHNSZXNvbHZlcigpO1xuICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgfVxufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcblByb21pc2UucmFjZSA9IHJhY2U7XG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5Qcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UuX2FzYXAgPSBhc2FwO1xuXG5Qcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFByb21pc2UsXG5cbiAgLyoqXG4gICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQ2hhaW5pbmdcbiAgICAtLS0tLS0tLVxuICBcbiAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgXG4gICAgYGBganNcbiAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICB9KTtcbiAgXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgfSk7XG4gICAgYGBgXG4gICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gIFxuICAgIGBgYGpzXG4gICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEFzc2ltaWxhdGlvblxuICAgIC0tLS0tLS0tLS0tLVxuICBcbiAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBTaW1wbGUgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCByZXN1bHQ7XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9XG4gICAgYGBgXG4gIFxuICAgIEVycmJhY2sgRXhhbXBsZVxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIFByb21pc2UgRXhhbXBsZTtcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgIC0tLS0tLS0tLS0tLS0tXG4gIFxuICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgXG4gICAgYGBgamF2YXNjcmlwdFxuICAgIGxldCBhdXRob3IsIGJvb2tzO1xuICBcbiAgICB0cnkge1xuICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgRXJyYmFjayBFeGFtcGxlXG4gIFxuICAgIGBgYGpzXG4gIFxuICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcbiAgXG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICBcbiAgICB9XG4gIFxuICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgUHJvbWlzZSBFeGFtcGxlO1xuICBcbiAgICBgYGBqYXZhc2NyaXB0XG4gICAgZmluZEF1dGhvcigpLlxuICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICB9KTtcbiAgICBgYGBcbiAgXG4gICAgQG1ldGhvZCB0aGVuXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIHRoZW46IHRoZW4sXG5cbiAgLyoqXG4gICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIFxuICAgIGBgYGpzXG4gICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgfVxuICBcbiAgICAvLyBzeW5jaHJvbm91c1xuICAgIHRyeSB7XG4gICAgICBmaW5kQXV0aG9yKCk7XG4gICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgfVxuICBcbiAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGNhdGNoXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgJ2NhdGNoJzogZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIHZhciBsb2NhbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgIGlmIChQKSB7XG4gICAgICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvY2FsLlByb21pc2UgPSBQcm9taXNlO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlLlByb21pc2UgPSBQcm9taXNlO1xuXG5yZXR1cm4gUHJvbWlzZTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDk2Nik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHZlcnR4IChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgcHV0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi4vYXBpcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiogbG9naW4oYWN0aW9uKSB7XG4gIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkIH0gPSBhY3Rpb24ucGF5bG9hZDtcblxuICB0cnkge1xuICAgIGNvbnN0IGF1dGggPSAoeWllbGQgYXBpLmxvZ2luKGVtYWlsLCBwYXNzd29yZCkpLnRvSlNPTigpO1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMucmVhZCh7IGVudGl0eTogJ3VzZXJzJywgdWlkOiBhdXRoLnVpZCB9KSk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuYXV0aG9yaXplKGF1dGgpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLm5vdGlmeUVycm9yKGVycikpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmF1dGhvcml6ZShuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyKSkpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIGxvZ291dCgpIHtcbiAgdHJ5IHtcbiAgICB5aWVsZCBhcGkubG9nb3V0KCk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMudW5hdXRob3JpemUoKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLm5vdGlmeUVycm9yKGVycikpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnVuYXV0aG9yaXplKG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlcnIpKSkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmVnaXN0ZXIoYWN0aW9uKSB7XG4gIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCB0eXBlIH0gPSBhY3Rpb24ucGF5bG9hZDtcblxuICB0cnkge1xuICAgIGNvbnN0IGF1dGggPSAoeWllbGQgYXBpLnJlZ2lzdGVyKGVtYWlsLCBwYXNzd29yZCkpLnRvSlNPTigpO1xuICAgIGNvbnN0IHVzZXIgPSB7IHVpZDogYXV0aC51aWQsIGVtYWlsLCB0eXBlIH07XG5cbiAgICB5aWVsZCBhcGkuc2F2ZSgndXNlcnMnLCB1c2VyKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5hdXRob3JpemUoYXV0aCkpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnVwZGF0ZUNhY2hlKHsgZW50aXR5OiAndXNlcnMnLCByZXNwb25zZTogeyBbdXNlci51aWRdOiB1c2VyIH0gfSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBlcnJvciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXJyKSk7XG4gICAgY29uc3QgbWVzc2FnZSA9ICdPY29ycmV1IHVtIGVycm8gYW8gdGVudGFyIHJlYWxpemFyIGEgYcOnw6NvIHNvbGljaXRhZGEuIFBvciBmYXZvciwgdGVudGUgbm92YW1lbnRlLic7XG5cbiAgICBjb25zb2xlLmVycm9yKGVyciwgZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5ub3RpZnlFcnJvcihlcnJvci5tZXNzYWdlIHx8IG1lc3NhZ2UpKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5hdXRob3JpemUoZXJyKSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3N0b3JlL3NhZ2FzL2F1dGguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmUgID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpXG4gICwgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHtzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNjU1KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZWZmZWN0cycpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZHV4LXNhZ2EvZWZmZWN0cy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmVkdXgtc2FnYS9lZmZlY3RzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE4MjIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC1zYWdhL2xpYi9lZmZlY3RzLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBmYiB9IGZyb20gJ34vY29uc3RhbnRzJztcbmltcG9ydCBnZW5VSUQgZnJvbSAnfi9oZWxwZXJzL2dlbi11aWQnO1xuXG5leHBvcnQgY29uc3Qgb25jZSA9IHJlZiA9PiBmYi5kYXRhYmFzZSgpLnJlZihyZWYpLm9uY2UoJ3ZhbHVlJyk7XG5leHBvcnQgY29uc3Qgc2V0ID0gKHJlZiwgZGF0YSkgPT4gZmIuZGF0YWJhc2UoKS5yZWYocmVmKS5zZXQoZGF0YSk7XG5cbmV4cG9ydCBjb25zdCBzYXZlID0gKHJlZiwgZGF0YSkgPT4ge1xuICBpZiAoIWRhdGEudWlkKSB7XG4gICAgZGF0YS51aWQgPSBnZW5VSUQocmVmKTtcbiAgfVxuXG4gIGlmICghZGF0YS5jcmVhdGVkQXQpIHtcbiAgICBkYXRhLmNyZWF0ZWRBdCA9IGZiLmRhdGFiYXNlLlNlcnZlclZhbHVlLlRJTUVTVEFNUDtcbiAgfVxuXG4gIGRhdGEudXBkYXRlZEF0ID0gZmIuZGF0YWJhc2UuU2VydmVyVmFsdWUuVElNRVNUQU1QO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0KGAke3JlZn0vJHtkYXRhLnVpZH1gLCBkYXRhKVxuICAgICAgLnRoZW4ob25jZShgJHtyZWZ9LyR7ZGF0YS51aWR9YCkpXG4gICAgICAudGhlbihyZXMgPT4gcmVzb2x2ZShyZXMudmFsKCkpKVxuICAgICAgLmNhdGNoKHJlamVjdCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IHJlZiA9PiBmYi5kYXRhYmFzZSgpLnJlZihyZWYpLnJlbW92ZSgpO1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb2ZpbGUgPSBkYXRhID0+IGZiLmF1dGgoKS5jdXJyZW50VXNlci51cGRhdGVQcm9maWxlKGRhdGEpO1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVBhc3N3b3JkID0gZGF0YSA9PiBmYi5hdXRoKCkuY3VycmVudFVzZXIudXBkYXRlUGFzc3dvcmQoZGF0YSk7XG5leHBvcnQgY29uc3QgbG9naW4gPSAoZW1haWwsIHBhc3N3b3JkKSA9PiBmYi5hdXRoKCkuc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKTtcbmV4cG9ydCBjb25zdCBsb2dvdXQgPSAoKSA9PiBmYi5hdXRoKCkuc2lnbk91dCgpO1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyID0gKGVtYWlsLCBwYXNzd29yZCkgPT5cbiAgZmIuYXV0aCgpLmNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvYXBpcy5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuUHJvbWlzZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNzA5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NDcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNjkxKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnByb21pc2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9wYXRjaCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWN0LWhvdC1sb2FkZXIvcGF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3JlYWN0LWhvdC1sb2FkZXIvcGF0Y2guanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTY1NCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NTYpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNzQyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NTMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNjYxKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTY1Nyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLWluc3RhbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE3NTgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNzU5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NjApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNjgwKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTc0MSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNjg4KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190YXNrLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTY4Nik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNjY1KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NzgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXtcbiAgICBpZihzYWZlICYmIHRhcmdldFtrZXldKXRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NTgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTY4Nyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNjU5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTY2Myk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTc2MSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlJztcblxuZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCh7XG4gIGFwaUtleTogJ0FJemFTeUF6VEhfUDczNW9WejJyNUFwZTVaRGpfbzlSU3p3bDRrMCcsXG4gIGF1dGhEb21haW46ICdhZ2VuY2lhLWFtaWdhLmZpcmViYXNlYXBwLmNvbScsXG4gIGRhdGFiYXNlVVJMOiAnaHR0cHM6Ly9hZ2VuY2lhLWFtaWdhLmZpcmViYXNlaW8uY29tJyxcbiAgc3RvcmFnZUJ1Y2tldDogJ2FnZW5jaWEtYW1pZ2EuYXBwc3BvdC5jb20nLFxuICBtZXNzYWdpbmdTZW5kZXJJZDogJzMyMzQ0NzI5NzkyNicsXG59KTtcblxuZXhwb3J0IGNvbnN0IGZiID0gZmlyZWJhc2U7XG5cbmV4cG9ydCBjb25zdCBDYWNoZSA9IHtcbiAgS0VZOiAnQUdFTkNJQV9BTUlHQV9TVEFURScsXG59O1xuXG5leHBvcnQgY29uc3QgRmlsdGVyID0ge1xuICBPUFRJT05TOiBbXG4gICAgeyB0ZXh0OiAnVm9sdW50w6FyaW9zJywgdmFsdWU6ICd1c2VycycsIGljb246ICd1c2VyJyB9LFxuICAgIHsgdGV4dDogJ09yZ2FuaXphw6fDtWVzJywgdmFsdWU6ICdvcmdhbml6YXRpb25zJywgaWNvbjogJ3VuaXZlcnNpdHknIH0sXG4gICAgeyB0ZXh0OiAnU2VydmnDp29zJywgdmFsdWU6ICdzZXJ2aWNlcycsIGljb246ICd3cmVuY2gnIH0sXG4gICAgeyB0ZXh0OiAnQ2FtcGFuaGFzJywgdmFsdWU6ICdjYW1wYWlnbnMnLCBpY29uOiAnYnVsbGhvcm4nIH0sXG4gIF0sXG59O1xuXG53aW5kb3cuZmIgPSBmYjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL2NvbnN0YW50cy5qcyIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDIxNjcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9maXJlYmFzZS9maXJlYmFzZS1icm93c2VyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBmYiB9IGZyb20gJ34vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgcmVmID0+IGZiLmRhdGFiYXNlKCkucmVmKCkuY2hpbGQocmVmKS5wdXNoKCkua2V5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvaGVscGVycy9nZW4tdWlkLmpzIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHB1dCwgc2VsZWN0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnLi4vc2VsZWN0b3JzJztcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi4vYXBpcyc7XG5cbmNvbnN0IGF0dHJzID0ge1xuICB1c2VyczogWydza2lsbHMnLCAnc2VydmljZXMnLCAnY2FtcGFpZ25zJ10sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24qIHJlYWQoYWN0aW9uKSB7XG4gIGNvbnN0IHsgdWlkLCBlbnRpdHkgfSA9IGFjdGlvbi5wYXlsb2FkIHx8IHt9O1xuXG4gIHRyeSB7XG4gICAgY29uc3Qgc25hcHNob3QgPSB5aWVsZCBhcGkub25jZSh1aWQgPyBgJHtlbnRpdHl9LyR7dWlkfWAgOiBlbnRpdHkpO1xuICAgIGNvbnN0IHZhbCA9IHNuYXBzaG90LnZhbCgpO1xuXG4gICAgaWYgKGF0dHJzW2VudGl0eV0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBhdHRyOyAoYXR0ciA9IGF0dHJzW2VudGl0eV1baV0pOyBpKyspIHtcbiAgICAgICAgaWYgKHNuYXBzaG90Lmhhc0NoaWxkKGF0dHIpKSB7XG4gICAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgICAgY29uc3Qgc25hcCA9IHlpZWxkIGFwaS5vbmNlKGF0dHIpO1xuXG4gICAgICAgICAgXy5mb3JFYWNoKHZhbFthdHRyXSwgKGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAoc25hcC5oYXNDaGlsZChpZCkpIHtcbiAgICAgICAgICAgICAgcmVzW2lkXSA9IHNuYXAuY2hpbGQoaWQpLnZhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgeWllbGQgcHV0KGFjdGlvbnMudXBkYXRlQ2FjaGUoeyBlbnRpdHk6IGF0dHIsIHJlc3BvbnNlOiByZXMgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMudXBkYXRlQ2FjaGUoeyBlbnRpdHksIHJlc3BvbnNlOiB1aWQgPyB7IFt1aWRdOiB2YWwgfSA6IHZhbCB9KSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGVycm9yID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlcnIpKTtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IuY29kZSA9PT0gJ1BFUk1JU1NJT05fREVOSUVEJyA/XG4gICAgICAnU3VhIHNlc3PDo28gZXhwaXJvdS4gUG9yIGZhdm9yLCBmYcOnYSBsb2dpbiBub3ZhbWVudGUnIDpcbiAgICAgICdPY29ycmV1IHVtIGVycm8gYW8gdGVudGFyIHJlYWxpemFyIGEgYcOnw6NvIHNvbGljaXRhZGEuIFBvciBmYXZvciwgdGVudGUgbm92YW1lbnRlLic7XG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5ub3RpZnlFcnJvcihlcnJvci5tZXNzYWdlIHx8IG1lc3NhZ2UpKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy51cGRhdGVDYWNoZShlcnIpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlbW92ZShhY3Rpb24pIHtcbiAgY29uc3QgeyBlbnRpdHksIHVpZCB9ID0gYWN0aW9uLnBheWxvYWQ7XG5cbiAgdHJ5IHtcbiAgICB5aWVsZCBhcGkucmVtb3ZlKGAke2VudGl0eX0vJHt1aWR9YCk7XG5cbiAgICBpZiAoZW50aXR5ID09PSAnc2VydmljZXMnIHx8IGVudGl0eSA9PT0gJ2NhbXBhaWducycpIHtcbiAgICAgIGxldCB1c2VyID0geWllbGQgc2VsZWN0KHNlbGVjdG9ycy5nZXRVc2VyKTtcblxuICAgICAgdXNlciA9IF8ubWVyZ2Uoe30sIHVzZXIpO1xuICAgICAgZGVsZXRlIHVzZXJbZW50aXR5XVt1aWRdO1xuICAgICAgdXNlciA9IHlpZWxkIGFwaS5zYXZlKCd1c2VycycsIHVzZXIpO1xuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy51cGRhdGVDYWNoZSh7IGVudGl0eTogJ3VzZXJzJywgcmVzcG9uc2U6IHsgW3VzZXIudWlkXTogdXNlciB9IH0pKTtcbiAgICB9XG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZW1vdmVDYWNoZSh7IGVudGl0eSwgdWlkIH0pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLm5vdGlmeUVycm9yKGVycikpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnJlbW92ZUNhY2hlKGVycikpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2F2ZShhY3Rpb24pIHtcbiAgY29uc3QgeyByZWYsIGRhdGEgfSA9IGFjdGlvbi5wYXlsb2FkIHx8IHt9O1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0geWllbGQgYXBpLnNhdmUocmVmLCBkYXRhKTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnVwZGF0ZUNhY2hlKHsgZW50aXR5OiByZWYsIHJlc3BvbnNlOiB7IFtyZXMudWlkXTogcmVzIH0gfSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgeWllbGQgcHV0KGFjdGlvbnMubm90aWZ5RXJyb3IoZXJyKSk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZShlcnIpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2FnYXMvZW50aXRpZXMuanMiLCJpbXBvcnQgKiBhcyBhdXRoIGZyb20gJy4vYXV0aCc7XG5pbXBvcnQgKiBhcyBlbnRpdGllcyBmcm9tICcuL2VudGl0aWVzJztcbmltcG9ydCAqIGFzIGdsb2JhbCBmcm9tICcuL2dsb2JhbCc7XG5pbXBvcnQgKiBhcyBmaWx0ZXIgZnJvbSAnLi9maWx0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC4uLmF1dGgsXG4gIC4uLmVudGl0aWVzLFxuICAuLi5nbG9iYWwsXG4gIC4uLmZpbHRlcixcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9zdG9yZS9zZWxlY3RvcnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxNzIwKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHMuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0JztcbmltcG9ydCBjcmVhdGVHZXREYXRhIGZyb20gJ34vaGVscGVycy9jcmVhdGUtZ2V0LWRhdGEnO1xuaW1wb3J0IHsgZ2V0RW50aXRpZXNCeUlkcyB9IGZyb20gJy4vZW50aXRpZXMnO1xuXG5jb25zdCBnZXREYXRhID0gY3JlYXRlR2V0RGF0YSgnYXV0aCcpO1xuXG5leHBvcnQgY29uc3QgZ2V0QXV0aCA9IGdldERhdGEoJ2F1dGhEYXRhJyk7XG5cbmV4cG9ydCBjb25zdCBnZXRVc2VyID0gY3JlYXRlU2VsZWN0b3IoXG4gIGdldEF1dGgsXG4gIHN0YXRlID0+IGdldEVudGl0aWVzQnlJZHMoJ3VzZXJzJywgXywgc3RhdGUpLFxuICAoYXV0aCwgZm5HZXRVc2VyKSA9PiBmbkdldFVzZXIoW2F1dGgudWlkXSlbYXV0aC51aWRdLFxuKTtcblxuZXhwb3J0IGNvbnN0IGlzUmVnaXN0ZXJpbmcgPSBnZXREYXRhKCdpc1JlZ2lzdGVyaW5nJyk7XG5leHBvcnQgY29uc3QgaXNBdXRoZW50aWNhdGluZyA9IGdldERhdGEoJ2lzQXV0aGVudGljYXRpbmcnKTtcbmV4cG9ydCBjb25zdCBpc0F1dGhlbnRpY2F0ZWQgPSBjcmVhdGVTZWxlY3RvcihnZXRBdXRoLCBhdXRoID0+ICFfLmlzRW1wdHkoYXV0aCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2VsZWN0b3JzL2F1dGguanMiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxODI0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjdXJyeSwgZ2V0IH0gZnJvbSAnbG9kYXNoJztcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlck5hbWUgPT4gY3VycnkoKGF0dHIsIHN0YXRlKSA9PiBnZXQoc3RhdGVbcmVkdWNlck5hbWVdLCBhdHRyKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9oZWxwZXJzL2NyZWF0ZS1nZXQtZGF0YS5qcyIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG4vLyBpbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0JztcbmltcG9ydCBjcmVhdGVHZXREYXRhIGZyb20gJ34vaGVscGVycy9jcmVhdGUtZ2V0LWRhdGEnO1xuXG5jb25zdCBnZXREYXRhID0gY3JlYXRlR2V0RGF0YSgnZW50aXRpZXMnKTtcblxuZXhwb3J0IGNvbnN0IGlzRmV0Y2hpbmcgPSBlbnRpdHkgPT4gZ2V0RGF0YShgaXNGZXRjaGluZy4ke2VudGl0eX1gKTtcbmV4cG9ydCBjb25zdCBpc1JlbW92aW5nID0gKGVudGl0eSwgaWQpID0+IGdldERhdGEoYGlzUmVtb3ZpbmcuJHtlbnRpdHl9LiR7aWR9YCk7XG5leHBvcnQgY29uc3QgZ2V0RW50aXRpZXMgPSBlbnRpdHkgPT4gZ2V0RGF0YShgYnlJZC4ke2VudGl0eX1gKTtcbmV4cG9ydCBjb25zdCBnZXRFbnRpdHkgPSAoZW50aXR5LCBpZCkgPT4gZ2V0RGF0YShgYnlJZC4ke2VudGl0eX0uJHtpZH1gKTtcblxuZXhwb3J0IGNvbnN0IGdldEVudGl0aWVzQnlJZHMgPSBfLmN1cnJ5KChlbnRpdHksIGlkcywgc3RhdGUpID0+XG4gIGlkcy5yZWR1Y2UoKGVudGl0aWVzLCBpZCkgPT4ge1xuICAgIGVudGl0aWVzW2lkXSA9IGdldEVudGl0eShlbnRpdHksIGlkKShzdGF0ZSkgfHwge307XG4gICAgcmV0dXJuIGVudGl0aWVzO1xuICB9LCB7fSksXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2VsZWN0b3JzL2VudGl0aWVzLmpzIiwiZXhwb3J0IGNvbnN0IGlzTG9hZGluZ1N0YXRlID0gc3RhdGUgPT4gc3RhdGUuYXN5bmNTdGF0ZS5sb2FkaW5nO1xuZXhwb3J0IGNvbnN0IGlzVXBkYXRpbmdQcm9maWxlID0gc3RhdGUgPT4gc3RhdGUuZ2xvYmFsLmlzVXBkYXRpbmdQcm9maWxlO1xuXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFRhYkZlZWQgPSBzdGF0ZSA9PiBzdGF0ZS5nbG9iYWwuY3VycmVudFRhYkZlZWQ7XG5leHBvcnQgY29uc3QgZ2V0Tm90aWZpY2F0aW9uID0gc3RhdGUgPT4gc3RhdGUuZ2xvYmFsLm5vdGlmaWNhdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3N0b3JlL3NlbGVjdG9ycy9nbG9iYWwuanMiLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxhdGluaXplIGZyb20gJ2xhdGluaXplJztcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuLy8gaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnfi9jb25zdGFudHMnO1xuaW1wb3J0IGNyZWF0ZUdldERhdGEgZnJvbSAnfi9oZWxwZXJzL2NyZWF0ZS1nZXQtZGF0YSc7XG5pbXBvcnQgeyBnZXRFbnRpdGllcyB9IGZyb20gJy4vZW50aXRpZXMnO1xuXG5jb25zdCBfZ2V0RGF0YSA9IGNyZWF0ZUdldERhdGEoJ2ZpbHRlcicpO1xuXG5jb25zdCBmb3JtYXQgPSBkYXRhID0+ICh7XG4gIHRpdGxlOiBkYXRhLm5hbWUsXG4gIG1ldGE6IGRhdGEuZW1haWwsXG4gIGltYWdlOiBkYXRhLmltYWdlLFxuICBkZXNjcmlwdGlvbjogZGF0YS5yZXN1bWUgfHwgZGF0YS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgY3JlYXRlZF9hdDogZGF0YS5jcmVhdGVkX2F0LFxufSk7XG5cbmV4cG9ydCBjb25zdCBpc0ZpbHRlcmluZyA9IF9nZXREYXRhKCdpc0ZpbHRlcmluZycpO1xuZXhwb3J0IGNvbnN0IGdldFF1ZXJ5RmlsdGVyID0gX2dldERhdGEoJ3F1ZXJ5Jyk7XG5leHBvcnQgY29uc3QgZ2V0RW50aXR5RmlsdGVyID0gX2dldERhdGEoJ2VudGl0eScpO1xuZXhwb3J0IGNvbnN0IGdldFNraWxsc0ZpbHRlciA9IF9nZXREYXRhKCdza2lsbHMnKTtcblxuZXhwb3J0IGNvbnN0IGdldFJlc3VsdHMgPSBjcmVhdGVTZWxlY3RvcihcbiAgZ2V0UXVlcnlGaWx0ZXIsXG4gIGdldEVudGl0eUZpbHRlcixcbiAgZ2V0U2tpbGxzRmlsdGVyLFxuICBzdGF0ZSA9PiBfLmN1cnJ5KGdldEVudGl0aWVzKShfLCBzdGF0ZSksXG4gIChxdWVyeSwgZW50aXR5LCBza2lsbHMsIGVudGl0eU5hbWVzLCBmbkdldEVudGl0aWVzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuXG4gICAgXy5mb3JFYWNoKGZuR2V0RW50aXRpZXMoZW50aXR5KSwgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gKFxuICAgICAgICBsYXRpbml6ZShpdGVtLnRpdGxlKS50b0xvd2VyQ2FzZSgpLnNlYXJjaChxdWVyeSkgIT09IC0xICYmXG4gICAgICAgICghc2tpbGxzLmxlbmd0aCB8fCBfLmludGVyc2VjdGlvbihfLnZhbHVlcyhpdGVtLnNraWxscyksIHNraWxscykubGVuZ3RoKVxuICAgICAgKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJlc3VsdHNbaXRlbS51aWRdID0gZm9ybWF0KGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0sXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2VsZWN0b3JzL2ZpbHRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDIxODIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9sYXRpbml6ZS9sYXRpbml6ZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHB1dCwgc2VsZWN0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnLi4vc2VsZWN0b3JzJztcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQgKiBhcyBhcGkgZnJvbSAnLi4vYXBpcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiogdXBkYXRlKHsgcGF5bG9hZCB9KSB7XG4gIGNvbnN0IHsgcGFzc3dvcmQsIC4uLnVzZXJEYXRhIH0gPSBwYXlsb2FkO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IHlpZWxkIGFwaS5zYXZlKCd1c2VycycsIHVzZXJEYXRhKTtcblxuICAgIHlpZWxkIGFwaS51cGRhdGVQcm9maWxlKHsgZGlzcGxheU5hbWU6IHBheWxvYWQubmFtZSB9KTtcblxuICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgeWllbGQgYXBpLnVwZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5ub3RpZnkoJ0RhZG9zIGF0dWFsaXphZG9zIScpKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy51cGRhdGVDYWNoZSh7IGVudGl0eTogJ3VzZXJzJywgcmVzcG9uc2U6IHsgW3VzZXIudWlkXTogdXNlciB9IH0pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLm5vdGlmeUVycm9yKGVycikpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnVwZGF0ZUNhY2hlKGVycikpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogYWRkVG9PcmcoeyBwYXlsb2FkOiB7IGRhdGEsIGVudGl0eSB9IH0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0geWllbGQgc2VsZWN0KHNlbGVjdG9ycy5nZXRVc2VyKTtcbiAgICBjb25zdCByZXMgPSB5aWVsZCBhcGkuc2F2ZShlbnRpdHksIGRhdGEpO1xuICAgIGNvbnN0IHZhbCA9IHlpZWxkIGFwaS5zYXZlKCd1c2VycycsIF8ubWVyZ2Uoe30sIHVzZXIsIHtcbiAgICAgIFtlbnRpdHldOiB7IFtyZXMudWlkXTogcmVzLnVpZCB9LFxuICAgIH0pKTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnVwZGF0ZUNhY2hlKHsgZW50aXR5LCByZXNwb25zZTogeyBbcmVzLnVpZF06IHJlcyB9IH0pKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy51cGRhdGVDYWNoZSh7IGVudGl0eTogJ3VzZXJzJywgcmVzcG9uc2U6IHsgW3ZhbC51aWRdOiB2YWwgfSB9KSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUubG9nKGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5ub3RpZnlFcnJvcihlcnIpKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy51cGRhdGVDYWNoZShlcnIpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvc2FnYXMvcHJvZmlsZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NDEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBsb2NhbGZvcmFnZSBmcm9tICdsb2NhbGZvcmFnZSc7XG5pbXBvcnQgeyBDYWNoZSB9IGZyb20gJ34vY29uc3RhbnRzJztcblxuZXhwb3J0IGNvbnN0IGxvYWRTdGF0ZSA9IGN1cnJlbnRTdGF0ZSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICBsb2NhbGZvcmFnZS5nZXRJdGVtKENhY2hlLktFWSwgKGVyciwgc3RhdGUgPSB7fSkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb2x2ZShtZXJnZSh7fSwgY3VycmVudFN0YXRlLCBzdGF0ZSkpO1xuICB9KTtcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2F2ZVN0YXRlID0gKHN0YXRlKSA9PiB7XG4gIGxvY2FsZm9yYWdlLnNldEl0ZW0oQ2FjaGUuS0VZLCBzdGF0ZSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvc3RvcmUvY2FjaGUtc3RhdGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgyMTgzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvbG9jYWxmb3JhZ2UvZGlzdC9sb2NhbGZvcmFnZS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY3JlYXRlRGV2VG9vbHMgfSBmcm9tICdyZWR1eC1kZXZ0b29scyc7XG5pbXBvcnQgTG9nTW9uaXRvciBmcm9tICdyZWR1eC1kZXZ0b29scy1sb2ctbW9uaXRvcic7XG5pbXBvcnQgRG9ja01vbml0b3IgZnJvbSAncmVkdXgtZGV2dG9vbHMtZG9jay1tb25pdG9yJztcblxuZXhwb3J0IGNvbnN0IERldlRvb2xzID0gY3JlYXRlRGV2VG9vbHMoXG4gIDxEb2NrTW9uaXRvclxuICAgIGZsdWlkXG4gICAgZGVmYXVsdFNpemU9ezF9XG4gICAgY2hhbmdlUG9zaXRpb25LZXk9XCJjdHJsLXNoaWZ0LXlcIlxuICAgIHRvZ2dsZVZpc2liaWxpdHlLZXk9XCJjdHJsLXNoaWZ0LWhcIlxuICA+XG4gICAgPExvZ01vbml0b3IgLz5cbiAgPC9Eb2NrTW9uaXRvcj4sXG4pO1xuXG5leHBvcnQgY29uc3Qgc2hvd0RldlRvb2xzID0gKHN0b3JlOiBhbnkpID0+IHtcbiAgY29uc3QgcG9wdXAgPSB3aW5kb3cub3BlbihudWxsLCAnUmVkdXggRGV2VG9vbHMnLCAnbWVudWJhcj1ubyxsb2NhdGlvbj1ubyxyZXNpemFibGU9eWVzLHNjcm9sbGJhcnM9bm8sc3RhdHVzPW5vJyk7XG5cbiAgLy8gUmVsb2FkIGluIGNhc2UgaXQgYWxyZWFkeSBleGlzdHNcbiAgcG9wdXAubG9jYXRpb24ucmVsb2FkKCk7XG5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgcG9wdXAuZG9jdW1lbnQud3JpdGUoJzxkaXYgaWQ9XCJyZWFjdC1kZXZ0b29scy1yb290XCI+PC9kaXY+Jyk7XG4gICAgUmVhY3RET00ucmVuZGVyKDxEZXZUb29scyBzdG9yZT17c3RvcmV9IC8+LCBwb3B1cC5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVhY3QtZGV2dG9vbHMtcm9vdCcpKTtcbiAgfSwgMTApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL2RldnRvb2xzLmpzeCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE1NjMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC1kZXZ0b29scy9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE1ODkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC1kZXZ0b29scy1sb2ctbW9uaXRvci9saWIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE3ODApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWR1eC1kZXZ0b29scy1kb2NrLW1vbml0b3IvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBCcm93c2VyUm91dGVyLCBNYXRjaCB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgTWFpbiBmcm9tICcuL3ZpZXdzL2NvbnRhaW5lcnMvbWFpbic7XG5cbmNvbnN0IEFwcGxpY2F0aW9uID0gKHsgc3RvcmUgfSkgPT4gKFxuICA8UHJvdmlkZXIgc3RvcmU9e3N0b3JlfT5cbiAgICA8QnJvd3NlclJvdXRlcj5cbiAgICAgIDxNYXRjaCBwYXR0ZXJuPVwiL1wiIGNvbXBvbmVudD17TWFpbn0gLz5cbiAgICA8L0Jyb3dzZXJSb3V0ZXI+XG4gIDwvUHJvdmlkZXI+XG4pO1xuXG5BcHBsaWNhdGlvbi5wcm9wVHlwZXMgPSB7XG4gIHN0b3JlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQXBwbGljYXRpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy9hcHBsaWNhdGlvbi5qc3giLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMzQ1KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMzc0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgTWF0Y2ggfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IHJlcXVpcmVBdXRoIGZyb20gJ34vaGVscGVycy9yZXF1aXJlLWF1dGgnO1xuaW1wb3J0ICogYXMgYWN0aW9uQ3JlYXRvcnMgZnJvbSAnfi9zdG9yZS9hY3Rpb25zJztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuaW1wb3J0IEZlZWQgZnJvbSAnfi92aWV3cy9jb250ZW50L2ZlZWQnO1xuaW1wb3J0IEJ1c2NhciBmcm9tICd+L3ZpZXdzL2NvbnRlbnQvYnVzY2FyJztcbmltcG9ydCBDYW1wYW5oYSBmcm9tICd+L3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEnO1xuaW1wb3J0IE9yZ2FuaXphY2FvIGZyb20gJ34vdmlld3MvY29udGVudC9vcmdhbml6YWNhbyc7XG5pbXBvcnQgU2VydmljbyBmcm9tICd+L3ZpZXdzL2NvbnRlbnQvc2Vydmljbyc7XG5pbXBvcnQgVXN1YXJpbyBmcm9tICd+L3ZpZXdzL2NvbnRlbnQvdXN1YXJpbyc7XG5pbXBvcnQgTG9naW4gZnJvbSAnLi9sb2dpbic7XG5pbXBvcnQgTm90aWZpY2F0aW9uIGZyb20gJy4vbm90aWZpY2F0aW9uJztcbmltcG9ydCBUb3BCYXIgZnJvbSAnLi90b3BiYXInO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL21haW4uc2Nzcyc7XG5cbmNsYXNzIE1haW4gZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY3Rpb25zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGF1dGg6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgaGFzU2tpbGxzOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBpc0xvZ2dlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaXNMb2FkaW5nU3RhdGU6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHVzZXI6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIH07XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh7IGFjdGlvbnMsIGF1dGgsIGhhc1NraWxscywgaXNMb2dnZWQsIHVzZXIgfSkge1xuICAgIGlmICghaXNMb2dnZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1NraWxscykge1xuICAgICAgYWN0aW9ucy5yZWFkKHsgZW50aXR5OiAnc2tpbGxzJyB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZXIuaWQpIHtcbiAgICAgIGFjdGlvbnMucmVhZCh7IGVudGl0eTogJ3VzZXJzJywgdWlkOiBhdXRoLnVpZCB9KTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpc0xvZ2dlZCwgaXNMb2FkaW5nU3RhdGUsIHVzZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoaXNMb2FkaW5nU3RhdGUgfHwgIXVzZXIuaWQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxGbGV4RWxlbWVudCBjb2x1bW4gZnVsbCBhbGlnbj1cImNlbnRlclwiIGp1c3RpZnk9XCJjZW50ZXJcIiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgICA8TG9hZGVyIGFjdGl2ZT5cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGNvbG9yOiAncmdiYSgwLDAsMCwgMC40NSknIH19PlxuICAgICAgICAgICAgICBDYXJyZWdhbmRvIG8gc2lzdGVtYS4uLlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvTG9hZGVyPlxuICAgICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICAgICAgPE5vdGlmaWNhdGlvbiAvPlxuICAgICAgICB7aXNMb2dnZWQgJiYgPFRvcEJhciAvPn1cbiAgICAgICAgPEZsZXhFbGVtZW50IGZ1bGwgY2xhc3NOYW1lPXtzdHlsZXMuY29udGVudH0+XG4gICAgICAgICAgPE1hdGNoIHBhdHRlcm49XCIvXCIgZXhhY3RseSBjb21wb25lbnQ9e3JlcXVpcmVBdXRoKEZlZWQpfSAvPlxuICAgICAgICAgIDxNYXRjaCBwYXR0ZXJuPVwiL2xvZ2luXCIgY29tcG9uZW50PXtMb2dpbn0gLz5cbiAgICAgICAgICA8TWF0Y2ggcGF0dGVybj1cIi9idXNjYXJcIiBjb21wb25lbnQ9e3JlcXVpcmVBdXRoKEJ1c2Nhcil9IC8+XG4gICAgICAgICAgPE1hdGNoIHBhdHRlcm49XCIvY2FtcGFuaGFzLzppZFwiIGNvbXBvbmVudD17cmVxdWlyZUF1dGgoQ2FtcGFuaGEpfSAvPlxuICAgICAgICAgIDxNYXRjaCBwYXR0ZXJuPVwiL29yZ2FuaXphY29lcy86aWRcIiBjb21wb25lbnQ9e3JlcXVpcmVBdXRoKE9yZ2FuaXphY2FvKX0gLz5cbiAgICAgICAgICA8TWF0Y2ggcGF0dGVybj1cIi92b2x1bnRhcmlvcy86aWRcIiBjb21wb25lbnQ9e3JlcXVpcmVBdXRoKFVzdWFyaW8pfSAvPlxuICAgICAgICAgIDxNYXRjaCBwYXR0ZXJuPVwiL3NlcnZpY29zLzppZFwiIGNvbXBvbmVudD17cmVxdWlyZUF1dGgoU2Vydmljbyl9IC8+XG4gICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gc3RhdGUgPT4gKHtcbiAgaGFzU2tpbGxzOiAhaXNFbXB0eShzZWxlY3RvcnMuZ2V0RW50aXRpZXMoc3RhdGUsICdza2lsbHMnKSksXG4gIGlzTG9nZ2VkOiBzZWxlY3RvcnMuaXNBdXRoZW50aWNhdGVkKHN0YXRlKSxcbiAgaXNMb2FkaW5nU3RhdGU6IHNlbGVjdG9ycy5pc0xvYWRpbmdTdGF0ZShzdGF0ZSksXG4gIGF1dGg6IHNlbGVjdG9ycy5nZXRBdXRoKHN0YXRlKSxcbiAgdXNlcjogc2VsZWN0b3JzLmdldFVzZXIoc3RhdGUpLFxufSk7XG5cbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGRpc3BhdGNoID0+ICh7XG4gIGFjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMpKE1haW4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGFpbmVycy9tYWluLmpzeCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE3ODcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NDIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE3OTQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDE2NDMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTcxMik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTgyNSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3NlbWFudGljLXVpLXJlYWN0L2Rpc3QvY29tbW9uanMvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgUmVkaXJlY3QgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5cbmNvbnN0IHJlcXVpcmVBdXRoID0gKENvbXBvc2VkQ29tcG9uZW50KSA9PiB7XG4gIGNvbnN0IEF1dGggPSAoeyBpc0F1dGhvcml6ZWQsIC4uLm90aGVyUHJvcHMgfSkgPT4gKFxuICAgIGlzQXV0aG9yaXplZCA/XG4gICAgICA8Q29tcG9zZWRDb21wb25lbnQgey4uLm90aGVyUHJvcHN9IC8+IDpcbiAgICAgIDxSZWRpcmVjdFxuICAgICAgICB0bz17e1xuICAgICAgICAgIHBhdGhuYW1lOiAnL2xvZ2luJyxcbiAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IChvdGhlclByb3BzLmxvY2F0aW9uIHx8IHt9KS5wYXRobmFtZSA9PT0gJy9sb2dpbicgP1xuICAgICAgICAgICAgICAoKG90aGVyUHJvcHMubG9jYXRpb24gfHwge30pLnN0YXRlIHx8IHt9KS5yZWRpcmVjdCA6XG4gICAgICAgICAgICAgIG90aGVyUHJvcHMubG9jYXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICk7XG5cbiAgQXV0aC5wcm9wVHlwZXMgPSB7XG4gICAgaXNBdXRob3JpemVkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgfTtcblxuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBzdGF0ZSA9PiAoe1xuICAgIGlzQXV0aG9yaXplZDogc2VsZWN0b3JzLmlzQXV0aGVudGljYXRlZChzdGF0ZSksXG4gIH0pO1xuXG4gIHJldHVybiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcykoQXV0aCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCByZXF1aXJlQXV0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL2hlbHBlcnMvcmVxdWlyZS1hdXRoLmpzIiwiaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJy4vZmxleC1lbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgRmxleEVsZW1lbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudC9pbmRleC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY24gZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgY25hbWVzIGZyb20gJ34vaGVscGVycy9jbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL2ZsZXgtZWxlbWVudC5zY3NzJztcbmltcG9ydCBEZWZhdWx0UHJvcHMgZnJvbSAnLi4vZGVmYXVsdC1wcm9wcyc7XG5cbmNsYXNzIEZsZXhFbGVtZW50IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLi4uRGVmYXVsdFByb3BzLnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIEFsaW5oYW1lbnRvIGRvcyBlbGVtZW50b3MgZmlsaG9zLlxuICAgICAqL1xuICAgIGFsaWduOiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoW1xuICAgICAgJ2Jhc2VsaW5lJywgJ2NlbnRlcicsICdmbGV4LWVuZCcsICdmbGV4LXN0YXJ0JyxcbiAgICAgICdpbmhlcml0JywgJ2luaXRpYWwnLCAnc3RyZXRjaCcsXG4gICAgXSksXG5cbiAgICAvKipcbiAgICAgKiBTZSBvIGVsZW1lbnRvIHBvc3N1aSBgZGlyZWN0aW9uOiBjb2x1bW5gLlxuICAgICAqL1xuICAgIGNvbHVtbjogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBTZSBvIGVsZW1lbnRvIHBvc3N1aSBgZmxleDogMWAuXG4gICAgICovXG4gICAgZnVsbDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBFc3Bhw6dhbWVudG8gZW50cmUgb3MgZWxlbWVudG9zIGZpbGhvcy5cbiAgICAgKi9cbiAgICBqdXN0aWZ5OiBSZWFjdC5Qcm9wVHlwZXMub25lT2YoW1xuICAgICAgJ2NlbnRlcicsICdmbGV4LWVuZCcsICdmbGV4LXN0YXJ0JyxcbiAgICAgICdpbmhlcml0JywgJ2luaXRpYWwnLCAnc3BhY2UtYXJvdW5kJywgJ3NwYWNlLWJldHdlZW4nLFxuICAgIF0pLFxuXG4gICAgLyoqXG4gICAgICogU2UgbyBlbGVtZW50byBwb3NzdWkgYGZsZXgtZGlyZWN0aW9uOiByb3dgLlxuICAgICAqL1xuICAgIHJvdzogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG5cbiAgICBvbkNsaWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIC4uLkRlZmF1bHRQcm9wcy5kZWZhdWx0UHJvcHMsXG4gIH07XG5cbiAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgIGNvbnN0IGNsYXNzZXMgPSB7XG4gICAgICBmbGV4OiB0cnVlLFxuICAgICAgY29sdW1uOiB0aGlzLnByb3BzLmNvbHVtbixcbiAgICAgIGRpc2FibGVkOiB0aGlzLnByb3BzLmRpc2FibGVkLFxuICAgICAgZnVsbDogdGhpcy5wcm9wcy5mdWxsLFxuICAgICAgcm93OiAhdGhpcy5wcm9wcy5jb2x1bW4sXG4gICAgICBbYGFsaWduLSR7dGhpcy5wcm9wcy5hbGlnbn1gXTogISF0aGlzLnByb3BzLmFsaWduLFxuICAgICAgW2BqdXN0aWZ5LSR7dGhpcy5wcm9wcy5qdXN0aWZ5fWBdOiAhIXRoaXMucHJvcHMuanVzdGlmeSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNuKFxuICAgICAgeyBbdGhpcy5wcm9wcy5jbGFzc05hbWVdOiB0aGlzLnByb3BzLmNsYXNzTmFtZSB9LFxuICAgICAgY25hbWVzKHN0eWxlcywgY2xhc3NlcyksXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBjb21wb25lbnQsIGlubmVyUmVmLCBzdHlsZSwgb25DbGljayB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBwcm9wcyA9IHsgcmVmOiBpbm5lclJlZiwgc3R5bGUsIGNsYXNzTmFtZTogdGhpcy5nZXRDbGFzc05hbWUoKSwgb25DbGljayB9O1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcywgY2hpbGRyZW4pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZsZXhFbGVtZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQvZmxleC1lbGVtZW50LmpzeCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMikpKDEpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgY24gZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChzdHlsZXMsIC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgYXJncy5mb3JFYWNoKChhcmcpID0+IHtcbiAgICBjb25zdCBjbGFzc2VzID0gY24oYXJnKTtcblxuICAgIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKChjbmFtZSkgPT4ge1xuICAgICAgaWYgKHN0eWxlc1tjbmFtZV0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc3R5bGVzW2NuYW1lXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuam9pbignICcpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL2hlbHBlcnMvY25hbWVzLmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2ZsZXgtZWxlbWVudC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vZmxleC1lbGVtZW50LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2ZsZXgtZWxlbWVudC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudC9mbGV4LWVsZW1lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQvZmxleC1lbGVtZW50LnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZmxleC1lbGVtZW50X19mbGV4X18zbjFHOUV2amFDIHtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLmZsZXgtZWxlbWVudF9fY29sdW1uX18yeGZjNlFXVnRsIHtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXG4gICAgICAtbXMtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgfVxcblxcbi5mbGV4LWVsZW1lbnRfX3Jvd19fM2xjM2RaMTRaMiB7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IGhvcml6b250YWw7XFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXG4gICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdzsgfVxcblxcbi5mbGV4LWVsZW1lbnRfX3dyYXBfXzJWMEpPVlUxanYge1xcbiAgLW1zLWZsZXgtd3JhcDogd3JhcDtcXG4gICAgICBmbGV4LXdyYXA6IHdyYXA7IH1cXG5cXG4uZmxleC1lbGVtZW50X19mdWxsX18xNVI4SVh3dDRNIHtcXG4gIC13ZWJraXQtYm94LWZsZXg6IDE7XFxuICAgICAgLW1zLWZsZXg6IDE7XFxuICAgICAgICAgIGZsZXg6IDE7IH1cXG5cXG4uZmxleC1lbGVtZW50X19kaXNhYmxlZF9fYUluTC1najhoMCB7XFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgb3BhY2l0eTogMC42OyB9XFxuXFxuLmZsZXgtZWxlbWVudF9fYWxpZ24tYmFzZWxpbmVfXzNyY0NQWVBnY20ge1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgIC1tcy1mbGV4LWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lOyB9XFxuXFxuLmZsZXgtZWxlbWVudF9fYWxpZ24tY2VudGVyX18xVjIyaGlVeDJwIHtcXG4gIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XFxuICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgfVxcblxcbi5mbGV4LWVsZW1lbnRfX2FsaWduLWZsZXgtZW5kX19SajR4MkNIeTViIHtcXG4gIC13ZWJraXQtYm94LWFsaWduOiBlbmQ7XFxuICAgICAgLW1zLWZsZXgtYWxpZ246IGVuZDtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kOyB9XFxuXFxuLmZsZXgtZWxlbWVudF9fYWxpZ24tZmxleC1zdGFydF9fMVdzQXNaUENYRCB7XFxuICAtd2Via2l0LWJveC1hbGlnbjogc3RhcnQ7XFxuICAgICAgLW1zLWZsZXgtYWxpZ246IHN0YXJ0O1xcbiAgICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDsgfVxcblxcbi5mbGV4LWVsZW1lbnRfX2FsaWduLXN0cmV0Y2hfX2RJbUVURjBjU20ge1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IHN0cmV0Y2g7XFxuICAgICAgLW1zLWZsZXgtYWxpZ246IHN0cmV0Y2g7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoOyB9XFxuXFxuLmZsZXgtZWxlbWVudF9fanVzdGlmeS1jZW50ZXJfXzhnaUk4cTh4RTAge1xcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IH1cXG5cXG4uZmxleC1lbGVtZW50X19qdXN0aWZ5LWZsZXgtZW5kX19GNzdDeW45OGVVIHtcXG4gIC13ZWJraXQtYm94LXBhY2s6IGVuZDtcXG4gICAgICAtbXMtZmxleC1wYWNrOiBlbmQ7XFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7IH1cXG5cXG4uZmxleC1lbGVtZW50X19qdXN0aWZ5LWZsZXgtc3RhcnRfXzN4UnFxaWV5LUEge1xcbiAgLXdlYmtpdC1ib3gtcGFjazogc3RhcnQ7XFxuICAgICAgLW1zLWZsZXgtcGFjazogc3RhcnQ7XFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDsgfVxcblxcbi5mbGV4LWVsZW1lbnRfX2p1c3RpZnktc3BhY2UtYXJvdW5kX185Q3pvZ05WVDhiIHtcXG4gIC1tcy1mbGV4LXBhY2s6IGRpc3RyaWJ1dGU7XFxuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7IH1cXG5cXG4uZmxleC1lbGVtZW50X19qdXN0aWZ5LXNwYWNlLWJldHdlZW5fXzNwX251UWFVbkgge1xcbiAgLXdlYmtpdC1ib3gtcGFjazoganVzdGlmeTtcXG4gICAgICAtbXMtZmxleC1wYWNrOiBqdXN0aWZ5O1xcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IH1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50L3NyYy92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudC9mbGV4LWVsZW1lbnQuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLHFCQUFjO0VBQWQscUJBQWM7RUFBZCxjQUFjO0VBQ2QsbUJBQW1CLEVBQ3BCOztBQUVEO0VBQ0UsNkJBQXVCO0VBQXZCLDhCQUF1QjtNQUF2QiwyQkFBdUI7VUFBdkIsdUJBQXVCLEVBQ3hCOztBQUVEO0VBQ0UsK0JBQW9CO0VBQXBCLDhCQUFvQjtNQUFwQix3QkFBb0I7VUFBcEIsb0JBQW9CLEVBQ3JCOztBQUVEO0VBQ0Usb0JBQWdCO01BQWhCLGdCQUFnQixFQUNqQjs7QUFFRDtFQUNFLG9CQUFRO01BQVIsWUFBUTtVQUFSLFFBQVEsRUFDVDs7QUFFRDtFQUNFLG9CQUFvQjtFQUNwQixhQUFhLEVBQ2Q7O0FBRUQ7RUFDRSw0QkFBc0I7TUFBdEIseUJBQXNCO1VBQXRCLHNCQUFzQixFQUN2Qjs7QUFFRDtFQUNFLDBCQUFvQjtNQUFwQix1QkFBb0I7VUFBcEIsb0JBQW9CLEVBQ3JCOztBQUVEO0VBQ0UsdUJBQXNCO01BQXRCLG9CQUFzQjtVQUF0QixzQkFBc0IsRUFDdkI7O0FBRUQ7RUFDRSx5QkFBd0I7TUFBeEIsc0JBQXdCO1VBQXhCLHdCQUF3QixFQUN6Qjs7QUFFRDtFQUNFLDJCQUFxQjtNQUFyQix3QkFBcUI7VUFBckIscUJBQXFCLEVBQ3RCOztBQUVEO0VBQ0UseUJBQXdCO01BQXhCLHNCQUF3QjtVQUF4Qix3QkFBd0IsRUFDekI7O0FBRUQ7RUFDRSxzQkFBMEI7TUFBMUIsbUJBQTBCO1VBQTFCLDBCQUEwQixFQUMzQjs7QUFFRDtFQUNFLHdCQUE0QjtNQUE1QixxQkFBNEI7VUFBNUIsNEJBQTRCLEVBQzdCOztBQUVEO0VBQ0UsMEJBQThCO01BQTlCLDhCQUE4QixFQUMvQjs7QUFFRDtFQUNFLDBCQUErQjtNQUEvQix1QkFBK0I7VUFBL0IsK0JBQStCLEVBQ2hDXCIsXCJmaWxlXCI6XCJmbGV4LWVsZW1lbnQuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZmxleCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4uY29sdW1uIHtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbi5yb3cge1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG59XFxuXFxuLndyYXAge1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbn1cXG5cXG4uZnVsbCB7XFxuICBmbGV4OiAxO1xcbn1cXG5cXG4uZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gIG9wYWNpdHk6IDAuNjtcXG59XFxuXFxuLmFsaWduLWJhc2VsaW5lIHtcXG4gIGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcXG59XFxuXFxuLmFsaWduLWNlbnRlciB7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uYWxpZ24tZmxleC1lbmQge1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbn1cXG5cXG4uYWxpZ24tZmxleC1zdGFydCB7XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG59XFxuXFxuLmFsaWduLXN0cmV0Y2gge1xcbiAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxufVxcblxcbi5qdXN0aWZ5LWNlbnRlciB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuXFxuLmp1c3RpZnktZmxleC1lbmQge1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG59XFxuXFxuLmp1c3RpZnktZmxleC1zdGFydCB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxufVxcblxcbi5qdXN0aWZ5LXNwYWNlLWFyb3VuZCB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG59XFxuXFxuLmp1c3RpZnktc3BhY2UtYmV0d2VlbiB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwiZmxleFwiOiBcImZsZXgtZWxlbWVudF9fZmxleF9fM24xRzlFdmphQ1wiLFxuXHRcImNvbHVtblwiOiBcImZsZXgtZWxlbWVudF9fY29sdW1uX18yeGZjNlFXVnRsXCIsXG5cdFwicm93XCI6IFwiZmxleC1lbGVtZW50X19yb3dfXzNsYzNkWjE0WjJcIixcblx0XCJ3cmFwXCI6IFwiZmxleC1lbGVtZW50X193cmFwX18yVjBKT1ZVMWp2XCIsXG5cdFwiZnVsbFwiOiBcImZsZXgtZWxlbWVudF9fZnVsbF9fMTVSOElYd3Q0TVwiLFxuXHRcImRpc2FibGVkXCI6IFwiZmxleC1lbGVtZW50X19kaXNhYmxlZF9fYUluTC1najhoMFwiLFxuXHRcImFsaWduLWJhc2VsaW5lXCI6IFwiZmxleC1lbGVtZW50X19hbGlnbi1iYXNlbGluZV9fM3JjQ1BZUGdjbVwiLFxuXHRcImFsaWduLWNlbnRlclwiOiBcImZsZXgtZWxlbWVudF9fYWxpZ24tY2VudGVyX18xVjIyaGlVeDJwXCIsXG5cdFwiYWxpZ24tZmxleC1lbmRcIjogXCJmbGV4LWVsZW1lbnRfX2FsaWduLWZsZXgtZW5kX19SajR4MkNIeTViXCIsXG5cdFwiYWxpZ24tZmxleC1zdGFydFwiOiBcImZsZXgtZWxlbWVudF9fYWxpZ24tZmxleC1zdGFydF9fMVdzQXNaUENYRFwiLFxuXHRcImFsaWduLXN0cmV0Y2hcIjogXCJmbGV4LWVsZW1lbnRfX2FsaWduLXN0cmV0Y2hfX2RJbUVURjBjU21cIixcblx0XCJqdXN0aWZ5LWNlbnRlclwiOiBcImZsZXgtZWxlbWVudF9fanVzdGlmeS1jZW50ZXJfXzhnaUk4cTh4RTBcIixcblx0XCJqdXN0aWZ5LWZsZXgtZW5kXCI6IFwiZmxleC1lbGVtZW50X19qdXN0aWZ5LWZsZXgtZW5kX19GNzdDeW45OGVVXCIsXG5cdFwianVzdGlmeS1mbGV4LXN0YXJ0XCI6IFwiZmxleC1lbGVtZW50X19qdXN0aWZ5LWZsZXgtc3RhcnRfXzN4UnFxaWV5LUFcIixcblx0XCJqdXN0aWZ5LXNwYWNlLWFyb3VuZFwiOiBcImZsZXgtZWxlbWVudF9fanVzdGlmeS1zcGFjZS1hcm91bmRfXzlDem9nTlZUOGJcIixcblx0XCJqdXN0aWZ5LXNwYWNlLWJldHdlZW5cIjogXCJmbGV4LWVsZW1lbnRfX2p1c3RpZnktc3BhY2UtYmV0d2Vlbl9fM3BfbnVRYVVuSFwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL34vcG9zdGNzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudC9mbGV4LWVsZW1lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50L2ZsZXgtZWxlbWVudC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZWxlbWVudFR5cGUgZnJvbSAncmVhY3QtcHJvcC10eXBlcy9saWIvZWxlbWVudFR5cGUnO1xuXG4vLyBOZWNlc3PDoXJpbyBwYXJhIG8gdXNvIGRvIHJlYWN0LWRvY2dlblxuY29uc3QgRGVmYXVsdFByb3BzID0gKCkgPT4gKFxuICA8bm9zY3JpcHQgLz5cbik7XG5cbkRlZmF1bHRQcm9wcy5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDaGlsZHJlbiBub2Rlc1xuICAgKi9cbiAgY2hpbGRyZW46IFJlYWN0LlByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gQ1NTLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBQZXJtaXRlIG8gdXNvIGRlIHRhZ3MgY3VzdG9taXphZGFzIG5vIGNvbXBvbmVudGUuXG4gICAqIEV4OiBgPERyb3Bkb3duTWVudSBjb21wb25lbnQ9e0J1dHRvbnxcImFcInxcImJ1dHRvblwifT5gXG4gICAqL1xuICBjb21wb25lbnQ6IGVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gc3R5bGUuXG4gICAqL1xuICBzdHlsZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbn07XG5cbkRlZmF1bHRQcm9wcy5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJycsXG4gIGNvbXBvbmVudDogJ2RpdicsXG4gIHN0eWxlOiB7fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRQcm9wcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbXBvbmVudHMvZGVmYXVsdC1wcm9wcy5qc3giLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMzQzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtcHJvcC10eXBlcy9saWIvZWxlbWVudFR5cGUuanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5pbXBvcnQgT3JnYW5pemF0aW9uIGZyb20gJy4vb3JnYW5pemF0aW9uJztcbmltcG9ydCBWb2x1bnRlZXIgZnJvbSAnLi92b2x1bnRlZXInO1xuXG5jb25zdCBGZWVkID0gKHsgdXNlciwgLi4ucHJvcHMgfSkgPT4gKFxuICB1c2VyLnR5cGUgPT09ICdvcmdhbml6YXRpb24nID9cbiAgICA8T3JnYW5pemF0aW9uIHsuLi5wcm9wc30gLz4gOlxuICAgIDxWb2x1bnRlZXIgey4uLnByb3BzfSAvPlxuKTtcblxuRmVlZC5wcm9wVHlwZXMgPSB7XG4gIHVzZXI6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG59O1xuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBzdGF0ZSA9PiAoe1xuICB1c2VyOiBzZWxlY3RvcnMuZ2V0VXNlcihzdGF0ZSksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKEZlZWQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL2luZGV4LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQYWdlIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvdGhyZWUtY29sdW1ucyc7XG5pbXBvcnQgUGFuZWwgZnJvbSAnLi9wYW5lbCc7XG5pbXBvcnQgRGV0YWlscyBmcm9tICcuL2RldGFpbHMnO1xuLy8gaW1wb3J0IFJlbGF0ZWQgZnJvbSAnLi9yZWxhdGVkJztcblxuY29uc3QgVXN1YXJpbyA9IHByb3BzID0+IChcbiAgPFBhZ2VcbiAgICBwYW5lbD17PFBhbmVsIHsuLi5wcm9wc30gLz59XG4gICAgY29udGVudD17PERldGFpbHMgey4uLnByb3BzfSAvPn1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFVzdWFyaW87XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL2luZGV4LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBGbGV4RWxlbWVudCBmcm9tICd+L3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50JztcblxuY29uc3QgVGhyZWVDb2x1bW5zID0gKHsgY29udGVudCwgcGFuZWwsIHJlbGF0ZWQgfSkgPT4gKFxuICA8RmxleEVsZW1lbnQgZnVsbD5cbiAgICA8RmxleEVsZW1lbnQgY29sdW1uPlxuICAgICAge3BhbmVsfVxuICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgPEZsZXhFbGVtZW50IGNvbHVtbiBmdWxsPlxuICAgICAge2NvbnRlbnR9XG4gICAgPC9GbGV4RWxlbWVudD5cbiAgICA8RmxleEVsZW1lbnQgY29sdW1uPlxuICAgICAge3JlbGF0ZWR9XG4gICAgPC9GbGV4RWxlbWVudD5cbiAgPC9GbGV4RWxlbWVudD5cbik7XG5cblRocmVlQ29sdW1ucy5wcm9wVHlwZXMgPSB7XG4gIGNvbnRlbnQ6IFJlYWN0LlByb3BUeXBlcy5ub2RlLFxuICBwYW5lbDogUmVhY3QuUHJvcFR5cGVzLm5vZGUsXG4gIHJlbGF0ZWQ6IFJlYWN0LlByb3BUeXBlcy5ub2RlLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgVGhyZWVDb2x1bW5zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29tcG9uZW50cy90aHJlZS1jb2x1bW5zLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgSGVhZGVyLCBTZWdtZW50IH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5cbmNvbnN0IHN0eWxlID0ge1xuICBmb250U2l6ZTogJzFyZW0nLFxuICBtYXJnaW5SaWdodDogJzAuOGVtJyxcbiAgd2lkdGg6ICcxNmVtJyxcbn07XG5cbmNvbnN0IFBhbmVsID0gKCkgPT4gKFxuICA8RmxleEVsZW1lbnQgY29sdW1uIHN0eWxlPXtzdHlsZX0+XG4gICAgPFNlZ21lbnQ+XG4gICAgICA8SGVhZGVyIGFzPVwiaDVcIiBzdHlsZT17eyBmb250U2l6ZTogJzAuOTVlbScgfX0+XG4gICAgICAgIFBFRElET1MgREUgVk9MVU5Uw4FSSU9TXG4gICAgICA8L0hlYWRlcj5cbiAgICAgIDxIZWFkZXIgYXM9XCJoNVwiIHN0eWxlPXt7IGZvbnRTaXplOiAnMC45NWVtJyB9fT5cbiAgICAgICAgU0VSVknDh09TIEFCRVJUT1NcbiAgICAgIDwvSGVhZGVyPlxuICAgIDwvU2VnbWVudD5cbiAgPC9GbGV4RWxlbWVudD5cbik7XG5cblBhbmVsLnByb3BUeXBlcyA9IHtcbiAgc2tpbGxzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICB1c2VyOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxufTtcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gc3RhdGUgPT4gKHtcbiAgdXNlcjogc2VsZWN0b3JzLmdldFVzZXIoc3RhdGUpLFxuICBza2lsbHM6IHNlbGVjdG9ycy5nZXRFbnRpdGllcyhzdGF0ZSwgJ3NraWxscycpLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzKShQYW5lbCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL3BhbmVsLmpzeCIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IFNlZ21lbnQsIENvbnRhaW5lciwgTWVudSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCAqIGFzIGFjdGlvbkNyZWF0b3JzIGZyb20gJ34vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgc2VsZWN0b3JzIGZyb20gJ34vc3RvcmUvc2VsZWN0b3JzJztcbmltcG9ydCBUaW1lbGluZSBmcm9tICcuL3RhYnMvdGltZWxpbmUnO1xuaW1wb3J0IENhbXBhaWducyBmcm9tICcuL3RhYnMvY2FtcGFpZ25zJztcbmltcG9ydCBTZXJ2aWNlcyBmcm9tICcuL3RhYnMvc2VydmljZXMnO1xuXG5jb25zdCB2aWV3cyA9IHtcbiAgdGltZWxpbmU6IHtcbiAgICBkZXNjcmlwdGlvbjogJ0ZlZWQnLFxuICAgIGNvbXBvbmVudDogVGltZWxpbmUsXG4gIH0sXG4gIGNhbXBhaWduczoge1xuICAgIGRlc2NyaXB0aW9uOiAnQ2FtcGFuaGFzJyxcbiAgICBjb21wb25lbnQ6IENhbXBhaWducyxcbiAgfSxcbiAgc2VydmljZXM6IHtcbiAgICBkZXNjcmlwdGlvbjogJ1NlcnZpw6dvcycsXG4gICAgY29tcG9uZW50OiBTZXJ2aWNlcyxcbiAgfSxcbn07XG5cbmNvbnN0IERldGFpbHMgPSAoeyBhY3RpdmUsIG9uVGFiQ2xpY2sgfSkgPT4ge1xuICBjb25zdCBDb21wb25lbnQgPSB2aWV3c1thY3RpdmVdLmNvbXBvbmVudDtcblxuICByZXR1cm4gKFxuICAgIDxDb250YWluZXIgZmx1aWQgc3R5bGU9e3sgZm9udFNpemU6ICcxcmVtJyB9fT5cbiAgICAgIDxNZW51IGF0dGFjaGVkPVwidG9wXCIgdGFidWxhcj5cbiAgICAgICAge18ubWFwKHZpZXdzLCAodmFsLCBrZXkpID0+XG4gICAgICAgICAgPE1lbnUuSXRlbVxuICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICBuYW1lPXtrZXl9XG4gICAgICAgICAgICBhY3RpdmU9e2FjdGl2ZSA9PT0ga2V5fVxuICAgICAgICAgICAgb25DbGljaz17b25UYWJDbGlja31cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7dmFsLmRlc2NyaXB0aW9ufVxuICAgICAgICAgIDwvTWVudS5JdGVtPixcbiAgICAgICAgKX1cbiAgICAgIDwvTWVudT5cbiAgICAgIDxTZWdtZW50IGF0dGFjaGVkPVwiYm90dG9tXCI+XG4gICAgICAgIDxDb21wb25lbnQgLz5cbiAgICAgIDwvU2VnbWVudD5cbiAgICA8L0NvbnRhaW5lcj5cbiAgKTtcbn07XG5cbkRldGFpbHMucHJvcFR5cGVzID0ge1xuICBhY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gIG9uVGFiQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxufTtcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gc3RhdGUgPT4gKHtcbiAgYWN0aXZlOiBzZWxlY3RvcnMuZ2V0Q3VycmVudFRhYkZlZWQoc3RhdGUpLFxufSk7XG5cbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGRpc3BhdGNoID0+ICh7XG4gIG9uVGFiQ2xpY2s6IChldnQsIHsgbmFtZSB9KSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9ycy51cGRhdGVUYWJGZWVkKG5hbWUpKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShEZXRhaWxzKTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL29yZ2FuaXphdGlvbi9kZXRhaWxzLmpzeCIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IEljb24sIEZlZWQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5pbXBvcnQgc2VsZWN0b3JzIGZyb20gJ34vc3RvcmUvc2VsZWN0b3JzJztcblxuY29uc3Qgc3R5bGVzID0ge1xuICBlbXB0eUNvbnRhaW5lcjogeyBoZWlnaHQ6IDMwMCwgZm9udFNpemU6ICcxcmVtJyB9LFxuICBlbXB0eUNvbnRlbnQ6IHsgbWF4V2lkdGg6IDM1MCB9LFxuICBlbXB0eUljb246IHsgY29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLCBmb250U2l6ZTogJzZlbScgfSxcbiAgZW1wdHlUZXh0OiB7IGNvbG9yOiAncmdiYSgwLDAsMCwwLjUpJywgbWFyZ2luVG9wOiAnMWVtJywgdGV4dEFsaWduOiAnY2VudGVyJyB9LFxufTtcblxuY29uc3QgVGltZWxpbmUgPSAoeyBmZWVkIH0pID0+IHtcbiAgaWYgKF8uaXNFbXB0eShmZWVkKSkge1xuICAgIHJldHVybiAoXG4gICAgICA8RmxleEVsZW1lbnQgY29sdW1uIGFsaWduPVwiY2VudGVyXCIganVzdGlmeT1cImNlbnRlclwiIHN0eWxlPXtzdHlsZXMuZW1wdHlDb250YWluZXJ9PlxuICAgICAgICA8RmxleEVsZW1lbnQgY29sdW1uIGFsaWduPVwiY2VudGVyXCIganVzdGlmeT1cImNlbnRlclwiIHN0eWxlPXtzdHlsZXMuZW1wdHlDb250ZW50fT5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwiY2xvdWRcIiBzdHlsZT17c3R5bGVzLmVtcHR5SWNvbn0gLz5cbiAgICAgICAgICA8c3BhbiBzdHlsZT17c3R5bGVzLmVtcHR5VGV4dH0+XG4gICAgICAgICAgICBFc3TDoSBtZWlvIHBhcmFkbyBwb3IgYXF1aS4uLlxuICAgICAgICAgICAgUXVlIHRhbCBwcm9jdXJhciBwb3Igdm9sdW50w6FyaW9zLCBjcmlhciBjYW1wYW5oYXMgb3Ugc2VydmnDp29zP1xuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPEZlZWQ+XG4gICAgICB7Xy5rZXlzKGZlZWQpLnNvcnQoKS5yZXZlcnNlKCkubWFwKGtleSA9PlxuICAgICAgICA8RmVlZC5FdmVudCBrZXk9e2tleX0gc3R5bGU9e3sgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkICNlZWUnIH19PlxuICAgICAgICAgIDxGZWVkLkxhYmVsPlxuICAgICAgICAgICAgPEljb24gY2lyY3VsYXIgbmFtZT17ZmVlZFtrZXldLmljb259IHN0eWxlPXt7IGNvbG9yOiAncmdiYSgwLDAsMCwwLjMpJywgZm9udFNpemU6ICcxLjRlbScgfX0gLz5cbiAgICAgICAgICA8L0ZlZWQuTGFiZWw+XG4gICAgICAgICAgPEZlZWQuQ29udGVudD5cbiAgICAgICAgICAgIDxGZWVkLkRhdGUgY29udGVudD17bW9tZW50KHBhcnNlSW50KGtleSwgMTApKS5mcm9tTm93KCl9IC8+XG4gICAgICAgICAgICA8RmVlZC5TdW1tYXJ5PlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnbm9ybWFsJyB9fT57ZmVlZFtrZXldLnByZXRleHR9PC9zcGFuPiB7ZmVlZFtrZXldLnRleHR9XG4gICAgICAgICAgICA8L0ZlZWQuU3VtbWFyeT5cbiAgICAgICAgICA8L0ZlZWQuQ29udGVudD5cbiAgICAgICAgPC9GZWVkLkV2ZW50PixcbiAgICAgICl9XG4gICAgPC9GZWVkPlxuICApO1xufTtcblxuVGltZWxpbmUucHJvcFR5cGVzID0ge1xuICBmZWVkOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxufTtcblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gc3RhdGUgPT4gKHtcbiAgZmVlZDogc2VsZWN0b3JzLmdldEZlZWQoc3RhdGUpLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzKShUaW1lbGluZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL3RhYnMvdGltZWxpbmUuanN4IiwiaW1wb3J0IENhbXBhaWducyBmcm9tICcuL2NhbXBhaWducyc7XG5cbmV4cG9ydCBkZWZhdWx0IENhbXBhaWducztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9jYW1wYWlnbnMvaW5kZXguanMiLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgc2VsZWN0b3JzIGZyb20gJ34vc3RvcmUvc2VsZWN0b3JzJztcbmltcG9ydCB7IEJ1dHRvbiwgRGl2aWRlciwgSWNvbiwgTG9hZGVyLCBUYWJsZSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCAqIGFzIGFjdGlvbkNyZWF0b3JzIGZyb20gJ34vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5pbXBvcnQgQ2FtcGFpZ24gZnJvbSAnLi9jYW1wYWlnbic7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi9tb2RhbCc7XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgZW1wdHlDb250YWluZXI6IHsgaGVpZ2h0OiAzMDAsIGZvbnRTaXplOiAnMXJlbScgfSxcbiAgZW1wdHlJY29uOiB7IGNvbG9yOiAncmdiYSgwLDAsMCwwLjEpJywgZm9udFNpemU6ICc2ZW0nIH0sXG4gIGVtcHR5VGV4dDogeyBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsIG1hcmdpblRvcDogJzFlbScsIHRleHRBbGlnbjogJ2NlbnRlcicgfSxcbn07XG5cbmNsYXNzIENhbXBhaWducyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBpc0ZldGNoaW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBpc0xvZ2dlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaGFzQ2FtcGFpZ25zOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB1c2VyOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIHNlbGVjdGVkSWQ6IG51bGwsXG4gICAgaXNNb2RhbE9wZW46IGZhbHNlLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgYWN0aW9ucywgaGFzQ2FtcGFpZ25zLCBpc0xvZ2dlZCwgaXNGZXRjaGluZyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghaGFzQ2FtcGFpZ25zICYmIGlzTG9nZ2VkICYmICFpc0ZldGNoaW5nKSB7XG4gICAgICBhY3Rpb25zLnJlYWQoeyBlbnRpdHk6ICdjYW1wYWlnbnMnIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoeyBhY3Rpb25zLCB1c2VyOiB7IGNhbXBhaWducyB9IH0pIHtcbiAgICBjb25zdCBvbGRDYW1wYWlnbnMgPSB0aGlzLnByb3BzLnVzZXIuY2FtcGFpZ25zO1xuXG4gICAgaWYgKGNhbXBhaWducyAhPT0gb2xkQ2FtcGFpZ25zKSB7XG4gICAgICBjb25zdCBuZXdMZW4gPSBfLmtleXMoY2FtcGFpZ25zKS5sZW5ndGg7XG4gICAgICBjb25zdCBvbGRMZW4gPSBfLmtleXMob2xkQ2FtcGFpZ25zKS5sZW5ndGg7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSAoXG4gICAgICAgIChuZXdMZW4gPiBvbGRMZW4gJiYgJ2NyaWFkYScpIHx8XG4gICAgICAgIChuZXdMZW4gPCBvbGRMZW4gJiYgJ3JlbW92aWRhJykgfHxcbiAgICAgICAgJ2VkaXRhZGEnXG4gICAgICApO1xuXG4gICAgICB0aGlzLmhhbmRsZUNsb3NlKCk7XG5cbiAgICAgIGFjdGlvbnMubm90aWZ5KGBDYW1wYW5oYSAke29wZXJhdGlvbn0gY29tIHN1Y2Vzc28hYCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogZmFsc2UgfSk7XG4gIH1cblxuICBoYW5kbGVDcmVhdGUgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSwgc2VsZWN0ZWRJZDogbnVsbCB9KTtcbiAgfTtcblxuICBoYW5kbGVFZGl0ID0gKHNlbGVjdGVkSWQpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNPcGVuOiB0cnVlLCBzZWxlY3RlZElkIH0pO1xuICB9O1xuXG4gIGhhbmRsZVJlbW92ZSA9ICh1aWQpID0+IHtcbiAgICB0aGlzLnByb3BzLmFjdGlvbnMucmVtb3ZlKHsgZW50aXR5OiAnY2FtcGFpZ25zJywgdWlkIH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlzT3Blbiwgc2VsZWN0ZWRJZCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGlzRmV0Y2hpbmcsIHVzZXIgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbj5cbiAgICAgICAgPEZsZXhFbGVtZW50IGp1c3RpZnk9XCJmbGV4LWVuZFwiPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIGNvbXBhY3RcbiAgICAgICAgICAgIHByaW1hcnlcbiAgICAgICAgICAgIGljb249XCJwbHVzXCJcbiAgICAgICAgICAgIHNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICBjb250ZW50PVwiQ2FtcGFuaGFcIlxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDcmVhdGV9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgICAgPE1vZGFsIGlzT3Blbj17aXNPcGVufSB1aWQ9e3NlbGVjdGVkSWR9IG9uQ2xvc2U9e3RoaXMuaGFuZGxlQ2xvc2V9IC8+XG4gICAgICAgIDxEaXZpZGVyIHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogMCB9fSAvPlxuICAgICAgICB7aXNGZXRjaGluZyAmJiAhXy5pc0VtcHR5KHVzZXIuY2FtcGFpZ25zKSAmJiAoXG4gICAgICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBhbGlnbj1cImNlbnRlclwiIGp1c3RpZnk9XCJjZW50ZXJcIiBzdHlsZT17c3R5bGVzLmVtcHR5Q29udGFpbmVyfT5cbiAgICAgICAgICAgIDxMb2FkZXIgYWN0aXZlPlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBjb2xvcjogJ3JnYmEoMCwwLDAsIDAuNDUpJyB9fT5cbiAgICAgICAgICAgICAgICBDYXJyZWdhbmRvIGNhbXBhbmhhcy4uLlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L0xvYWRlcj5cbiAgICAgICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgICApfVxuICAgICAgICB7IWlzRmV0Y2hpbmcgJiYgXy5pc0VtcHR5KHVzZXIuY2FtcGFpZ25zKSAmJiAoXG4gICAgICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBhbGlnbj1cImNlbnRlclwiIGp1c3RpZnk9XCJjZW50ZXJcIiBzdHlsZT17c3R5bGVzLmVtcHR5Q29udGFpbmVyfT5cbiAgICAgICAgICAgIDxJY29uIG5hbWU9XCJidWxsaG9yblwiIHN0eWxlPXtzdHlsZXMuZW1wdHlJY29ufSAvPlxuICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3N0eWxlcy5lbXB0eVRleHR9PlxuICAgICAgICAgICAgICBDbGlxdWUgbm8gYm90w6NvIGFjaW1hIHBhcmEgYWRpY2lvbmFyIHVtIGNhbXBhbmhhLlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICAgICl9XG4gICAgICAgIHshaXNGZXRjaGluZyAmJiAhXy5pc0VtcHR5KHVzZXIuY2FtcGFpZ25zKSAmJiAoXG4gICAgICAgICAgPFRhYmxlIGJhc2ljPVwidmVyeVwiIHN0eWxlPXt7IG1hcmdpbjogMCB9fT5cbiAgICAgICAgICAgIDxUYWJsZS5Cb2R5PlxuICAgICAgICAgICAgICB7Xy5tYXAodXNlci5jYW1wYWlnbnMsIHVpZCA9PlxuICAgICAgICAgICAgICAgIDxDYW1wYWlnblxuICAgICAgICAgICAgICAgICAga2V5PXt1aWR9XG4gICAgICAgICAgICAgICAgICB1aWQ9e3VpZH1cbiAgICAgICAgICAgICAgICAgIG9uRWRpdD17dGhpcy5oYW5kbGVFZGl0fVxuICAgICAgICAgICAgICAgICAgb25SZW1vdmU9e3RoaXMuaGFuZGxlUmVtb3ZlfVxuICAgICAgICAgICAgICAgIC8+LFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9UYWJsZS5Cb2R5PlxuICAgICAgICAgIDwvVGFibGU+XG4gICAgICAgICl9XG4gICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gc3RhdGUgPT4gKHtcbiAgdXNlcjogc2VsZWN0b3JzLmdldFVzZXIoc3RhdGUpLFxuICBpc0xvZ2dlZDogc2VsZWN0b3JzLmlzQXV0aGVudGljYXRlZChzdGF0ZSksXG4gIGlzRmV0Y2hpbmc6IHNlbGVjdG9ycy5pc0ZldGNoaW5nKHN0YXRlLCAnY2FtcGFpZ25zJyksXG4gIGhhc0NhbXBhaWduczogIV8uaXNFbXB0eShzZWxlY3RvcnMuZ2V0RW50aXRpZXMoc3RhdGUsICdjYW1wYWlnbnMnKSksXG59KTtcblxuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gZGlzcGF0Y2ggPT4gKHtcbiAgYWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcykoQ2FtcGFpZ25zKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9jYW1wYWlnbnMvY2FtcGFpZ25zLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgQnV0dG9uLCBJY29uLCBIZWFkZXIsIExvYWRlciwgTW9kYWwsIFRhYmxlIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgZWRpdDogeyBtYXJnaW5SaWdodDogMTAgfSxcbiAgcmVtb3ZlOiB7IG1hcmdpblRvcDogLTEgfSxcbiAgbG9hZGVyOiB7IG1hcmdpbkxlZnQ6IDgsIG1hcmdpblJpZ2h0OiA1LCBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9LFxufTtcblxuY2xhc3MgQ2FtcGFpZ24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGlzUmVtb3Zpbmc6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGNhbXBhaWduOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHVpZDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkVkaXQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVtb3ZlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBpc09wZW46IGZhbHNlLFxuICB9O1xuXG4gIGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBpc09wZW46IGZhbHNlIH0pO1xuICB9O1xuXG4gIGhhbmRsZU9wZW4gPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVSZW1vdmUgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogZmFsc2UgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vblJlbW92ZSh0aGlzLnByb3BzLnVpZCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNPcGVuIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaXNSZW1vdmluZywgY2FtcGFpZ24sIG9uRWRpdCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB0cmlnZ2VyID0gaXNSZW1vdmluZyA/XG4gICAgICA8c3BhbiBzdHlsZT17c3R5bGVzLmxvYWRlcn0+PExvYWRlciBhY3RpdmUgc2l6ZT1cIm1pbmlcIiAvPjwvc3Bhbj4gOlxuICAgICAgPEljb24gbGluayBuYW1lPVwidHJhc2ggb3V0bGluZVwiIHN0eWxlPXtzdHlsZXMucmVtb3ZlfSBvbkNsaWNrPXt0aGlzLmhhbmRsZU9wZW59IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxUYWJsZS5Sb3c+XG4gICAgICAgIDxUYWJsZS5DZWxsPlxuICAgICAgICAgIDxIZWFkZXIgYXM9XCJoNFwiIGltYWdlPlxuICAgICAgICAgICAgPEljb24gbmFtZT1cImJ1bGxob3JuXCIgLz5cbiAgICAgICAgICAgIDxIZWFkZXIuQ29udGVudD5cbiAgICAgICAgICAgICAge2NhbXBhaWduLm5hbWV9XG4gICAgICAgICAgICAgIDxIZWFkZXIuU3ViaGVhZGVyPlxuICAgICAgICAgICAgICAgIHsoY2FtcGFpZ24uZGV0YWlscyB8fCAnJykubGVuZ3RoID4gMjAwID9cbiAgICAgICAgICAgICAgICAgIGAke2NhbXBhaWduLmRldGFpbHMuc3Vic3RyKDAsIDIwMCl9Li4uYCA6XG4gICAgICAgICAgICAgICAgICBjYW1wYWlnbi5kZXRhaWxzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA8L0hlYWRlci5TdWJoZWFkZXI+XG4gICAgICAgICAgICA8L0hlYWRlci5Db250ZW50PlxuICAgICAgICAgIDwvSGVhZGVyPlxuICAgICAgICA8L1RhYmxlLkNlbGw+XG4gICAgICAgIDxUYWJsZS5DZWxsIGNvbGxhcHNpbmc+XG4gICAgICAgICAgPEljb25cbiAgICAgICAgICAgIGxpbmtcbiAgICAgICAgICAgIG5hbWU9XCJlZGl0XCJcbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZXMuZWRpdH1cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uRWRpdChjYW1wYWlnbi51aWQpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPE1vZGFsXG4gICAgICAgICAgICBzaXplPVwic21hbGxcIlxuICAgICAgICAgICAgb3Blbj17aXNPcGVufVxuICAgICAgICAgICAgdHJpZ2dlcj17dHJpZ2dlcn1cbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU9e2ZhbHNlfVxuICAgICAgICAgICAgY2xvc2VPblJvb3ROb2RlQ2xpY2s9e2ZhbHNlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxIZWFkZXIgc2l6ZT1cIm1pbmlcIiBjb250ZW50PVwiUmVtb3ZlciBDYW1wYW5oYVwiIC8+XG4gICAgICAgICAgICA8TW9kYWwuQ29udGVudD5cbiAgICAgICAgICAgICAgQ29uZmlybWFyIGEgcmVtb8Onw6NvIGRlIDxzdHJvbmc+e2NhbXBhaWduLm5hbWV9PC9zdHJvbmc+P1xuICAgICAgICAgICAgPC9Nb2RhbC5Db250ZW50PlxuICAgICAgICAgICAgPE1vZGFsLkFjdGlvbnM+XG4gICAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZX0+XG4gICAgICAgICAgICAgICAgPEljb24gbmFtZT1cInJlbW92ZVwiIC8+IE7Do29cbiAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgIDxCdXR0b24gY29sb3I9XCJyZWRcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZVJlbW92ZX0+XG4gICAgICAgICAgICAgICAgPEljb24gbmFtZT1cInRyYXNoIG91dGxpbmVcIiAvPiBTaW1cbiAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8L01vZGFsLkFjdGlvbnM+XG4gICAgICAgICAgPC9Nb2RhbD5cbiAgICAgICAgPC9UYWJsZS5DZWxsPlxuICAgICAgPC9UYWJsZS5Sb3c+XG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSAoc3RhdGUsIHsgdWlkIH0pID0+ICh7XG4gIGNhbXBhaWduOiBzZWxlY3RvcnMuZ2V0RW50aXRpZXMoc3RhdGUsICdjYW1wYWlnbnMnLCB1aWQpLFxuICBpc1JlbW92aW5nOiBzZWxlY3RvcnMuaXNSZW1vdmluZyhzdGF0ZSwgJ2NhbXBhaWducycsIHVpZCksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKENhbXBhaWduKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9jYW1wYWlnbnMvY2FtcGFpZ24uanN4IiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgQnV0dG9uLCBGb3JtLCBNb2RhbCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCAqIGFzIGFjdGlvbkNyZWF0b3JzIGZyb20gJ34vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgc2VsZWN0b3JzIGZyb20gJ34vc3RvcmUvc2VsZWN0b3JzJztcbmltcG9ydCBGbGV4RWxlbWVudCBmcm9tICd+L3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50JztcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBmb3JtRGF0YToge1xuICAgIG5hbWU6ICcnLFxuICAgIGRldGFpbHM6ICcnLFxuICB9LFxufTtcblxuY2xhc3MgTW9kYWxDYW1wYWlnbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBjYW1wYWlnbjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBpc09wZW46IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGlzU2F2aW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNsb3NlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNhbXBhaWduOiB7fSxcbiAgfTtcblxuICBzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblxuICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLnByb3BzLm9uQ2xvc2UoKTtcbiAgfTtcblxuICBoYW5kbGVPcGVuID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY2FtcGFpZ24gfSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZvcm1EYXRhOiB7XG4gICAgICAgIG5hbWU6IGNhbXBhaWduLm5hbWUgfHwgJycsXG4gICAgICAgIGRldGFpbHM6IGNhbXBhaWduLmRldGFpbHMgfHwgJycsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGUsIGRhdGEgPSB7fSkgPT4ge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gXy5tZXJnZSh7fSwgdGhpcy5zdGF0ZS5mb3JtRGF0YSk7XG4gICAgY29uc3QgbmFtZSA9IGRhdGEubmFtZSB8fCBlLmN1cnJlbnRUYXJnZXQubmFtZTtcbiAgICBjb25zdCB2YWx1ZSA9IGRhdGEudmFsdWUgfHwgZS5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuXG4gICAgZm9ybURhdGFbbmFtZV0gPSB2YWx1ZTtcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JtRGF0YSB9KTtcbiAgfTtcblxuICBoYW5kbGVTdWJtaXQgPSAoZXZ0KSA9PiB7XG4gICAgY29uc3QgeyBmb3JtRGF0YSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGFjdGlvbnMsIGNhbXBhaWduIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodGhpcy5pc1ZhbGlkKGZvcm1EYXRhKSkge1xuICAgICAgYWN0aW9ucy5hZGRUb09yZyh7XG4gICAgICAgIGVudGl0eTogJ2NhbXBhaWducycsXG4gICAgICAgIGRhdGE6IF8uYXNzaWduKHt9LCBjYW1wYWlnbiwgZm9ybURhdGEpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZChkYXRhKSB7XG4gICAgY29uc3QgaXNWYWxpZCA9ICFbJ25hbWUnLCAnZGV0YWlscyddXG4gICAgICAubWFwKGF0dHIgPT4gZGF0YVthdHRyXSlcbiAgICAgIC5zb21lKHZhbCA9PiBfLmlzRW1wdHkodmFsKSk7XG5cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHRoaXMucHJvcHMuYWN0aW9ucy5ub3RpZnlFcnJvcignw4kgbmVjZXNzw6FyaW8gcHJlZW5jaGVyIG9zIGNhbXBvcyBvYnJpZ2F0w7NyaW9zJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQ7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpc09wZW4sIGlzU2F2aW5nLCBjYW1wYWlnbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZvcm1EYXRhIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNb2RhbFxuICAgICAgICBvcGVuPXtpc09wZW59XG4gICAgICAgIGNsb3NlT25Fc2NhcGU9e2ZhbHNlfVxuICAgICAgICBjbG9zZU9uUm9vdE5vZGVDbGljaz17ZmFsc2V9XG4gICAgICAgIG9uTW91bnQ9e3RoaXMuaGFuZGxlT3Blbn1cbiAgICAgICAgb25DbG9zZT17dGhpcy5oYW5kbGVDbG9zZX1cbiAgICAgID5cbiAgICAgICAgPE1vZGFsLkhlYWRlcj5cbiAgICAgICAgICB7Y2FtcGFpZ24udWlkID8gJ0VkaXRhciBDYW1wYW5oYScgOiAnTm92YSBDYW1wYW5oYSd9XG4gICAgICAgIDwvTW9kYWwuSGVhZGVyPlxuICAgICAgICA8TW9kYWwuQ29udGVudCBhcz17Rm9ybX0gb25TdWJtaXQ9e3RoaXMuaGFuZGxlU3VibWl0fT5cbiAgICAgICAgICA8Rm9ybS5JbnB1dFxuICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgIG5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgIGxhYmVsPVwiTm9tZVwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIk5vbWUgcXVlIHNlcsOhIGV4aWJpZG8gbm9zIHJlc3VsdGFkb3MgZGEgcGVzcXVpc2FcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzU2F2aW5nfVxuICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLm5hbWV9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8Rm9ybS5UZXh0QXJlYVxuICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgIHJvd3M9XCI2XCJcbiAgICAgICAgICAgIG5hbWU9XCJkZXRhaWxzXCJcbiAgICAgICAgICAgIGxhYmVsPVwiRGV0YWxoZXNcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJEbyBxdWUgc2UgdHJhdGEgZXN0YSBjYW1wYW5oYT9cIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzU2F2aW5nfVxuICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLmRldGFpbHN9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Nb2RhbC5Db250ZW50PlxuICAgICAgICA8TW9kYWwuQWN0aW9ucyBhcz17RmxleEVsZW1lbnR9IGp1c3RpZnk9XCJmbGV4LWVuZFwiPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIGNvbnRlbnQ9XCJGZWNoYXJcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzU2F2aW5nfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIHByaW1hcnlcbiAgICAgICAgICAgIGljb249XCJzYXZlXCJcbiAgICAgICAgICAgIGNvbnRlbnQ9XCJTYWx2YXJcIlxuICAgICAgICAgICAgbG9hZGluZz17aXNTYXZpbmd9XG4gICAgICAgICAgICBkaXNhYmxlZD17aXNTYXZpbmd9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZVN1Ym1pdH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L01vZGFsLkFjdGlvbnM+XG4gICAgICA8L01vZGFsPlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlLCB7IHVpZCB9KSA9PiAoe1xuICB1c2VyOiBzZWxlY3RvcnMuZ2V0VXNlcihzdGF0ZSksXG4gIGNhbXBhaWduOiBzZWxlY3RvcnMuZ2V0RW50aXRpZXMoc3RhdGUsICdjYW1wYWlnbnMnLCB1aWQpLFxuICBpc1NhdmluZzogKFxuICAgIHNlbGVjdG9ycy5pc0ZldGNoaW5nKHN0YXRlLCAnY2FtcGFpZ25zJykgfHxcbiAgICBzZWxlY3RvcnMuaXNGZXRjaGluZyhzdGF0ZSwgJ3VzZXJzJylcbiAgKSxcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoe1xuICBhY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShNb2RhbENhbXBhaWduKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9jYW1wYWlnbnMvbW9kYWwuanN4IiwiaW1wb3J0IFNlcnZpY2VzIGZyb20gJy4vc2VydmljZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBTZXJ2aWNlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9zZXJ2aWNlcy9pbmRleC5qcyIsImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuaW1wb3J0IHsgQnV0dG9uLCBEaXZpZGVyLCBJY29uLCBMb2FkZXIsIFRhYmxlIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0ICogYXMgYWN0aW9uQ3JlYXRvcnMgZnJvbSAnfi9zdG9yZS9hY3Rpb25zJztcbmltcG9ydCBGbGV4RWxlbWVudCBmcm9tICd+L3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50JztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4vc2VydmljZSc7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi9tb2RhbCc7XG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgZW1wdHlDb250YWluZXI6IHsgaGVpZ2h0OiAzMDAsIGZvbnRTaXplOiAnMXJlbScgfSxcbiAgZW1wdHlJY29uOiB7IGNvbG9yOiAncmdiYSgwLDAsMCwwLjEpJywgZm9udFNpemU6ICc2ZW0nIH0sXG4gIGVtcHR5VGV4dDogeyBjb2xvcjogJ3JnYmEoMCwwLDAsMC41KScsIG1hcmdpblRvcDogJzFlbScsIHRleHRBbGlnbjogJ2NlbnRlcicgfSxcbn07XG5cbmNsYXNzIFNlcnZpY2VzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY3Rpb25zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIGlzRmV0Y2hpbmc6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIGlzTG9nZ2VkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBoYXNTZXJ2aWNlczogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgdXNlcjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBzZWxlY3RlZElkOiBudWxsLFxuICAgIGlzTW9kYWxPcGVuOiBmYWxzZSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IGFjdGlvbnMsIGhhc1NlcnZpY2VzLCBpc0xvZ2dlZCwgaXNGZXRjaGluZyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghaGFzU2VydmljZXMgJiYgaXNMb2dnZWQgJiYgIWlzRmV0Y2hpbmcpIHtcbiAgICAgIGFjdGlvbnMucmVhZCh7IGVudGl0eTogJ3NlcnZpY2VzJyB9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHsgYWN0aW9ucywgdXNlcjogeyBzZXJ2aWNlcyB9IH0pIHtcbiAgICBjb25zdCBvbGRTZXJ2aWNlcyA9IHRoaXMucHJvcHMudXNlci5zZXJ2aWNlcztcblxuICAgIGlmIChzZXJ2aWNlcyAhPT0gb2xkU2VydmljZXMpIHtcbiAgICAgIGNvbnN0IG5ld0xlbiA9IF8ua2V5cyhzZXJ2aWNlcykubGVuZ3RoO1xuICAgICAgY29uc3Qgb2xkTGVuID0gXy5rZXlzKG9sZFNlcnZpY2VzKS5sZW5ndGg7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSAoXG4gICAgICAgIChuZXdMZW4gPiBvbGRMZW4gJiYgJ2NyaWFkbycpIHx8XG4gICAgICAgIChuZXdMZW4gPCBvbGRMZW4gJiYgJ3JlbW92aWRvJykgfHxcbiAgICAgICAgJ2VkaXRhZG8nXG4gICAgICApO1xuXG4gICAgICB0aGlzLmhhbmRsZUNsb3NlKCk7XG5cbiAgICAgIGFjdGlvbnMubm90aWZ5KGBTZXJ2acOnbyAke29wZXJhdGlvbn0gY29tIHN1Y2Vzc28hYCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogZmFsc2UgfSk7XG4gIH1cblxuICBoYW5kbGVDcmVhdGUgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSwgc2VsZWN0ZWRJZDogbnVsbCB9KTtcbiAgfTtcblxuICBoYW5kbGVFZGl0ID0gKHNlbGVjdGVkSWQpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNPcGVuOiB0cnVlLCBzZWxlY3RlZElkIH0pO1xuICB9O1xuXG4gIGhhbmRsZVJlbW92ZSA9ICh1aWQpID0+IHtcbiAgICB0aGlzLnByb3BzLmFjdGlvbnMucmVtb3ZlKHsgZW50aXR5OiAnc2VydmljZXMnLCB1aWQgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaXNPcGVuLCBzZWxlY3RlZElkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgaXNGZXRjaGluZywgdXNlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8RmxleEVsZW1lbnQgY29sdW1uPlxuICAgICAgICA8RmxleEVsZW1lbnQganVzdGlmeT1cImZsZXgtZW5kXCI+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgY29tcGFjdFxuICAgICAgICAgICAgcHJpbWFyeVxuICAgICAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICAgICAgc2l6ZT1cInNtYWxsXCJcbiAgICAgICAgICAgIGNvbnRlbnQ9XCJTZXJ2acOnb1wiXG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZUNyZWF0ZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgICA8TW9kYWwgaXNPcGVuPXtpc09wZW59IHVpZD17c2VsZWN0ZWRJZH0gb25DbG9zZT17dGhpcy5oYW5kbGVDbG9zZX0gLz5cbiAgICAgICAgPERpdmlkZXIgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAwIH19IC8+XG4gICAgICAgIHtpc0ZldGNoaW5nICYmICFfLmlzRW1wdHkodXNlci5zZXJ2aWNlcykgJiYgKFxuICAgICAgICAgIDxGbGV4RWxlbWVudCBjb2x1bW4gYWxpZ249XCJjZW50ZXJcIiBqdXN0aWZ5PVwiY2VudGVyXCIgc3R5bGU9e3N0eWxlcy5lbXB0eUNvbnRhaW5lcn0+XG4gICAgICAgICAgICA8TG9hZGVyIGFjdGl2ZT5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6ICdyZ2JhKDAsMCwwLCAwLjQ1KScgfX0+XG4gICAgICAgICAgICAgICAgQ2FycmVnYW5kbyBzZXJ2acOnb3MuLi5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9Mb2FkZXI+XG4gICAgICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgICAgKX1cbiAgICAgICAgeyFpc0ZldGNoaW5nICYmIF8uaXNFbXB0eSh1c2VyLnNlcnZpY2VzKSAmJiAoXG4gICAgICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBhbGlnbj1cImNlbnRlclwiIGp1c3RpZnk9XCJjZW50ZXJcIiBzdHlsZT17c3R5bGVzLmVtcHR5Q29udGFpbmVyfT5cbiAgICAgICAgICAgIDxJY29uIG5hbWU9XCJ3cmVuY2hcIiBzdHlsZT17c3R5bGVzLmVtcHR5SWNvbn0gLz5cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXtzdHlsZXMuZW1wdHlUZXh0fT5cbiAgICAgICAgICAgICAgQ2xpcXVlIG5vIGJvdMOjbyBhY2ltYSBwYXJhIGFkaWNpb25hciB1bSBzZXJ2acOnby5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgICApfVxuICAgICAgICB7IWlzRmV0Y2hpbmcgJiYgIV8uaXNFbXB0eSh1c2VyLnNlcnZpY2VzKSAmJiAoXG4gICAgICAgICAgPFRhYmxlIGJhc2ljPVwidmVyeVwiIHN0eWxlPXt7IG1hcmdpbjogMCB9fT5cbiAgICAgICAgICAgIDxUYWJsZS5Cb2R5PlxuICAgICAgICAgICAgICB7Xy5tYXAodXNlci5zZXJ2aWNlcywgdWlkID0+XG4gICAgICAgICAgICAgICAgPFNlcnZpY2VcbiAgICAgICAgICAgICAgICAgIGtleT17dWlkfVxuICAgICAgICAgICAgICAgICAgdWlkPXt1aWR9XG4gICAgICAgICAgICAgICAgICBvbkVkaXQ9e3RoaXMuaGFuZGxlRWRpdH1cbiAgICAgICAgICAgICAgICAgIG9uUmVtb3ZlPXt0aGlzLmhhbmRsZVJlbW92ZX1cbiAgICAgICAgICAgICAgICAvPixcbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvVGFibGUuQm9keT5cbiAgICAgICAgICA8L1RhYmxlPlxuICAgICAgICApfVxuICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gIHVzZXI6IHNlbGVjdG9ycy5nZXRVc2VyKHN0YXRlKSxcbiAgaXNMb2dnZWQ6IHNlbGVjdG9ycy5pc0F1dGhlbnRpY2F0ZWQoc3RhdGUpLFxuICBpc0ZldGNoaW5nOiBzZWxlY3RvcnMuaXNGZXRjaGluZyhzdGF0ZSwgJ3NlcnZpY2VzJyksXG4gIGhhc1NlcnZpY2VzOiAhXy5pc0VtcHR5KHNlbGVjdG9ycy5nZXRFbnRpdGllcyhzdGF0ZSwgJ3NlcnZpY2VzJykpLFxufSk7XG5cbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGRpc3BhdGNoID0+ICh7XG4gIGFjdGlvbnM6IGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMpKFNlcnZpY2VzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC9vcmdhbml6YXRpb24vdGFicy9zZXJ2aWNlcy9zZXJ2aWNlcy5qc3giLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCB7IEJ1dHRvbiwgSWNvbiwgSGVhZGVyLCBMb2FkZXIsIE1vZGFsLCBUYWJsZSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuXG5jb25zdCBzdHlsZXMgPSB7XG4gIGVkaXQ6IHsgbWFyZ2luUmlnaHQ6IDEwIH0sXG4gIHJlbW92ZTogeyBtYXJnaW5Ub3A6IC0xIH0sXG4gIGxvYWRlcjogeyBtYXJnaW5MZWZ0OiA4LCBtYXJnaW5SaWdodDogNSwgcG9zaXRpb246ICdyZWxhdGl2ZScgfSxcbn07XG5cbmNsYXNzIFNlcnZpY2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGlzUmVtb3Zpbmc6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHNlcnZpY2U6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgdWlkOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uRWRpdDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZW1vdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGlzT3BlbjogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogZmFsc2UgfSk7XG4gIH07XG5cbiAgaGFuZGxlT3BlbiA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNPcGVuOiB0cnVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZVJlbW92ZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNPcGVuOiBmYWxzZSB9LCAoKSA9PiB7XG4gICAgICB0aGlzLnByb3BzLm9uUmVtb3ZlKHRoaXMucHJvcHMudWlkKTtcbiAgICB9KTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpc09wZW4gfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBpc1JlbW92aW5nLCBzZXJ2aWNlLCBvbkVkaXQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgdHJpZ2dlciA9IGlzUmVtb3ZpbmcgP1xuICAgICAgPHNwYW4gc3R5bGU9e3N0eWxlcy5sb2FkZXJ9PjxMb2FkZXIgYWN0aXZlIHNpemU9XCJtaW5pXCIgLz48L3NwYW4+IDpcbiAgICAgIDxJY29uIGxpbmsgbmFtZT1cInRyYXNoIG91dGxpbmVcIiBzdHlsZT17c3R5bGVzLnJlbW92ZX0gb25DbGljaz17dGhpcy5oYW5kbGVPcGVufSAvPjtcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFibGUuUm93PlxuICAgICAgICA8VGFibGUuQ2VsbD5cbiAgICAgICAgICA8SGVhZGVyIGFzPVwiaDRcIiBpbWFnZT5cbiAgICAgICAgICAgIDxJY29uIG5hbWU9XCJ3cmVuY2hcIiAvPlxuICAgICAgICAgICAgPEhlYWRlci5Db250ZW50PlxuICAgICAgICAgICAgICB7c2VydmljZS5uYW1lfVxuICAgICAgICAgICAgICA8SGVhZGVyLlN1YmhlYWRlcj5cbiAgICAgICAgICAgICAgICB7KHNlcnZpY2UuZGV0YWlscyB8fCAnJykubGVuZ3RoID4gMjAwID9cbiAgICAgICAgICAgICAgICAgIGAke3NlcnZpY2UuZGV0YWlscy5zdWJzdHIoMCwgMjAwKX0uLi5gIDpcbiAgICAgICAgICAgICAgICAgIHNlcnZpY2UuZGV0YWlsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPC9IZWFkZXIuU3ViaGVhZGVyPlxuICAgICAgICAgICAgPC9IZWFkZXIuQ29udGVudD5cbiAgICAgICAgICA8L0hlYWRlcj5cbiAgICAgICAgPC9UYWJsZS5DZWxsPlxuICAgICAgICA8VGFibGUuQ2VsbCBjb2xsYXBzaW5nPlxuICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICBsaW5rXG4gICAgICAgICAgICBuYW1lPVwiZWRpdFwiXG4gICAgICAgICAgICBzdHlsZT17c3R5bGVzLmVkaXR9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbkVkaXQoc2VydmljZS51aWQpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPE1vZGFsXG4gICAgICAgICAgICBzaXplPVwic21hbGxcIlxuICAgICAgICAgICAgb3Blbj17aXNPcGVufVxuICAgICAgICAgICAgdHJpZ2dlcj17dHJpZ2dlcn1cbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU9e2ZhbHNlfVxuICAgICAgICAgICAgY2xvc2VPblJvb3ROb2RlQ2xpY2s9e2ZhbHNlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxIZWFkZXIgc2l6ZT1cIm1pbmlcIiBjb250ZW50PVwiUmVtb3ZlciBTZXJ2acOnb1wiIC8+XG4gICAgICAgICAgICA8TW9kYWwuQ29udGVudD5cbiAgICAgICAgICAgICAgQ29uZmlybWFyIGEgcmVtb8Onw6NvIGRlIDxzdHJvbmc+e3NlcnZpY2UubmFtZX08L3N0cm9uZz4/XG4gICAgICAgICAgICA8L01vZGFsLkNvbnRlbnQ+XG4gICAgICAgICAgICA8TW9kYWwuQWN0aW9ucz5cbiAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsb3NlfT5cbiAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwicmVtb3ZlXCIgLz4gTsOjb1xuICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgPEJ1dHRvbiBjb2xvcj1cInJlZFwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlUmVtb3ZlfT5cbiAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwidHJhc2ggb3V0bGluZVwiIC8+IFNpbVxuICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDwvTW9kYWwuQWN0aW9ucz5cbiAgICAgICAgICA8L01vZGFsPlxuICAgICAgICA8L1RhYmxlLkNlbGw+XG4gICAgICA8L1RhYmxlLlJvdz5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChzdGF0ZSwgeyB1aWQgfSkgPT4gKHtcbiAgc2VydmljZTogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAnc2VydmljZXMnLCB1aWQpLFxuICBpc1JlbW92aW5nOiBzZWxlY3RvcnMuaXNSZW1vdmluZyhzdGF0ZSwgJ3NlcnZpY2VzJywgdWlkKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcykoU2VydmljZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvb3JnYW5pemF0aW9uL3RhYnMvc2VydmljZXMvc2VydmljZS5qc3giLCJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBCdXR0b24sIEZvcm0sIE1vZGFsIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IGdlblVJRCBmcm9tICd+L2hlbHBlcnMvZ2VuLXVpZCc7XG5pbXBvcnQgKiBhcyBhY3Rpb25DcmVhdG9ycyBmcm9tICd+L3N0b3JlL2FjdGlvbnMnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5cbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgaXNDcmVhdGluZ1NraWxsOiBmYWxzZSxcbiAgc2tpbGxzOiB7fSxcbiAgb3B0aW9uczogW10sXG4gIGZvcm1EYXRhOiB7XG4gICAgbmFtZTogJycsXG4gICAgZGV0YWlsczogJycsXG4gICAgcXR5QXZhaWxhYmxlOiAnJyxcbiAgICBza2lsbHM6IFtdLFxuICB9LFxufTtcblxuY2xhc3MgTW9kYWxTZXJ2aWNlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY3Rpb25zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHNlcnZpY2U6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgaXNPcGVuOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBpc1NhdmluZzogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgc2tpbGxzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2xvc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgc2VydmljZToge30sXG4gIH07XG5cbiAgc3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh7IHNraWxscyB9KSB7XG4gICAgaWYgKHNraWxscyAhPT0gdGhpcy5wcm9wcy5za2lsbHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc0NyZWF0aW5nU2tpbGw6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25DbG9zZSgpO1xuICB9O1xuXG4gIGhhbmRsZU9wZW4gPSAoKSA9PiB7XG4gICAgY29uc3QgeyBza2lsbHMsIHNlcnZpY2UgfSA9IHRoaXMucHJvcHM7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGlzQ3JlYXRpbmdTa2lsbDogZmFsc2UsXG4gICAgICBza2lsbHM6IF8ubWVyZ2Uoe30sIHNraWxscyksXG4gICAgICBvcHRpb25zOiBfLnZhbHVlcyhza2lsbHMpLm1hcCgoeyB1aWQsIG5hbWUgfSkgPT4gKHtcbiAgICAgICAgdGV4dDogbmFtZSxcbiAgICAgICAgdmFsdWU6IHVpZCxcbiAgICAgIH0pKSxcbiAgICAgIGZvcm1EYXRhOiB7XG4gICAgICAgIG5hbWU6IHNlcnZpY2UubmFtZSB8fCAnJyxcbiAgICAgICAgZGV0YWlsczogc2VydmljZS5kZXRhaWxzIHx8ICcnLFxuICAgICAgICBxdHlBdmFpbGFibGU6IHNlcnZpY2UucXR5QXZhaWxhYmxlIHx8ICcnLFxuICAgICAgICBza2lsbHM6IHNlcnZpY2Uuc2tpbGxzIHx8IFtdLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IChlLCBkYXRhID0ge30pID0+IHtcbiAgICBjb25zdCB7IHNraWxscywgb3B0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBmb3JtRGF0YSA9IF8ubWVyZ2Uoe30sIHRoaXMuc3RhdGUuZm9ybURhdGEpO1xuICAgIGNvbnN0IG5hbWUgPSBkYXRhLm5hbWUgfHwgZS5jdXJyZW50VGFyZ2V0Lm5hbWU7XG4gICAgY29uc3QgdmFsdWUgPSBkYXRhLnZhbHVlIHx8IGUuY3VycmVudFRhcmdldC52YWx1ZTtcblxuICAgIGlmIChuYW1lID09PSAnc2tpbGxzJykge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSB7fTtcbiAgICAgIGNvbnN0IG5ld1NraWxsID0gXy5yZW1vdmUodmFsdWUsIGF0dHIgPT4gIXNraWxsc1thdHRyXSlbMF07XG5cbiAgICAgIGlmIChuZXdTa2lsbCkge1xuICAgICAgICBjb25zdCB1aWQgPSBnZW5VSUQoJ3NraWxscycpO1xuXG4gICAgICAgIHNraWxsc1t1aWRdID0geyB1aWQsIG5hbWU6IG5ld1NraWxsIH07XG5cbiAgICAgICAgb3B0aW9ucy5wdXNoKHsgdGV4dDogbmV3U2tpbGwsIHZhbHVlOiB1aWQgfSk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG9wdGlvbnMsIHNraWxscyB9LCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5hY3Rpb25zLnNhdmUoJ3NraWxscycsIHNraWxsc1t1aWRdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3VmFsdWVbdWlkXSA9IHVpZDtcbiAgICAgIH1cblxuICAgICAgdmFsdWUuZm9yRWFjaCh1aWQgPT4gKG5ld1ZhbHVlW3VpZF0gPSB1aWQpKTtcblxuICAgICAgZm9ybURhdGFbbmFtZV0gPSBuZXdWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybURhdGFbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgZm9ybURhdGEgfSk7XG4gIH07XG5cbiAgaGFuZGxlU3VibWl0ID0gKGV2dCkgPT4ge1xuICAgIGNvbnN0IHsgZm9ybURhdGEgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgeyBhY3Rpb25zLCBzZXJ2aWNlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodGhpcy5pc1ZhbGlkKGZvcm1EYXRhKSkge1xuICAgICAgYWN0aW9ucy5hZGRUb09yZyh7XG4gICAgICAgIGVudGl0eTogJ3NlcnZpY2VzJyxcbiAgICAgICAgZGF0YTogXy5hc3NpZ24oe30sIHNlcnZpY2UsIGZvcm1EYXRhKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWQoZGF0YSkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSAhWyduYW1lJywgJ3F0eUF2YWlsYWJsZScsICdkZXRhaWxzJywgJ3NraWxscyddXG4gICAgICAubWFwKGF0dHIgPT4gZGF0YVthdHRyXSlcbiAgICAgIC5zb21lKHZhbCA9PiBfLmlzRW1wdHkodmFsKSk7XG5cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHRoaXMucHJvcHMuYWN0aW9ucy5ub3RpZnlFcnJvcignw4kgbmVjZXNzw6FyaW8gcHJlZW5jaGVyIG9zIGNhbXBvcyBvYnJpZ2F0w7NyaW9zJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWQ7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpc09wZW4sIGlzU2F2aW5nLCBzZXJ2aWNlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgZm9ybURhdGEsIG9wdGlvbnMsIGlzQ3JlYXRpbmdTa2lsbCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIHJldHVybiAoXG4gICAgICA8TW9kYWxcbiAgICAgICAgb3Blbj17aXNPcGVufVxuICAgICAgICBjbG9zZU9uRXNjYXBlPXtmYWxzZX1cbiAgICAgICAgY2xvc2VPblJvb3ROb2RlQ2xpY2s9e2ZhbHNlfVxuICAgICAgICBvbk1vdW50PXt0aGlzLmhhbmRsZU9wZW59XG4gICAgICAgIG9uQ2xvc2U9e3RoaXMuaGFuZGxlQ2xvc2V9XG4gICAgICA+XG4gICAgICAgIDxNb2RhbC5IZWFkZXI+XG4gICAgICAgICAge3NlcnZpY2UudWlkID8gJ0VkaXRhciBTZXJ2acOnbycgOiAnTm92byBTZXJ2acOnbyd9XG4gICAgICAgIDwvTW9kYWwuSGVhZGVyPlxuICAgICAgICA8TW9kYWwuQ29udGVudCBhcz17Rm9ybX0gb25TdWJtaXQ9e3RoaXMuaGFuZGxlU3VibWl0fT5cbiAgICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxuICAgICAgICAgICAgPEZvcm0uSW5wdXRcbiAgICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgICAgbmFtZT1cIm5hbWVcIlxuICAgICAgICAgICAgICBsYWJlbD1cIk5vbWVcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIk5vbWUgcXVlIHNlcsOhIGV4aWJpZG8gbm9zIHJlc3VsdGFkb3MgZGEgcGVzcXVpc2FcIlxuICAgICAgICAgICAgICBkaXNhYmxlZD17aXNTYXZpbmd9XG4gICAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YS5uYW1lfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPEZvcm0uSW5wdXRcbiAgICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgICAgbmFtZT1cInF0eUF2YWlsYWJsZVwiXG4gICAgICAgICAgICAgIGxhYmVsPVwiVmFnYXMgZGlzcG9uw612ZWlzXCJcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJOw7ptZXJvIGRlIHZhZ2FzIGRpc3BvbsOtdmVpc1wiXG4gICAgICAgICAgICAgIGRpc2FibGVkPXtpc1NhdmluZ31cbiAgICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLnF0eUF2YWlsYWJsZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0Zvcm0uR3JvdXA+XG4gICAgICAgICAgPEZvcm0uU2VsZWN0XG4gICAgICAgICAgICBmbHVpZFxuICAgICAgICAgICAgc2VhcmNoXG4gICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgbXVsdGlwbGVcbiAgICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICAgICAgYWxsb3dBZGRpdGlvbnNcbiAgICAgICAgICAgIG5hbWU9XCJza2lsbHNcIlxuICAgICAgICAgICAgbGFiZWw9XCJIYWJpbGlkYWRlc1wiXG4gICAgICAgICAgICBhZGRpdGlvbkxhYmVsPVwiQWRpY2lvbmFyOiBcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJEaWdpdGUgYXMgaGFiaWxpZGFkZXMgbmVjZXNzw6FyaWFzIHBhcmEgZXN0ZSBzZXJ2acOnb1wiXG4gICAgICAgICAgICBub1Jlc3VsdHNNZXNzYWdlPVwiTmVuaHVtIHJlc3VsdGFkbyBlbmNvbnRyYWRvXCJcbiAgICAgICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgICAgICBkaXNhYmxlZD17aXNTYXZpbmd9XG4gICAgICAgICAgICBsb2FkaW5nPXtpc0NyZWF0aW5nU2tpbGx9XG4gICAgICAgICAgICB2YWx1ZT17Xy5rZXlzKGZvcm1EYXRhLnNraWxscyl9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8Rm9ybS5UZXh0QXJlYVxuICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgIHJvd3M9XCI2XCJcbiAgICAgICAgICAgIG5hbWU9XCJkZXRhaWxzXCJcbiAgICAgICAgICAgIGxhYmVsPVwiRGV0YWxoZXNcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJEbyBxdWUgc2UgdHJhdGEgZXN0ZSBzZXJ2acOnbz9cIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzU2F2aW5nfVxuICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLmRldGFpbHN9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Nb2RhbC5Db250ZW50PlxuICAgICAgICA8TW9kYWwuQWN0aW9ucyBhcz17RmxleEVsZW1lbnR9IGp1c3RpZnk9XCJmbGV4LWVuZFwiPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIGNvbnRlbnQ9XCJGZWNoYXJcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2lzU2F2aW5nfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIHByaW1hcnlcbiAgICAgICAgICAgIGljb249XCJzYXZlXCJcbiAgICAgICAgICAgIGNvbnRlbnQ9XCJTYWx2YXJcIlxuICAgICAgICAgICAgbG9hZGluZz17aXNTYXZpbmd9XG4gICAgICAgICAgICBkaXNhYmxlZD17aXNTYXZpbmd9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZVN1Ym1pdH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L01vZGFsLkFjdGlvbnM+XG4gICAgICA8L01vZGFsPlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlLCB7IHVpZCB9KSA9PiAoe1xuICB1c2VyOiBzZWxlY3RvcnMuZ2V0VXNlcihzdGF0ZSksXG4gIHNraWxsczogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAnc2tpbGxzJyksXG4gIHNlcnZpY2U6IHNlbGVjdG9ycy5nZXRFbnRpdGllcyhzdGF0ZSwgJ3NlcnZpY2VzJywgdWlkKSxcbiAgaXNTYXZpbmc6IChcbiAgICBzZWxlY3RvcnMuaXNGZXRjaGluZyhzdGF0ZSwgJ3NlcnZpY2VzJykgfHxcbiAgICBzZWxlY3RvcnMuaXNGZXRjaGluZyhzdGF0ZSwgJ3VzZXJzJylcbiAgKSxcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoe1xuICBhY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShNb2RhbFNlcnZpY2UpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9mZWVkL29yZ2FuaXphdGlvbi90YWJzL3NlcnZpY2VzL21vZGFsLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUGFnZSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL3RocmVlLWNvbHVtbnMnO1xuaW1wb3J0IFBhbmVsIGZyb20gJy4vcGFuZWwnO1xuaW1wb3J0IERldGFpbHMgZnJvbSAnLi9kZXRhaWxzJztcbmltcG9ydCBSZWxhdGVkIGZyb20gJy4vcmVsYXRlZCc7XG5cbmNvbnN0IFVzdWFyaW8gPSBwcm9wcyA9PiAoXG4gIDxQYWdlXG4gICAgcGFuZWw9ezxQYW5lbCB7Li4ucHJvcHN9IC8+fVxuICAgIGNvbnRlbnQ9ezxEZXRhaWxzIHsuLi5wcm9wc30gLz59XG4gICAgcmVsYXRlZD17PFJlbGF0ZWQgey4uLnByb3BzfSAvPn1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFVzdWFyaW87XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvdm9sdW50ZWVyL2luZGV4LmpzIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgSGVhZGVyLCBMYWJlbCwgU2VnbWVudCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuXG5jb25zdCBzdHlsZSA9IHtcbiAgZm9udFNpemU6ICcxcmVtJyxcbiAgbWFyZ2luUmlnaHQ6ICcwLjhlbScsXG4gIHdpZHRoOiAnMTZlbScsXG59O1xuXG5jb25zdCBQYW5lbCA9ICh7IHNraWxscywgdXNlciB9KSA9PiAoXG4gIDxGbGV4RWxlbWVudCBjb2x1bW4gc3R5bGU9e3N0eWxlfT5cbiAgICA8U2VnbWVudD5cbiAgICAgIDxIZWFkZXIgYXM9XCJoNVwiIHN0eWxlPXt7IGZvbnRTaXplOiAnMC45NWVtJyB9fT5cbiAgICAgICAgTUlOSEFTIEhBQklMSURBREVTXG4gICAgICA8L0hlYWRlcj5cbiAgICAgIHtfLmtleXModXNlci5za2lsbHMsIGtleSA9PlxuICAgICAgICA8TGFiZWwga2V5PXtrZXl9PlxuICAgICAgICAgIHtza2lsbHNba2V5XS5uYW1lfVxuICAgICAgICA8L0xhYmVsPixcbiAgICAgICl9XG4gICAgICA8SGVhZGVyIGFzPVwiaDVcIiBzdHlsZT17eyBmb250U2l6ZTogJzAuOTVlbScgfX0+XG4gICAgICAgIFBST1BPU1RBUyBERSBTRVJWScOHT1NcbiAgICAgIDwvSGVhZGVyPlxuICAgICAgPEhlYWRlciBhcz1cImg1XCIgc3R5bGU9e3sgZm9udFNpemU6ICcwLjk1ZW0nIH19PlxuICAgICAgICBTRVJWScOHT1MgUkVBTElaQURPU1xuICAgICAgPC9IZWFkZXI+XG4gICAgPC9TZWdtZW50PlxuICA8L0ZsZXhFbGVtZW50PlxuKTtcblxuUGFuZWwucHJvcFR5cGVzID0ge1xuICBza2lsbHM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIHVzZXI6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG59O1xuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBzdGF0ZSA9PiAoe1xuICB1c2VyOiBzZWxlY3RvcnMuZ2V0VXNlcihzdGF0ZSksXG4gIHNraWxsczogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAnc2tpbGxzJyksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKFBhbmVsKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC92b2x1bnRlZXIvcGFuZWwuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBmYWtlciBmcm9tICdmYWtlcic7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgQ2FyZCwgQ29udGFpbmVyLCBGZWVkLCBJbWFnZSB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCAqIGFzIGFjdGlvbkNyZWF0b3JzIGZyb20gJ34vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgc2VsZWN0b3JzIGZyb20gJ34vc3RvcmUvc2VsZWN0b3JzJztcblxuY29uc3Qgc3JjSW1nID0gJ2h0dHA6Ly94cGVub2xvZ3kub3JnL3dwLWNvbnRlbnQvdGhlbWVzL3FhZW5naW5lL2ltZy9kZWZhdWx0LXRodW1ibmFpbC5qcGcnO1xuXG5jb25zdCBzdHlsZSA9IHtcbiAgZm9udFNpemU6ICcxcmVtJyxcbn07XG5cbmNvbnN0IERldGFpbHMgPSAoKSA9PiAoXG4gIDxDb250YWluZXIgZmx1aWQgc3R5bGU9e3N0eWxlfT5cbiAgICA8Q2FyZCBmbHVpZD5cbiAgICAgIDxDYXJkLkNvbnRlbnQ+XG4gICAgICAgIDxJbWFnZSBmbG9hdGVkPVwibGVmdFwiIHNpemU9XCJzbWFsbFwiIHNyYz17c3JjSW1nfSAvPlxuICAgICAgICA8Q2FyZC5IZWFkZXIgc3R5bGU9e3sgZm9udFNpemU6ICcxZW0nLCBtYXJnaW5Cb3R0b206ICcwLjNlbScgfX0+XG4gICAgICAgICAgTk9NRSBEQSBDQU1QQU5IQVxuICAgICAgICA8L0NhcmQuSGVhZGVyPlxuICAgICAgICA8Q2FyZC5NZXRhPlxuICAgICAgICAgIHtmYWtlci5sb3JlbS5wYXJhZ3JhcGgoNCl9XG4gICAgICAgIDwvQ2FyZC5NZXRhPlxuICAgICAgPC9DYXJkLkNvbnRlbnQ+XG4gICAgPC9DYXJkPlxuICAgIDxDYXJkIGZsdWlkPlxuICAgICAgPENhcmQuQ29udGVudD5cbiAgICAgICAgPENhcmQuSGVhZGVyIHN0eWxlPXt7IGZvbnRTaXplOiAnMWVtJyB9fT5cbiAgICAgICAgICBGRUVEIERFIE5PVMONQ0lBU1xuICAgICAgICA8L0NhcmQuSGVhZGVyPlxuICAgICAgPC9DYXJkLkNvbnRlbnQ+XG4gICAgICA8Q2FyZC5Db250ZW50PlxuICAgICAgICA8RmVlZD5cbiAgICAgICAgICA8RmVlZC5FdmVudD5cbiAgICAgICAgICAgIDxGZWVkLkxhYmVsIGltYWdlPVwiaHR0cDovL3NlbWFudGljLXVpLmNvbS9pbWFnZXMvYXZhdGFyL3NtYWxsL2plbm55LmpwZ1wiIC8+XG4gICAgICAgICAgICA8RmVlZC5Db250ZW50PlxuICAgICAgICAgICAgICA8RmVlZC5EYXRlIGNvbnRlbnQ9XCIxIGRheSBhZ29cIiAvPlxuICAgICAgICAgICAgICA8RmVlZC5TdW1tYXJ5PlxuICAgICAgICAgICAgICAgIFlvdSBhZGRlZCA8YT5KZW5ueSBIZXNzPC9hPiB0byB5b3VyIDxhPmNvd29ya2VyPC9hPiBncm91cC5cbiAgICAgICAgICAgICAgPC9GZWVkLlN1bW1hcnk+XG4gICAgICAgICAgICA8L0ZlZWQuQ29udGVudD5cbiAgICAgICAgICA8L0ZlZWQuRXZlbnQ+XG5cbiAgICAgICAgICA8RmVlZC5FdmVudD5cbiAgICAgICAgICAgIDxGZWVkLkxhYmVsIGltYWdlPVwiaHR0cDovL3NlbWFudGljLXVpLmNvbS9pbWFnZXMvYXZhdGFyMi9zbWFsbC9tb2xseS5wbmdcIiAvPlxuICAgICAgICAgICAgPEZlZWQuQ29udGVudD5cbiAgICAgICAgICAgICAgPEZlZWQuRGF0ZSBjb250ZW50PVwiMyBkYXlzIGFnb1wiIC8+XG4gICAgICAgICAgICAgIDxGZWVkLlN1bW1hcnk+XG4gICAgICAgICAgICAgICAgWW91IGFkZGVkIDxhPk1vbGx5IE1hbG9uZTwvYT4gYXMgYSBmcmllbmQuXG4gICAgICAgICAgICAgIDwvRmVlZC5TdW1tYXJ5PlxuICAgICAgICAgICAgPC9GZWVkLkNvbnRlbnQ+XG4gICAgICAgICAgPC9GZWVkLkV2ZW50PlxuXG4gICAgICAgICAgPEZlZWQuRXZlbnQ+XG4gICAgICAgICAgICA8RmVlZC5MYWJlbCBpbWFnZT1cImh0dHA6Ly9zZW1hbnRpYy11aS5jb20vaW1hZ2VzL2F2YXRhci9zbWFsbC9lbGxpb3QuanBnXCIgLz5cbiAgICAgICAgICAgIDxGZWVkLkNvbnRlbnQ+XG4gICAgICAgICAgICAgIDxGZWVkLkRhdGUgY29udGVudD1cIjQgZGF5cyBhZ29cIiAvPlxuICAgICAgICAgICAgICA8RmVlZC5TdW1tYXJ5PlxuICAgICAgICAgICAgICAgIFlvdSBhZGRlZCA8YT5FbGxpb3QgQmFrZXI8L2E+IHRvIHlvdXIgPGE+bXVzaWNpYW5zPC9hPiBncm91cC5cbiAgICAgICAgICAgICAgPC9GZWVkLlN1bW1hcnk+XG4gICAgICAgICAgICA8L0ZlZWQuQ29udGVudD5cbiAgICAgICAgICA8L0ZlZWQuRXZlbnQ+XG4gICAgICAgIDwvRmVlZD5cbiAgICAgIDwvQ2FyZC5Db250ZW50PlxuICAgIDwvQ2FyZD5cbiAgPC9Db250YWluZXI+XG4pO1xuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSAoc3RhdGUsIHsgcGFyYW1zOiB7IGlkIH0gfSkgPT4gKHtcbiAgdXNlcjogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAndXNlcnMnLCBpZCksXG4gIHNraWxsczogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAnc2tpbGxzJyksXG59KTtcblxuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gZGlzcGF0Y2ggPT4gKHtcbiAgYWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcykoRGV0YWlscyk7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvZmVlZC92b2x1bnRlZXIvZGV0YWlscy5qc3giLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvZmFrZXIvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIF9fX0FHRU5DSUFfQU1JR0FfX19cbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgSGVhZGVyLCBTZWdtZW50IH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5cbmNvbnN0IFJlbGF0ZWQgPSAoKSA9PiAoXG4gIDxGbGV4RWxlbWVudCBjb2x1bW4gc3R5bGU9e3sgbWFyZ2luTGVmdDogJzAuOGVtJywgd2lkdGg6ICcxNmVtJyB9fT5cbiAgICA8U2VnbWVudD5cbiAgICAgIDxIZWFkZXIgYXM9XCJoNVwiIHN0eWxlPXt7IGZvbnRTaXplOiAnMC45NWVtJyB9fT5cbiAgICAgICAgU0VSVknDh09TIERFIElOVEVSRVNTRVxuICAgICAgPC9IZWFkZXI+XG4gICAgPC9TZWdtZW50PlxuICA8L0ZsZXhFbGVtZW50PlxuKTtcblxuUmVsYXRlZC5wcm9wVHlwZXMgPSB7XG4gIHNraWxsczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgdXNlcjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbn07XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gIHVzZXI6IHNlbGVjdG9ycy5nZXRVc2VyKHN0YXRlKSxcbiAgc2tpbGxzOiBzZWxlY3RvcnMuZ2V0RW50aXRpZXMoc3RhdGUsICdza2lsbHMnKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcykoUmVsYXRlZCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2ZlZWQvdm9sdW50ZWVyL3JlbGF0ZWQuanN4IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQYWdlIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdGhyZWUtY29sdW1ucyc7XG5pbXBvcnQgRmlsdGVycyBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IFJlc3VsdHMgZnJvbSAnLi9yZXN1bHRzJztcblxuY29uc3QgQnVzY2FyID0gcHJvcHMgPT4gKFxuICA8UGFnZVxuICAgIHBhbmVsPXs8RmlsdGVycyB7Li4ucHJvcHN9IC8+fVxuICAgIGNvbnRlbnQ9ezxSZXN1bHRzIHsuLi5wcm9wc30gLz59XG4gIC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBCdXNjYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2J1c2Nhci9pbmRleC5qcyIsImltcG9ydCBjbiBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbGF0aW5pemUgZnJvbSAnbGF0aW5pemUnO1xuaW1wb3J0IHsgZmluZCwgdmFsdWVzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBCdXR0b24sIERpdmlkZXIsIERyb3Bkb3duLCBGb3JtLCBIZWFkZXIsIEljb24sIFNlZ21lbnQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICd+L2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBhY3Rpb25DcmVhdG9ycyBmcm9tICd+L3N0b3JlL2FjdGlvbnMnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vZmlsdGVycy5zY3NzJztcblxuY2xhc3MgRmlsdGVycyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBpc0ZpbHRlcmluZzogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgYXBwbGllZEZpbHRlcjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBza2lsbHM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIH07XG5cbiAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICByb3V0ZXI6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBoYW5kbGVDbGVhciA9ICgpID0+IHtcbiAgICB0aGlzLmRyb3Bkb3duLnNldFZhbHVlKCcnKTtcbiAgICB0aGlzLnByb3BzLmFjdGlvbnMudXBkYXRlRmlsdGVyKHsgc2tpbGxzOiBudWxsIH0pO1xuICB9O1xuXG4gIGhhbmRsZVNlYXJjaCA9ICgpID0+IHtcbiAgICBjb25zdCBza2lsbHMgPSB0aGlzLmRyb3Bkb3duLnN0YXRlLnZhbHVlO1xuXG4gICAgdGhpcy5wcm9wcy5hY3Rpb25zLnVwZGF0ZUZpbHRlcih7IHNraWxscyB9KTtcblxuICAgIHRoaXMuYXBwbHlTZWFyY2godGhpcy5wcm9wcy5hcHBsaWVkRmlsdGVyLmZpbHRlcik7XG4gIH07XG5cbiAgaGFuZGxlRmlsdGVyQ2xpY2sgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCB7IHRyYW5zaXRpb25UbyB9ID0gdGhpcy5jb250ZXh0LnJvdXRlcjtcbiAgICBjb25zdCB7IGFjdGlvbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB0ZXh0IH0gPSBmaW5kKEZpbHRlci5PUFRJT05TLCB7IHZhbHVlIH0pO1xuICAgIGNvbnN0IHNsdWcgPSBsYXRpbml6ZSh0ZXh0KS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdHJhbnNpdGlvblRvKHtcbiAgICAgIHBhdGhuYW1lOiAnL2J1c2NhcicsXG4gICAgICBxdWVyeTogdmFsdWUgPT09ICdhbGwnID8gbnVsbCA6IHsgZmlsdHJvOiBzbHVnIH0sXG4gICAgfSk7XG5cbiAgICBhY3Rpb25zLnVwZGF0ZUZpbHRlcih7IGZpbHRlcjogdmFsdWUgfSk7XG4gICAgdGhpcy5hcHBseVNlYXJjaCh2YWx1ZSk7XG4gIH07XG5cbiAgYXBwbHlTZWFyY2goZW50aXR5KSB7XG4gICAgdGhpcy5wcm9wcy5hY3Rpb25zLnJlYWQoeyBlbnRpdHkgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpc0ZpbHRlcmluZywgYXBwbGllZEZpbHRlciwgc2tpbGxzIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxGbGV4RWxlbWVudCBjb2x1bW4gY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgICAgIDxTZWdtZW50PlxuICAgICAgICAgIDxGbGV4RWxlbWVudCBjb2x1bW4gY2xhc3NOYW1lPXtzdHlsZXMubWVudX0+XG4gICAgICAgICAgICB7RmlsdGVyLk9QVElPTlMubWFwKG9wdGlvbiA9PlxuICAgICAgICAgICAgICA8RmxleEVsZW1lbnRcbiAgICAgICAgICAgICAgICBhbGlnbj1cImNlbnRlclwiXG4gICAgICAgICAgICAgICAga2V5PXtvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbihzdHlsZXMubWVudUl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgIFtzdHlsZXMuc2VsZWN0ZWRdOiBvcHRpb24udmFsdWUgPT09IGFwcGxpZWRGaWx0ZXIuZmlsdGVyLFxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHRoaXMuaGFuZGxlRmlsdGVyQ2xpY2sob3B0aW9uLnZhbHVlKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9e29wdGlvbi5pY29ufSAvPlxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpbkxlZnQ6ICcwLjVlbScgfX0+e29wdGlvbi50ZXh0fTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9GbGV4RWxlbWVudD4sXG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICAgICAgPERpdmlkZXIgLz5cbiAgICAgICAgICA8RmxleEVsZW1lbnQgY29sdW1uPlxuICAgICAgICAgICAgPEhlYWRlciBhcz1cImg1XCI+RmlsdHJhciBwb3I6PC9IZWFkZXI+XG4gICAgICAgICAgICA8Rm9ybSBjbGFzc05hbWU9e3N0eWxlcy5zZWFyY2hGb3JtfSBvblN1Ym1pdD17dGhpcy5oYW5kbGVTZWFyY2h9PlxuICAgICAgICAgICAgICA8RHJvcGRvd25cbiAgICAgICAgICAgICAgICBmbHVpZFxuICAgICAgICAgICAgICAgIHNlYXJjaFxuICAgICAgICAgICAgICAgIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzRmlsdGVyaW5nfVxuICAgICAgICAgICAgICAgIHJlZj17ZWwgPT4gKHRoaXMuZHJvcGRvd24gPSBlbCl9XG4gICAgICAgICAgICAgICAgbm9SZXN1bHRzTWVzc2FnZT1cIk5lbmh1bSByZWdpc3RybyBlbmNvbnRyYWRvXCJcbiAgICAgICAgICAgICAgICBvcHRpb25zPXt2YWx1ZXMoc2tpbGxzKS5tYXAoKHsgbmFtZSwgdWlkIH0pID0+ICh7IHRleHQ6IG5hbWUsIHZhbHVlOiB1aWQgfSkpfVxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiSGFiaWxpZGFkZXMuLi5cIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICB7LypcbiAgICAgICAgICAgICAgPElucHV0IGZsdWlkIHBsYWNlaG9sZGVyPVwiTG9jYWxpemHDp8Ojby4uLlwiIHN0eWxlPXt7IG1hcmdpblRvcDogJzFlbScgfX0gLz5cbiAgICAgICAgICAgICAgKi99XG4gICAgICAgICAgICA8L0Zvcm0+XG4gICAgICAgICAgICA8RmxleEVsZW1lbnQganVzdGlmeT1cInNwYWNlLWJldHdlZW5cIiBzdHlsZT17eyBtYXJnaW5Ub3A6ICcxZW0nIH19PlxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgcHJpbWFyeVxuICAgICAgICAgICAgICAgIHNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzRmlsdGVyaW5nfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlU2VhcmNofVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQnVzY2FyXG4gICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbWFsbFwiIGRpc2FibGVkPXtpc0ZpbHRlcmluZ30gb25DbGljaz17dGhpcy5oYW5kbGVDbGVhcn0+XG4gICAgICAgICAgICAgICAgTGltcGFyXG4gICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgICA8L1NlZ21lbnQ+XG4gICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gc3RhdGUgPT4gKHtcbiAgYXBwbGllZEZpbHRlcjogc2VsZWN0b3JzLmdldEFwcGxpZWRGaWx0ZXIoc3RhdGUpLFxuICBpc0ZpbHRlcmluZzogc2VsZWN0b3JzLmlzRmlsdGVyaW5nKHN0YXRlKSxcbiAgc2tpbGxzOiBzZWxlY3RvcnMuZ2V0RW50aXRpZXMoc3RhdGUsICdza2lsbHMnKSxcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoe1xuICBhY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShGaWx0ZXJzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL2ZpbHRlcnMuanN4IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2ZpbHRlcnMuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2ZpbHRlcnMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vZmlsdGVycy5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb250ZW50L2J1c2Nhci9maWx0ZXJzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL2ZpbHRlcnMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5maWx0ZXJzX193cmFwcGVyX19oYV8tRGRUMlhNIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbi1yaWdodDogLjhlbTtcXG4gIHdpZHRoOiAxNWVtOyB9XFxuXFxuLmZpbHRlcnNfX21lbnVfXzNYNmRTY2F3bU8ge1xcbiAgbWFyZ2luOiAtMC41ZW0gLTFlbSAxZW07IH1cXG5cXG4uZmlsdGVyc19fbWVudUl0ZW1fXzJVd1JGOGRDaUEge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLWxlZnQ6IDVweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHBhZGRpbmc6IC41ZW0gLjdlbTsgfVxcbiAgLmZpbHRlcnNfX21lbnVJdGVtX18yVXdSRjhkQ2lBLmZpbHRlcnNfX3NlbGVjdGVkX18yYUFNTURKdlBrIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogI2RkZDtcXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6ICMyOTg3Q0Q7IH1cXG4gIC5maWx0ZXJzX19tZW51SXRlbV9fMlV3UkY4ZENpQTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGYwZjA7IH1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL3NyYy92aWV3cy9jb250ZW50L2J1c2Nhci9maWx0ZXJzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxnQkFBZ0I7RUFDaEIsbUJBQW1CO0VBQ25CLFlBQVksRUFDYjs7QUFFRDtFQUNFLHdCQUF3QixFQUN6Qjs7QUFFRDtFQUNFLHFDQUFxQztFQUNyQyxtQ0FBbUM7RUFDbkMsa0NBQWtDO0VBQ2xDLGdCQUFnQjtFQUNoQixtQkFBbUIsRUFZcEI7RUFqQkQ7SUFRSSwwQkFBMEI7SUFDMUIsMEJBQTBCO0lBQzFCLHVCQUF1QjtJQUN2QiwyQkFBMkIsRUFDNUI7RUFaSDtJQWVJLDBCQUEwQixFQUMzQlwiLFwiZmlsZVwiOlwiZmlsdGVycy5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi53cmFwcGVyIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbi1yaWdodDogLjhlbTtcXG4gIHdpZHRoOiAxNWVtO1xcbn1cXG5cXG4ubWVudSB7XFxuICBtYXJnaW46IC0wLjVlbSAtMWVtIDFlbTtcXG59XFxuXFxuLm1lbnVJdGVtIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1sZWZ0OiA1cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBwYWRkaW5nOiAuNWVtIC43ZW07XFxuXFxuICAmLnNlbGVjdGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogI2RkZDtcXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6ICMyOTg3Q0Q7XFxuICB9XFxuXFxuICAmOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcXG4gIH1cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJ3cmFwcGVyXCI6IFwiZmlsdGVyc19fd3JhcHBlcl9faGFfLURkVDJYTVwiLFxuXHRcIm1lbnVcIjogXCJmaWx0ZXJzX19tZW51X18zWDZkU2Nhd21PXCIsXG5cdFwibWVudUl0ZW1cIjogXCJmaWx0ZXJzX19tZW51SXRlbV9fMlV3UkY4ZENpQVwiLFxuXHRcInNlbGVjdGVkXCI6IFwiZmlsdGVyc19fc2VsZWN0ZWRfXzJhQU1NREp2UGtcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi9+L3Bvc3Rjc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlcj9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9idXNjYXIvZmlsdGVycy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9idXNjYXIvZmlsdGVycy5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbGF0aW5pemUgZnJvbSAnbGF0aW5pemUnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgaXNFbXB0eSwgbWFwLCBmaW5kIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBDYXJkLCBJY29uLCBJbWFnZSwgU2VnbWVudCwgTG9hZGVyIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnfi9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgYWN0aW9uQ3JlYXRvcnMgZnJvbSAnfi9zdG9yZS9hY3Rpb25zJztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3Jlc3VsdHMuc2Nzcyc7XG5cbi8vIGNvbnN0IHRpbWVvdXRJRCA9IG51bGw7XG5cbmNsYXNzIFJlc3VsdHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgaXNGaWx0ZXJpbmc6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIC8vIGlzTG9nZ2VkOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBsb2NhdGlvbjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICByZWNvcmRzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG4gICAgLy8gYXBwbGllZEZpbHRlcjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgfTtcblxuICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgIHJvdXRlcjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBjb25zdCB7IGFjdGlvbnMgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5nZXRGaWx0ZXIoKTtcblxuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIGFjdGlvbnMudXBkYXRlRmlsdGVyKHsgZmlsdGVyIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIGNvbnN0IHsgYWN0aW9ucywgYXBwbGllZEZpbHRlciwgcmVjb3JkcywgaXNGaWx0ZXJpbmcsIGlzTG9nZ2VkIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIGNvbnN0IGZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyKCkgfHwgYXBwbGllZEZpbHRlci5maWx0ZXI7XG5cbiAgICAvLyBpZiAoaXNFbXB0eShyZWNvcmRzKSAmJiAhaXNGaWx0ZXJpbmcgJiYgIXRpbWVvdXRJRCAmJiBpc0xvZ2dlZCkge1xuICAgIC8vICAgYWN0aW9ucy5yZWFkKHsgZW50aXR5OiBmaWx0ZXIgfSk7XG5cbiAgICAvLyAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4gKHRpbWVvdXRJRCA9IG51bGwpLCAxMDAwMCk7XG4gICAgLy8gfVxuICB9XG5cbiAgZ2V0RmlsdGVyKCkge1xuICAgIGNvbnN0IHsgZmlsdHJvIH0gPSB0aGlzLnByb3BzLmxvY2F0aW9uLnF1ZXJ5IHx8IHt9O1xuXG4gICAgaWYgKGZpbHRybykge1xuICAgICAgY29uc3QgY29tcGFyYXRvciA9IG9wdGlvbiA9PiBmaWx0cm8gPT09IGxhdGluaXplKG9wdGlvbi50ZXh0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gZmluZChGaWx0ZXIuT1BUSU9OUywgY29tcGFyYXRvcikgfHwge307XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG5hdmlnYXRlVG8oZW50aXR5LCBpZCkge1xuICAgIGNvbnN0IHsgdHJhbnNpdGlvblRvIH0gPSB0aGlzLmNvbnRleHQucm91dGVyO1xuICAgIGNvbnN0IHsgdGV4dCB9ID0gZmluZChGaWx0ZXIuT1BUSU9OUywgeyB2YWx1ZTogZW50aXR5IH0pO1xuICAgIGNvbnN0IHNsdWcgPSBsYXRpbml6ZSh0ZXh0KS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdHJhbnNpdGlvblRvKGAvJHtzbHVnfS8ke2lkfWApO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgcmVjb3JkcywgaXNGaWx0ZXJpbmcgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoaXNGaWx0ZXJpbmcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxTZWdtZW50IGJhc2ljIHN0eWxlPXt7IGhlaWdodDogJzEwMCUnLCB3aWR0aDogJzEwMCUnIH19PlxuICAgICAgICAgIDxMb2FkZXIgYWN0aXZlIHNpemU9XCJzbWFsbFwiIC8+XG4gICAgICAgIDwvU2VnbWVudD5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0ZpbHRlcmluZyAmJiBpc0VtcHR5KHJlY29yZHMpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8RmxleEVsZW1lbnQgY29sdW1uIGZ1bGwgYWxpZ249XCJjZW50ZXJcIiBqdXN0aWZ5PVwiY2VudGVyXCIgY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgICAgICAgPEljb24gbmFtZT1cImNsb3VkXCIgc2l6ZT1cIm1hc3NpdmVcIiBzdHlsZT17eyBjb2xvcjogJ3JnYmEoMCwwLDAsIDAuMSknIH19IC8+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6ICdyZ2JhKDAsMCwwLCAwLjQ1KScgfX0+XG4gICAgICAgICAgICBOZW5odW0gcmVzdWx0YWRvIGVuY29udHJhZG8gOihcbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8RmxleEVsZW1lbnQgY29sdW1uIGZ1bGwgY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgICAgIHsvKlxuICAgICAgICA8RmxleEVsZW1lbnQgYWxpZ249XCJjZW50ZXJcIiBjbGFzc05hbWU9e3N0eWxlcy5zb3J0aW5nfT5cbiAgICAgICAgICA8c3Ryb25nPk9yZGVuYXIgcG9yOjwvc3Ryb25nPlxuICAgICAgICAgIDxhIGhyZWY9XCIjL1wiIGNsYXNzTmFtZT17c3R5bGVzLnNlbGVjdGVkfT5NYWlzIFJlY2VudGU8L2E+PHNwYW4+fDwvc3Bhbj5cbiAgICAgICAgICA8YSBocmVmPVwiIy9cIj5NYWlzIEFudGlnbzwvYT48c3Bhbj58PC9zcGFuPlxuICAgICAgICAgIDxhIGhyZWY9XCIjL1wiPlBvcHVsYXJpZGFkZTwvYT5cbiAgICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgICAgKi99XG4gICAgICAgIDxDYXJkLkdyb3VwIGl0ZW1zUGVyUm93PXs0fSBjbGFzc05hbWU9e3N0eWxlcy5jYXJkc30+XG4gICAgICAgICAge21hcChyZWNvcmRzLCAocmVjb3JkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBtb21lbnQocmVjb3JkLmNyZWF0ZWRfYXQpO1xuICAgICAgICAgICAgY29uc3QgeyBpY29uIH0gPSBmaW5kKEZpbHRlci5PUFRJT05TLCB7IHZhbHVlOiByZWNvcmQuZW50aXR5IH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8Q2FyZFxuICAgICAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNhcmR9XG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5uYXZpZ2F0ZVRvKHJlY29yZC5lbnRpdHksIHJlY29yZC5pZCl9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8Q2FyZC5Db250ZW50PlxuICAgICAgICAgICAgICAgICAge3JlY29yZC5pbWFnZSA/XG4gICAgICAgICAgICAgICAgICAgIDxJbWFnZSBmbG9hdGVkPVwibGVmdFwiIHNpemU9XCJtaW5pXCIgc3JjPXtyZWNvcmQuaW1hZ2V9IC8+IDpcbiAgICAgICAgICAgICAgICAgICAgPEljb24gY2xhc3NOYW1lPXtzdHlsZXMuY2FyZEljb259IG5hbWU9e2ljb259IGNvbG9yPVwiYmxhY2tcIiAvPlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgPENhcmQuSGVhZGVyPntyZWNvcmQudGl0bGV9PC9DYXJkLkhlYWRlcj5cbiAgICAgICAgICAgICAgICAgIDxDYXJkLk1ldGE+e3JlY29yZC5tZXRhfTwvQ2FyZC5NZXRhPlxuICAgICAgICAgICAgICAgICAgPENhcmQuRGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIHtyZWNvcmQuZGVzY3JpcHRpb24ubGVuZ3RoIC0gMyA+IDEwMCA/XG4gICAgICAgICAgICAgICAgICAgICAgYCR7cmVjb3JkLmRlc2NyaXB0aW9uLnNsaWNlKDAsIDEwMCl9Li4uYCA6XG4gICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIDwvQ2FyZC5EZXNjcmlwdGlvbj5cbiAgICAgICAgICAgICAgICA8L0NhcmQuQ29udGVudD5cbiAgICAgICAgICAgICAgICA8Q2FyZC5Db250ZW50IGV4dHJhPlxuICAgICAgICAgICAgICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBhbGlnbj1cImZsZXgtZW5kXCI+XG4gICAgICAgICAgICAgICAgICAgIHsvKlxuICAgICAgICAgICAgICAgICAgICA8UmF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiaGVhcnRcIlxuICAgICAgICAgICAgICAgICAgICAgIHJhdGluZz17M31cbiAgICAgICAgICAgICAgICAgICAgICBtYXhSYXRpbmc9ezV9XG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAnMC41ZW0nIH19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICovfVxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICB7ZGF0ZS5pc1ZhbGlkKCkgJiYgZGF0ZS5mcm9tTm93KCl9XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICAgICAgICAgICAgPC9DYXJkLkNvbnRlbnQ+XG4gICAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSl9XG4gICAgICAgIDwvQ2FyZC5Hcm91cD5cbiAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBzdGF0ZSA9PiAoe1xuICBpc0xvZ2dlZDogc2VsZWN0b3JzLmlzQXV0aGVudGljYXRlZChzdGF0ZSksXG4gIGlzRmlsdGVyaW5nOiBzZWxlY3RvcnMuaXNGaWx0ZXJpbmcoc3RhdGUpLFxuICBhcHBsaWVkRmlsdGVyOiBzZWxlY3RvcnMuZ2V0QXBwbGllZEZpbHRlcihzdGF0ZSksXG4gIHJlY29yZHM6IHNlbGVjdG9ycy5nZXRTZWFyY2hSZXN1bHRzKHN0YXRlKSxcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoe1xuICBhY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShSZXN1bHRzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL3Jlc3VsdHMuanN4IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3Jlc3VsdHMuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3Jlc3VsdHMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vcmVzdWx0cy5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb250ZW50L2J1c2Nhci9yZXN1bHRzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL3Jlc3VsdHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5yZXN1bHRzX193cmFwcGVyX18yZDBsRzhub0N0IHtcXG4gIGZvbnQtc2l6ZTogMXJlbTsgfVxcblxcbi5yZXN1bHRzX19zb3J0aW5nX18xbzlGb0FrcF9yIHtcXG4gIHBhZGRpbmc6IC41ZW0gLjVlbSAxLjVlbTsgfVxcbiAgLnJlc3VsdHNfX3NvcnRpbmdfXzFvOUZvQWtwX3IgYS5yZXN1bHRzX19zZWxlY3RlZF9fMVpvTi04QW5BUSB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgfVxcbiAgLnJlc3VsdHNfX3NvcnRpbmdfXzFvOUZvQWtwX3Igc3Ryb25nIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAuNWVtOyB9XFxuICAucmVzdWx0c19fc29ydGluZ19fMW85Rm9Ba3BfciBzcGFuIHtcXG4gICAgbWFyZ2luOiAwIC41ZW07IH1cXG5cXG4ucmVzdWx0c19fY2FyZHNfX0RWS0dlYjQtOHMge1xcbiAgbWFyZ2luLWxlZnQ6IC0wLjNlbSAhaW1wb3J0YW50O1xcbiAgbWFyZ2luLXJpZ2h0OiAtMC41ZW0gIWltcG9ydGFudDsgfVxcblxcbi5yZXN1bHRzX19jYXJkX18zQXJoa21wTzRtIHtcXG4gIGN1cnNvcjogcG9pbnRlcjsgfVxcbiAgLnJlc3VsdHNfX2NhcmRfXzNBcmhrbXBPNG06aG92ZXIge1xcbiAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggI0Q0RDRENSwgMCAycHggNHB4IDAgcmdiYSgzNCwgMzYsIDM4LCAwLjEyKSwgMCAycHggMTBweCAwIHJnYmEoMzQsIDM2LCAzOCwgMC4xNSkgIWltcG9ydGFudDsgfVxcblxcbi5yZXN1bHRzX19jYXJkSWNvbl9fMWFES3dlM0xsMyB7XFxuICBmbG9hdDogbGVmdCAhaW1wb3J0YW50O1xcbiAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxuICB3aWR0aDogMzVweCAhaW1wb3J0YW50O1xcbiAgZm9udC1zaXplOiAyZW0gIWltcG9ydGFudDtcXG4gIG1hcmdpbi1ib3R0b206IDEwcHggIWltcG9ydGFudDtcXG4gIG1hcmdpbi1yaWdodDogMTBweCAhaW1wb3J0YW50O1xcbiAgbWFyZ2luLXRvcDogNXB4ICFpbXBvcnRhbnQ7IH1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL3NyYy92aWV3cy9jb250ZW50L2J1c2Nhci9yZXN1bHRzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxnQkFBZ0IsRUFDakI7O0FBRUQ7RUFDRSx5QkFBeUIsRUFjMUI7RUFmRDtJQUlJLGtCQUFrQjtJQUNsQiwyQkFBMkIsRUFDNUI7RUFOSDtJQVNJLG1CQUFtQixFQUNwQjtFQVZIO0lBYUksZUFBZSxFQUNoQjs7QUFHSDtFQUNFLCtCQUErQjtFQUMvQixnQ0FBZ0MsRUFDakM7O0FBRUQ7RUFDRSxnQkFBZ0IsRUFRakI7RUFURDtJQUlJLGtIQUc0QyxFQUM3Qzs7QUFHSDtFQUNFLHVCQUF1QjtFQUN2Qix3QkFBd0I7RUFDeEIsdUJBQXVCO0VBQ3ZCLDBCQUEwQjtFQUMxQiwrQkFBK0I7RUFDL0IsOEJBQThCO0VBQzlCLDJCQUEyQixFQUM1QlwiLFwiZmlsZVwiOlwicmVzdWx0cy5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi53cmFwcGVyIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG59XFxuXFxuLnNvcnRpbmcge1xcbiAgcGFkZGluZzogLjVlbSAuNWVtIDEuNWVtO1xcblxcbiAgYS5zZWxlY3RlZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIH1cXG5cXG4gIHN0cm9uZyB7XFxuICAgIG1hcmdpbi1yaWdodDogLjVlbTtcXG4gIH1cXG5cXG4gIHNwYW4ge1xcbiAgICBtYXJnaW46IDAgLjVlbTtcXG4gIH1cXG59XFxuXFxuLmNhcmRzIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMC4zZW0gIWltcG9ydGFudDtcXG4gIG1hcmdpbi1yaWdodDogLTAuNWVtICFpbXBvcnRhbnQ7XFxufVxcblxcbi5jYXJkIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG5cXG4gICY6aG92ZXIge1xcbiAgICBib3gtc2hhZG93OlxcbiAgICAgIDAgMCAwIDFweCAjRDRENEQ1LFxcbiAgICAgIDAgMnB4IDRweCAwIHJnYmEoMzQsMzYsMzgsLjEyKSxcXG4gICAgICAwIDJweCAxMHB4IDAgcmdiYSgzNCwzNiwzOCwuMTUpICFpbXBvcnRhbnQ7XFxuICB9XFxufVxcblxcbi5jYXJkSWNvbiB7XFxuICBmbG9hdDogbGVmdCAhaW1wb3J0YW50O1xcbiAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XFxuICB3aWR0aDogMzVweCAhaW1wb3J0YW50O1xcbiAgZm9udC1zaXplOiAyZW0gIWltcG9ydGFudDtcXG4gIG1hcmdpbi1ib3R0b206IDEwcHggIWltcG9ydGFudDtcXG4gIG1hcmdpbi1yaWdodDogMTBweCAhaW1wb3J0YW50O1xcbiAgbWFyZ2luLXRvcDogNXB4ICFpbXBvcnRhbnQ7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwid3JhcHBlclwiOiBcInJlc3VsdHNfX3dyYXBwZXJfXzJkMGxHOG5vQ3RcIixcblx0XCJzb3J0aW5nXCI6IFwicmVzdWx0c19fc29ydGluZ19fMW85Rm9Ba3BfclwiLFxuXHRcInNlbGVjdGVkXCI6IFwicmVzdWx0c19fc2VsZWN0ZWRfXzFab04tOEFuQVFcIixcblx0XCJjYXJkc1wiOiBcInJlc3VsdHNfX2NhcmRzX19EVktHZWI0LThzXCIsXG5cdFwiY2FyZFwiOiBcInJlc3VsdHNfX2NhcmRfXzNBcmhrbXBPNG1cIixcblx0XCJjYXJkSWNvblwiOiBcInJlc3VsdHNfX2NhcmRJY29uX18xYURLd2UzTGwzXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vfi9wb3N0Y3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL3Jlc3VsdHMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRlbnQvYnVzY2FyL3Jlc3VsdHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFBhZ2UgZnJvbSAnLi4vLi4vY29tcG9uZW50cy90aHJlZS1jb2x1bW5zJztcbmltcG9ydCBQYW5lbCBmcm9tICcuL3BhbmVsJztcbmltcG9ydCBEZXRhaWxzIGZyb20gJy4vZGV0YWlscyc7XG5cbmNvbnN0IENhbXBhbmhhID0gcHJvcHMgPT4gKFxuICA8UGFnZVxuICAgIHBhbmVsPXs8UGFuZWwgey4uLnByb3BzfSAvPn1cbiAgICBjb250ZW50PXs8RGV0YWlscyB7Li4ucHJvcHN9IC8+fVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FtcGFuaGE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL2luZGV4LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNlZ21lbnQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vcGFuZWwuc2Nzcyc7XG5cbmNvbnN0IFBhbmVsID0gKCkgPT4gKFxuICA8RmxleEVsZW1lbnQgY29sdW1uIGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgIDxTZWdtZW50PlxuICAgICAgQ2FtcGFuaGFcbiAgICA8L1NlZ21lbnQ+XG4gIDwvRmxleEVsZW1lbnQ+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBQYW5lbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvcGFuZWwuanN4IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3BhbmVsLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9wYW5lbC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9wYW5lbC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvcGFuZWwuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5wYW5lbF9fd3JhcHBlcl9fMWtoXzFrUlJsRiB7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDAuOGVtO1xcbiAgd2lkdGg6IDE1ZW07IH1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvcGFuZWwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGdCQUFnQjtFQUNoQixvQkFBb0I7RUFDcEIsWUFBWSxFQUNiXCIsXCJmaWxlXCI6XCJwYW5lbC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi53cmFwcGVyIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC44ZW07XFxuICB3aWR0aDogMTVlbTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJ3cmFwcGVyXCI6IFwicGFuZWxfX3dyYXBwZXJfXzFraF8xa1JSbEZcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi9+L3Bvc3Rjc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlcj9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9jYW1wYW5oYS9wYW5lbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9jYW1wYW5oYS9wYW5lbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZmFrZXIgZnJvbSAnZmFrZXInO1xuaW1wb3J0IHRpbWVzIGZyb20gJ2xvZGFzaC90aW1lcyc7XG5pbXBvcnQgeyBDb250YWluZXIsIEhlYWRlciwgSWNvbiwgTGFiZWwsIFNlZ21lbnQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vZGV0YWlscy5zY3NzJztcblxuY29uc3QgRGV0YWlscyA9ICgpID0+IChcbiAgPFNlZ21lbnQgY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgPENvbnRhaW5lciBmbHVpZD5cbiAgICAgIDxGbGV4RWxlbWVudCBjb2x1bW4gc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAzMCB9fT5cbiAgICAgICAgPEhlYWRlciBhcz1cImg1XCI+XG4gICAgICAgICAgPEljb24gbmFtZT1cImNsaXBib2FyZFwiIC8+XG4gICAgICAgICAgPEhlYWRlci5Db250ZW50PlNFUlZJw4dPPC9IZWFkZXIuQ29udGVudD5cbiAgICAgICAgPC9IZWFkZXI+XG4gICAgICAgIDxwPntmYWtlci5sb3JlbS5zZW50ZW5jZSgyMCl9PC9wPlxuICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgIDxGbGV4RWxlbWVudCBjb2x1bW4gc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAzMCB9fT5cbiAgICAgICAgPEhlYWRlciBhcz1cImg1XCI+XG4gICAgICAgICAgPEljb24gbmFtZT1cImxpZ2h0YnVsYlwiIC8+XG4gICAgICAgICAgPEhlYWRlci5Db250ZW50PkhBQklMSURBREVTIFJFUVVFUklEQVM8L0hlYWRlci5Db250ZW50PlxuICAgICAgICA8L0hlYWRlcj5cbiAgICAgICAgPExhYmVsLkdyb3VwPlxuICAgICAgICAgIDxMYWJlbD5FbmNhbmFkb3I8L0xhYmVsPlxuICAgICAgICAgIDxMYWJlbD5FbGV0cmljaXN0YTwvTGFiZWw+XG4gICAgICAgIDwvTGFiZWwuR3JvdXA+XG4gICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbj5cbiAgICAgICAgPEhlYWRlciBhcz1cImg1XCI+XG4gICAgICAgICAgPEljb24gbmFtZT1cImNsaXBib2FyZFwiIC8+XG4gICAgICAgICAgPEhlYWRlci5Db250ZW50PkRFU0NSScOHw4NPPC9IZWFkZXIuQ29udGVudD5cbiAgICAgICAgPC9IZWFkZXI+XG4gICAgICAgIHt0aW1lcygzKS5tYXAoaWR4ID0+XG4gICAgICAgICAgPHAga2V5PXtpZHh9PntmYWtlci5sb3JlbS5wYXJhZ3JhcGgoNil9PC9wPixcbiAgICAgICAgKX1cbiAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgPC9Db250YWluZXI+XG4gIDwvU2VnbWVudD5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IERldGFpbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL2RldGFpbHMuanN4IiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTg5MCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC90aW1lcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2RldGFpbHMuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2RldGFpbHMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vZGV0YWlscy5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb250ZW50L2NhbXBhbmhhL2RldGFpbHMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29udGVudC9jYW1wYW5oYS9kZXRhaWxzLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZGV0YWlsc19fd3JhcHBlcl9fUGo5YkszdUt2SyB7XFxuICBmb250LXNpemU6IDFyZW07IH1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvZGV0YWlscy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZ0JBQWdCLEVBQ2pCXCIsXCJmaWxlXCI6XCJkZXRhaWxzLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLndyYXBwZXIge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcIndyYXBwZXJcIjogXCJkZXRhaWxzX193cmFwcGVyX19QajliSzN1S3ZLXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vfi9wb3N0Y3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRlbnQvY2FtcGFuaGEvZGV0YWlscy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9jYW1wYW5oYS9kZXRhaWxzLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQYWdlIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvdGhyZWUtY29sdW1ucyc7XG5pbXBvcnQgUGFuZWwgZnJvbSAnLi9wYW5lbCc7XG5pbXBvcnQgRGV0YWlscyBmcm9tICcuL2RldGFpbHMnO1xuXG5jb25zdCBPcmdhbml6YWNhbyA9IHByb3BzID0+IChcbiAgPFBhZ2VcbiAgICBwYW5lbD17PFBhbmVsIHsuLi5wcm9wc30gLz59XG4gICAgY29udGVudD17PERldGFpbHMgey4uLnByb3BzfSAvPn1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IE9yZ2FuaXphY2FvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9vcmdhbml6YWNhby9pbmRleC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZWdtZW50IH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3BhbmVsLnNjc3MnO1xuXG5jb25zdCBQYW5lbCA9ICgpID0+IChcbiAgPEZsZXhFbGVtZW50IGNvbHVtbiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICA8U2VnbWVudD5cbiAgICAgIE9yZ2FuaXphY2FvXG4gICAgPC9TZWdtZW50PlxuICA8L0ZsZXhFbGVtZW50PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgUGFuZWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL3BhbmVsLmpzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9wYW5lbC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vcGFuZWwuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vcGFuZWwuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmlld3MvY29udGVudC9vcmdhbml6YWNhby9wYW5lbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIucGFuZWxfX3dyYXBwZXJfXzJ0Zml6MGpWbFMge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAuOGVtO1xcbiAgd2lkdGg6IDE1ZW07IH1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vcGFuZWwuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGdCQUFnQjtFQUNoQixtQkFBbUI7RUFDbkIsWUFBWSxFQUNiXCIsXCJmaWxlXCI6XCJwYW5lbC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi53cmFwcGVyIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbi1yaWdodDogLjhlbTtcXG4gIHdpZHRoOiAxNWVtO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcIndyYXBwZXJcIjogXCJwYW5lbF9fd3JhcHBlcl9fMnRmaXowalZsU1wiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL34vcG9zdGNzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBmYWtlciBmcm9tICdmYWtlcic7XG5pbXBvcnQgdGltZXMgZnJvbSAnbG9kYXNoL3RpbWVzJztcbmltcG9ydCB7IENvbnRhaW5lciwgSGVhZGVyLCBJY29uLCBMYWJlbCwgU2VnbWVudCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCBGbGV4RWxlbWVudCBmcm9tICd+L3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9kZXRhaWxzLnNjc3MnO1xuXG5jb25zdCBEZXRhaWxzID0gKCkgPT4gKFxuICA8U2VnbWVudCBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICA8Q29udGFpbmVyIGZsdWlkPlxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDMwIH19PlxuICAgICAgICA8SGVhZGVyIGFzPVwiaDVcIj5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwiY2xpcGJvYXJkXCIgLz5cbiAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+U0VSVknDh088L0hlYWRlci5Db250ZW50PlxuICAgICAgICA8L0hlYWRlcj5cbiAgICAgICAgPHA+e2Zha2VyLmxvcmVtLnNlbnRlbmNlKDIwKX08L3A+XG4gICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDMwIH19PlxuICAgICAgICA8SGVhZGVyIGFzPVwiaDVcIj5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwibGlnaHRidWxiXCIgLz5cbiAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+SEFCSUxJREFERVMgUkVRVUVSSURBUzwvSGVhZGVyLkNvbnRlbnQ+XG4gICAgICAgIDwvSGVhZGVyPlxuICAgICAgICA8TGFiZWwuR3JvdXA+XG4gICAgICAgICAgPExhYmVsPkVuY2FuYWRvcjwvTGFiZWw+XG4gICAgICAgICAgPExhYmVsPkVsZXRyaWNpc3RhPC9MYWJlbD5cbiAgICAgICAgPC9MYWJlbC5Hcm91cD5cbiAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICA8RmxleEVsZW1lbnQgY29sdW1uPlxuICAgICAgICA8SGVhZGVyIGFzPVwiaDVcIj5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwiY2xpcGJvYXJkXCIgLz5cbiAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+REVTQ1JJw4fDg088L0hlYWRlci5Db250ZW50PlxuICAgICAgICA8L0hlYWRlcj5cbiAgICAgICAge3RpbWVzKDMpLm1hcChpZHggPT5cbiAgICAgICAgICA8cCBrZXk9e2lkeH0+e2Zha2VyLmxvcmVtLnBhcmFncmFwaCg2KX08L3A+LFxuICAgICAgICApfVxuICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICA8L0NvbnRhaW5lcj5cbiAgPC9TZWdtZW50PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgRGV0YWlscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vZGV0YWlscy5qc3giLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vZGV0YWlscy5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vZGV0YWlscy5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9kZXRhaWxzLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZpZXdzL2NvbnRlbnQvb3JnYW5pemFjYW8vZGV0YWlscy5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL2RldGFpbHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kZXRhaWxzX193cmFwcGVyX18xU0w1dXZxM3dHIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTsgfVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvdmlld3MvY29udGVudC9vcmdhbml6YWNhby9zcmMvdmlld3MvY29udGVudC9vcmdhbml6YWNhby9kZXRhaWxzLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxnQkFBZ0IsRUFDakJcIixcImZpbGVcIjpcImRldGFpbHMuc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIud3JhcHBlciB7XFxuICBmb250LXNpemU6IDFyZW07XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwid3JhcHBlclwiOiBcImRldGFpbHNfX3dyYXBwZXJfXzFTTDV1dnEzd0dcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi9+L3Bvc3Rjc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlcj9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9vcmdhbml6YWNhby9kZXRhaWxzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb250ZW50L29yZ2FuaXphY2FvL2RldGFpbHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFBhZ2UgZnJvbSAnLi4vLi4vY29tcG9uZW50cy90aHJlZS1jb2x1bW5zJztcbmltcG9ydCBQYW5lbCBmcm9tICcuL3BhbmVsJztcbmltcG9ydCBEZXRhaWxzIGZyb20gJy4vZGV0YWlscyc7XG5pbXBvcnQgUmVsYXRlZCBmcm9tICcuL3JlbGF0ZWQnO1xuXG5jb25zdCBTZXJ2aWNvID0gcHJvcHMgPT4gKFxuICA8UGFnZVxuICAgIHBhbmVsPXs8UGFuZWwgey4uLnByb3BzfSAvPn1cbiAgICBjb250ZW50PXs8RGV0YWlscyB7Li4ucHJvcHN9IC8+fVxuICAgIHJlbGF0ZWQ9ezxSZWxhdGVkIHsuLi5wcm9wc30gLz59XG4gIC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBTZXJ2aWNvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL2luZGV4LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNlZ21lbnQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vcGFuZWwuc2Nzcyc7XG5cbmNvbnN0IFBhbmVsID0gKCkgPT4gKFxuICA8RmxleEVsZW1lbnQgY29sdW1uIGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgIDxTZWdtZW50PlxuICAgICAgU2Vydmljb1xuICAgIDwvU2VnbWVudD5cbiAgPC9GbGV4RWxlbWVudD5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3BhbmVsLmpzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9wYW5lbC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vcGFuZWwuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vcGFuZWwuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9wYW5lbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnBhbmVsX193cmFwcGVyX18xVmY0M3hER08yIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbi1yaWdodDogLjhlbTtcXG4gIHdpZHRoOiAxNWVtOyB9XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9wYW5lbC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZ0JBQWdCO0VBQ2hCLG1CQUFtQjtFQUNuQixZQUFZLEVBQ2JcIixcImZpbGVcIjpcInBhbmVsLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLndyYXBwZXIge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAuOGVtO1xcbiAgd2lkdGg6IDE1ZW07XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwid3JhcHBlclwiOiBcInBhbmVsX193cmFwcGVyX18xVmY0M3hER08yXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vfi9wb3N0Y3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9wYW5lbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBmYWtlciBmcm9tICdmYWtlcic7XG5pbXBvcnQgdGltZXMgZnJvbSAnbG9kYXNoL3RpbWVzJztcbmltcG9ydCB7IENvbnRhaW5lciwgSGVhZGVyLCBJY29uLCBMYWJlbCwgU2VnbWVudCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCBGbGV4RWxlbWVudCBmcm9tICd+L3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9kZXRhaWxzLnNjc3MnO1xuXG5jb25zdCBEZXRhaWxzID0gKCkgPT4gKFxuICA8U2VnbWVudCBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfT5cbiAgICA8Q29udGFpbmVyIGZsdWlkPlxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDMwIH19PlxuICAgICAgICA8SGVhZGVyIGFzPVwiaDVcIj5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwiY2xpcGJvYXJkXCIgLz5cbiAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+U0VSVknDh088L0hlYWRlci5Db250ZW50PlxuICAgICAgICA8L0hlYWRlcj5cbiAgICAgICAgPHA+e2Zha2VyLmxvcmVtLnNlbnRlbmNlKDIwKX08L3A+XG4gICAgICA8L0ZsZXhFbGVtZW50PlxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDMwIH19PlxuICAgICAgICA8SGVhZGVyIGFzPVwiaDVcIj5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwibGlnaHRidWxiXCIgLz5cbiAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+SEFCSUxJREFERVMgUkVRVUVSSURBUzwvSGVhZGVyLkNvbnRlbnQ+XG4gICAgICAgIDwvSGVhZGVyPlxuICAgICAgICA8TGFiZWwuR3JvdXA+XG4gICAgICAgICAgPExhYmVsPkVuY2FuYWRvcjwvTGFiZWw+XG4gICAgICAgICAgPExhYmVsPkVsZXRyaWNpc3RhPC9MYWJlbD5cbiAgICAgICAgPC9MYWJlbC5Hcm91cD5cbiAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICA8RmxleEVsZW1lbnQgY29sdW1uPlxuICAgICAgICA8SGVhZGVyIGFzPVwiaDVcIj5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwiY2xpcGJvYXJkXCIgLz5cbiAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+REVTQ1JJw4fDg088L0hlYWRlci5Db250ZW50PlxuICAgICAgICA8L0hlYWRlcj5cbiAgICAgICAge3RpbWVzKDMpLm1hcChpZHggPT5cbiAgICAgICAgICA8cCBrZXk9e2lkeH0+e2Zha2VyLmxvcmVtLnBhcmFncmFwaCg2KX08L3A+LFxuICAgICAgICApfVxuICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICA8L0NvbnRhaW5lcj5cbiAgPC9TZWdtZW50PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgRGV0YWlscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9kZXRhaWxzLmpzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9kZXRhaWxzLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9kZXRhaWxzLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2RldGFpbHMuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL2RldGFpbHMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL2RldGFpbHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kZXRhaWxzX193cmFwcGVyX18zbnYyNnlDaUxMIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTsgfVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vZGV0YWlscy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZ0JBQWdCLEVBQ2pCXCIsXCJmaWxlXCI6XCJkZXRhaWxzLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLndyYXBwZXIge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcIndyYXBwZXJcIjogXCJkZXRhaWxzX193cmFwcGVyX18zbnYyNnlDaUxMXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vfi9wb3N0Y3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9kZXRhaWxzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vZGV0YWlscy5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTZWdtZW50IH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3JlbGF0ZWQuc2Nzcyc7XG5cbmNvbnN0IFJlbGF0ZWQgPSAoKSA9PiAoXG4gIDxGbGV4RWxlbWVudCBjb2x1bW4gY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgPFNlZ21lbnQ+XG4gICAgICBQZWxsZW50ZXNxdWUgaGFiaXRhbnQgbW9yYmkgdHJpc3RpcXVlIHNlbmVjdHVzLlxuICAgIDwvU2VnbWVudD5cbiAgICA8U2VnbWVudD5cbiAgICAgIFBlbGxlbnRlc3F1ZSBoYWJpdGFudCBtb3JiaSB0cmlzdGlxdWUgc2VuZWN0dXMuXG4gICAgPC9TZWdtZW50PlxuICA8L0ZsZXhFbGVtZW50PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgUmVsYXRlZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9yZWxhdGVkLmpzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9yZWxhdGVkLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9yZWxhdGVkLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3JlbGF0ZWQuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3JlbGF0ZWQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3JlbGF0ZWQuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5yZWxhdGVkX193cmFwcGVyX18yNFpiWEtFTElGIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbi1sZWZ0OiAuOGVtO1xcbiAgd2lkdGg6IDE4ZW07IH1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL3ZpZXdzL2NvbnRlbnQvc2Vydmljby9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3JlbGF0ZWQuc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGdCQUFnQjtFQUNoQixrQkFBa0I7RUFDbEIsWUFBWSxFQUNiXCIsXCJmaWxlXCI6XCJyZWxhdGVkLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLndyYXBwZXIge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgbWFyZ2luLWxlZnQ6IC44ZW07XFxuICB3aWR0aDogMThlbTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5leHBvcnRzLmxvY2FscyA9IHtcblx0XCJ3cmFwcGVyXCI6IFwicmVsYXRlZF9fd3JhcHBlcl9fMjRaYlhLRUxJRlwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL34vcG9zdGNzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb250ZW50L3NlcnZpY28vcmVsYXRlZC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC9zZXJ2aWNvL3JlbGF0ZWQuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFBhZ2UgZnJvbSAnLi4vLi4vY29tcG9uZW50cy90aHJlZS1jb2x1bW5zJztcbmltcG9ydCBQYW5lbCBmcm9tICcuL3BhbmVsJztcbmltcG9ydCBEZXRhaWxzIGZyb20gJy4vZGV0YWlscyc7XG5cbmNvbnN0IFVzdWFyaW8gPSBwcm9wcyA9PiAoXG4gIDxQYWdlXG4gICAgcGFuZWw9ezxQYW5lbCB7Li4ucHJvcHN9IC8+fVxuICAgIGNvbnRlbnQ9ezxEZXRhaWxzIHsuLi5wcm9wc30gLz59XG4gIC8+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBVc3VhcmlvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL2luZGV4LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNlZ21lbnQgfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgRmxleEVsZW1lbnQgZnJvbSAnfi92aWV3cy9jb21wb25lbnRzL2ZsZXgtZWxlbWVudCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vcGFuZWwuc2Nzcyc7XG5cbmNvbnN0IFBhbmVsID0gKCkgPT4gKFxuICA8RmxleEVsZW1lbnQgY29sdW1uIGNsYXNzTmFtZT17c3R5bGVzLndyYXBwZXJ9PlxuICAgIDxTZWdtZW50PlxuICAgICAgVXN1YXJpb1xuICAgIDwvU2VnbWVudD5cbiAgPC9GbGV4RWxlbWVudD5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL3BhbmVsLmpzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9wYW5lbC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vcGFuZWwuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vcGFuZWwuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vc3JjL3ZpZXdzL2NvbnRlbnQvdXN1YXJpby9wYW5lbC5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnBhbmVsX193cmFwcGVyX19FNjQ0NFV1RkczIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbi1yaWdodDogLjhlbTtcXG4gIHdpZHRoOiAxNWVtOyB9XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi8uL3NyYy92aWV3cy9jb250ZW50L3VzdWFyaW8vc3JjL3ZpZXdzL2NvbnRlbnQvdXN1YXJpby9wYW5lbC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZ0JBQWdCO0VBQ2hCLG1CQUFtQjtFQUNuQixZQUFZLEVBQ2JcIixcImZpbGVcIjpcInBhbmVsLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLndyYXBwZXIge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgbWFyZ2luLXJpZ2h0OiAuOGVtO1xcbiAgd2lkdGg6IDE1ZW07XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuZXhwb3J0cy5sb2NhbHMgPSB7XG5cdFwid3JhcHBlclwiOiBcInBhbmVsX193cmFwcGVyX19FNjQ0NFV1RkczXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vfi9wb3N0Y3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRlbnQvdXN1YXJpby9wYW5lbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL3BhbmVsLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHZhbHVlcyB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgQ29udGFpbmVyLCBIZWFkZXIsIEljb24sIExhYmVsLCBTZWdtZW50IH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0ICogYXMgYWN0aW9uQ3JlYXRvcnMgZnJvbSAnfi9zdG9yZS9hY3Rpb25zJztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL2RldGFpbHMuc2Nzcyc7XG5cbmNsYXNzIERldGFpbHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgaXNMb2dnZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHVzZXI6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgc2tpbGxzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLmlzTG9nZ2VkKSB7XG4gICAgICB0aGlzLnByb3BzLmFjdGlvbnMucmVhZCh7IGVudGl0eTogJ3VzZXJzJyB9KTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB1c2VyLCBza2lsbHMgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFNlZ21lbnQgY2xhc3NOYW1lPXtzdHlsZXMud3JhcHBlcn0+XG4gICAgICAgIDxDb250YWluZXIgZmx1aWQ+XG4gICAgICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDMwIH19PlxuICAgICAgICAgICAgPEhlYWRlciBhcz1cImg1XCI+XG4gICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJjbGlwYm9hcmRcIiAvPlxuICAgICAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+U09CUkUgTUlNPC9IZWFkZXIuQ29udGVudD5cbiAgICAgICAgICAgIDwvSGVhZGVyPlxuICAgICAgICAgICAgPHA+e3VzZXIuZGVzY3JpcHRpb259PC9wPlxuICAgICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDMwIH19PlxuICAgICAgICAgICAgPEhlYWRlciBhcz1cImg1XCI+XG4gICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJsaWdodGJ1bGJcIiAvPlxuICAgICAgICAgICAgICA8SGVhZGVyLkNvbnRlbnQ+SEFCSUxJREFERVM8L0hlYWRlci5Db250ZW50PlxuICAgICAgICAgICAgPC9IZWFkZXI+XG4gICAgICAgICAgICA8TGFiZWwuR3JvdXA+XG4gICAgICAgICAgICAgIHt2YWx1ZXModXNlci5za2lsbHMpLm1hcChza2lsbElEID0+XG4gICAgICAgICAgICAgICAgPExhYmVsIGtleT17c2tpbGxJRH0+XG4gICAgICAgICAgICAgICAgICB7c2tpbGxzW3NraWxsSURdLm5hbWV9XG4gICAgICAgICAgICAgICAgPC9MYWJlbD4sXG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L0xhYmVsLkdyb3VwPlxuICAgICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICAgIDwvQ29udGFpbmVyPlxuICAgICAgPC9TZWdtZW50PlxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gKHN0YXRlLCB7IHBhcmFtczogeyBpZCB9IH0pID0+ICh7XG4gIGlzTG9nZ2VkOiBzZWxlY3RvcnMuaXNBdXRoZW50aWNhdGVkKHN0YXRlKSxcbiAgdXNlcjogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAndXNlcnMnLCBpZCksXG4gIHNraWxsczogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAnc2tpbGxzJyksXG59KTtcblxuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gZGlzcGF0Y2ggPT4gKHtcbiAgYWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcykoRGV0YWlscyk7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRlbnQvdXN1YXJpby9kZXRhaWxzLmpzeCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9kZXRhaWxzLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCZtb2R1bGVzJmxvY2FsSWRlbnROYW1lPVtuYW1lXV9fW2xvY2FsXV9fW2hhc2g6YmFzZTY0OjEwXSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9kZXRhaWxzLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL2RldGFpbHMuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL2RldGFpbHMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL2RldGFpbHMuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kZXRhaWxzX193cmFwcGVyX195LVpySklIdDRlIHtcXG4gIGZvbnQtc2l6ZTogMXJlbTsgfVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvdmlld3MvY29udGVudC91c3VhcmlvL3NyYy92aWV3cy9jb250ZW50L3VzdWFyaW8vZGV0YWlscy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsZ0JBQWdCLEVBQ2pCXCIsXCJmaWxlXCI6XCJkZXRhaWxzLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLndyYXBwZXIge1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcIndyYXBwZXJcIjogXCJkZXRhaWxzX193cmFwcGVyX195LVpySklIdDRlXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vfi9wb3N0Y3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXI/c291cmNlTWFwIS4vc3JjL3ZpZXdzL2NvbnRlbnQvdXN1YXJpby9kZXRhaWxzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb250ZW50L3VzdWFyaW8vZGV0YWlscy5zY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgUmVkaXJlY3QgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgQnV0dG9uLCBEaXZpZGVyLCBGb3JtLCBJY29uLCBTZWdtZW50IH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5pbXBvcnQgKiBhcyBhY3Rpb25DcmVhdG9ycyBmcm9tICd+L3N0b3JlL2FjdGlvbnMnO1xuXG5jbGFzcyBMb2dpbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICBpc0xvZ2dlZDogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgaXNMb2dnaW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBpc1JlZ2lzdGVyaW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBsb2NhdGlvbjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICB0eXBlOiAndm9sdW50ZWVyJyxcbiAgfTtcblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZ0LCB7IG5hbWUsIHZhbHVlIH0pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgW25hbWVdOiB2YWx1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVMb2dpbiA9IChldnQsIHsgZW1haWwsIHBhc3N3b3JkIH0pID0+IHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IHsgdHlwZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGFjdGlvbnMsIGlzTG9nZ2luZywgaXNSZWdpc3RlcmluZyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChpc0xvZ2dpbmcgfHwgaXNSZWdpc3RlcmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbWFpbCAmJiBwYXNzd29yZCkge1xuICAgICAgYWN0aW9ucy5sb2dpbih7IGVtYWlsLCBwYXNzd29yZCwgdHlwZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9ucy5ub3RpZnlFcnJvcignUG9yIGZhdm9yLCBwcmVlbmNoYSB0b2RvcyBvcyBjYW1wb3MuJyk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVJlZ2lzdGVyID0gKGV2dCkgPT4ge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgeyB0eXBlIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgYWN0aW9ucywgaXNMb2dnaW5nLCBpc1JlZ2lzdGVyaW5nIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGlzUmVnaXN0ZXJpbmcgfHwgaXNMb2dnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZW1haWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPVwiZW1haWxcIl0nKS52YWx1ZTtcbiAgICBjb25zdCBwYXNzd29yZCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignW25hbWU9XCJwYXNzd29yZFwiXScpLnZhbHVlO1xuXG4gICAgaWYgKGVtYWlsICYmIHBhc3N3b3JkKSB7XG4gICAgICBhY3Rpb25zLnJlZ2lzdGVyKHsgZW1haWwsIHBhc3N3b3JkLCB0eXBlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3Rpb25zLm5vdGlmeUVycm9yKCdQb3IgZmF2b3IsIHByZWVuY2hhIHRvZG9zIG9zIGNhbXBvcy4nKTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IGlzTG9nZ2VkLCBpc0xvZ2dpbmcsIGlzUmVnaXN0ZXJpbmcsIGxvY2F0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgcmVkaXJlY3QgPSB7IHBhdGhuYW1lOiAnLycgfSB9ID0gbG9jYXRpb24uc3RhdGUgfHwge307XG5cbiAgICBpZiAoaXNMb2dnZWQpIHtcbiAgICAgIHJldHVybiA8UmVkaXJlY3QgdG89e3JlZGlyZWN0fSAvPjtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEZsZXhFbGVtZW50IGNvbHVtbiBmdWxsIGFsaWduPVwiY2VudGVyXCIganVzdGlmeT1cImNlbnRlclwiIGlubmVyUmVmPXtlbCA9PiAodGhpcy5lbCA9IGVsKX0+XG4gICAgICAgIDxGbGV4RWxlbWVudCBjb2x1bW4gYWxpZ249XCJjZW50ZXJcIj5cbiAgICAgICAgICA8SWNvbiBuYW1lPVwidHJhdmVsXCIgY29sb3I9XCJibHVlXCIgc3R5bGU9e3sgZm9udFNpemU6ICc2ZW0nIH19IC8+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6ICdyZ2JhKDAsMCwwLDAuNSknLCBmb250U2l6ZTogJzEuM2VtJyB9fT5BZ8OqbmNpYSBBbWlnYTwvc3Bhbj5cbiAgICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgICAgPFNlZ21lbnQgY29sdW1uIGFsaWduPVwiY2VudGVyXCIgYXM9e0ZsZXhFbGVtZW50fSBzdHlsZT17eyBtYXJnaW5Ub3A6IDMwLCB3aWR0aDogMzAwIH19PlxuICAgICAgICAgIDxGb3JtIHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogJzFlbScsIHdpZHRoOiAnMTAwJScgfX0gb25TdWJtaXQ9e3RoaXMuaGFuZGxlTG9naW59PlxuICAgICAgICAgICAgPEZvcm0uRmllbGQ+XG4gICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPkxvZ2luPC9sYWJlbD5cbiAgICAgICAgICAgIDwvRm9ybS5GaWVsZD5cbiAgICAgICAgICAgIDxGb3JtLklucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgbmFtZT1cImVtYWlsXCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9nZ2luZyB8fCBpc1JlZ2lzdGVyaW5nfVxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVtYWlsXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8Rm9ybS5JbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwicGFzc3dvcmRcIlxuICAgICAgICAgICAgICBuYW1lPVwicGFzc3dvcmRcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlbmhhXCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9nZ2luZyB8fCBpc1JlZ2lzdGVyaW5nfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgcHJpbWFyeVxuICAgICAgICAgICAgICBmbHVpZFxuICAgICAgICAgICAgICBzaXplPVwibGFyZ2VcIlxuICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luOiAwIH19XG4gICAgICAgICAgICAgIGxvYWRpbmc9e2lzTG9nZ2luZ31cbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9nZ2luZyB8fCBpc1JlZ2lzdGVyaW5nfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8RmxleEVsZW1lbnQgYWxpZ249XCJjZW50ZXJcIiBqdXN0aWZ5PVwic3BhY2UtYmV0d2VlblwiPlxuICAgICAgICAgICAgICAgIDxzcGFuPntpc0xvZ2dpbmcgPyAnQXV0ZW50aWNhbmRvLi4uJyA6ICdFbnRyYXInfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwic2lnbiBpblwiIC8+XG4gICAgICAgICAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8L0Zvcm0+XG4gICAgICAgICAgPERpdmlkZXIgaG9yaXpvbnRhbCBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19Pm91PC9EaXZpZGVyPlxuICAgICAgICAgIDxGb3JtIHN0eWxlPXt7IG1hcmdpblRvcDogJzFlbScsIHdpZHRoOiAnMTAwJScgfX0gPlxuICAgICAgICAgICAgPEZvcm0uRmllbGQ+XG4gICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPkNhZGFzdHJlLXNlIGNvbW86PC9sYWJlbD5cbiAgICAgICAgICAgIDwvRm9ybS5GaWVsZD5cbiAgICAgICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94XG4gICAgICAgICAgICAgICAgcmFkaW9cbiAgICAgICAgICAgICAgICBuYW1lPVwidHlwZVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9XCJWb2x1bnTDoXJpb1wiXG4gICAgICAgICAgICAgICAgdmFsdWU9XCJ2b2x1bnRlZXJcIlxuICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3R5cGUgPT09ICd2b2x1bnRlZXInfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc0xvZ2dpbmcgfHwgaXNSZWdpc3RlcmluZ31cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxGb3JtLkNoZWNrYm94XG4gICAgICAgICAgICAgICAgcmFkaW9cbiAgICAgICAgICAgICAgICBuYW1lPVwidHlwZVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9XCJPcmdhbml6YcOnw6NvXCJcbiAgICAgICAgICAgICAgICB2YWx1ZT1cIm9yZ2FuaXphdGlvblwiXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17dHlwZSA9PT0gJ29yZ2FuaXphdGlvbid9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzTG9nZ2luZyB8fCBpc1JlZ2lzdGVyaW5nfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvRm9ybS5Hcm91cD5cbiAgICAgICAgICA8L0Zvcm0+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgZmx1aWRcbiAgICAgICAgICAgIHNpemU9XCJsYXJnZVwiXG4gICAgICAgICAgICBzdHlsZT17eyBtYXJnaW46IDAsIG1hcmdpblRvcDogMTAgfX1cbiAgICAgICAgICAgIGxvYWRpbmc9e2lzUmVnaXN0ZXJpbmd9XG4gICAgICAgICAgICBkaXNhYmxlZD17aXNMb2dnaW5nIHx8IGlzUmVnaXN0ZXJpbmd9XG4gICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmhhbmRsZVJlZ2lzdGVyfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxGbGV4RWxlbWVudCBhbGlnbj1cImNlbnRlclwiIGp1c3RpZnk9XCJzcGFjZS1iZXR3ZWVuXCI+XG4gICAgICAgICAgICAgIDxzcGFuPntpc1JlZ2lzdGVyaW5nID8gJ1JlZ2lzdHJhbmRvLi4uJyA6ICdSZWdpc3RyYXInfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPEljb24gbmFtZT1cInNpZ251cFwiIHN0eWxlPXt7IG1hcmdpbjogMCB9fSAvPlxuICAgICAgICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9TZWdtZW50PlxuICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gIGlzTG9nZ2VkOiBzZWxlY3RvcnMuaXNBdXRoZW50aWNhdGVkKHN0YXRlKSxcbiAgaXNMb2dnaW5nOiBzZWxlY3RvcnMuaXNBdXRoZW50aWNhdGluZyhzdGF0ZSksXG4gIGlzUmVnaXN0ZXJpbmc6IHNlbGVjdG9ycy5pc1JlZ2lzdGVyaW5nKHN0YXRlKSxcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoe1xuICBhY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShMb2dpbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250YWluZXJzL2xvZ2luLmpzeCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTm90aWZpY2F0aW9uU3lzdGVtIGZyb20gJ3JlYWN0LW5vdGlmaWNhdGlvbi1zeXN0ZW0nO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuXG5jbGFzcyBOb3RpZmljYXRpb25Db250YWluZXIgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBub3RpZmljYXRpb246IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gIH07XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh7IG5vdGlmaWNhdGlvbiB9KSB7XG4gICAgaWYgKG5vdGlmaWNhdGlvbi5sZXZlbCkge1xuICAgICAgdGhpcy5lbC5hZGROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxOb3RpZmljYXRpb25TeXN0ZW0gcmVmPXtlbCA9PiAodGhpcy5lbCA9IGVsKX0gLz5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gIG5vdGlmaWNhdGlvbjogc2VsZWN0b3JzLmdldE5vdGlmaWNhdGlvbihzdGF0ZSksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKE5vdGlmaWNhdGlvbkNvbnRhaW5lcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250YWluZXJzL25vdGlmaWNhdGlvbi5qc3giLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKSgxMzMxKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3Qtbm90aWZpY2F0aW9uLXN5c3RlbS9kaXN0L05vdGlmaWNhdGlvblN5c3RlbS5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgX19fQUdFTkNJQV9BTUlHQV9fX1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCBGbGV4RWxlbWVudCBmcm9tICd+L3ZpZXdzL2NvbXBvbmVudHMvZmxleC1lbGVtZW50JztcbmltcG9ydCBTZWFyY2ggZnJvbSAnLi9zZWFyY2gnO1xuaW1wb3J0IFVzZXIgZnJvbSAnLi91c2VyJztcblxuY29uc3Qgc3R5bGVzID0ge1xuICB0b3BCYXI6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjk4N0NEJyxcbiAgICBjb2xvcjogJ3doaXRlJyxcbiAgICBmb250U2l6ZTogJzFyZW0nLFxuICAgIHBhZGRpbmc6ICcwLjRlbSAwLjRlbSAwLjVlbSAxZW0nLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gIH0sXG4gIGxvZ286IHtcbiAgICBmb250U2l6ZTogJzEuM2VtJyxcbiAgICBtYXJnaW5SaWdodDogJzAuNWVtJyxcbiAgICBtYXJnaW5Ub3A6ICcwLjFlbScsXG4gIH0sXG59O1xuXG5jb25zdCBUb3BCYXIgPSAoKSA9PiAoXG4gIDxGbGV4RWxlbWVudCBzdHlsZT17c3R5bGVzLnRvcEJhcn0+XG4gICAgPEZsZXhFbGVtZW50IGNvbHVtbiBhbGlnbj1cImNlbnRlclwiIHN0eWxlPXt7IGZvbnRTaXplOiAnMS4yZW0nIH19PlxuICAgICAgPEljb24gbmFtZT1cInRyYXZlbFwiIHN0eWxlPXtzdHlsZXMubG9nb30gLz5cbiAgICAgIDxMaW5rIHRvPVwiL1wiIHN0eWxlPXt7IGNvbG9yOiAnd2hpdGUnIH19PkFnw6puY2lhIEFtaWdhPC9MaW5rPlxuICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgPEZsZXhFbGVtZW50IGZ1bGwgY29sdW1uIGFsaWduPVwiY2VudGVyXCI+XG4gICAgICA8U2VhcmNoIC8+XG4gICAgPC9GbGV4RWxlbWVudD5cbiAgICA8RmxleEVsZW1lbnQgY29sdW1uIGFsaWduPVwiY2VudGVyXCI+XG4gICAgICA8VXNlciAvPlxuICAgIDwvRmxleEVsZW1lbnQ+XG4gIDwvRmxleEVsZW1lbnQ+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBUb3BCYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9pbmRleC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbGF0aW5pemUgZnJvbSAnbGF0aW5pemUnO1xuaW1wb3J0IHsgZmluZCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgQnV0dG9uLCBGb3JtLCBJY29uLCBJbnB1dCwgRHJvcGRvd24gfSBmcm9tICdzZW1hbnRpYy11aS1yZWFjdCc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICd+L2NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBhY3Rpb25DcmVhdG9ycyBmcm9tICd+L3N0b3JlL2FjdGlvbnMnO1xuaW1wb3J0IHNlbGVjdG9ycyBmcm9tICd+L3N0b3JlL3NlbGVjdG9ycyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc2VhcmNoLnNjc3MnO1xuXG5jbGFzcyBUb3BCYXJTZWFyY2ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGVudGl0eTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpc0ZpbHRlcmluZzogUmVhY3QuUHJvcFR5cGVzLmJvb2wsXG4gICAgcXVlcnk6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25GaWx0ZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9uVXBkYXRlRmlsdGVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgfTtcblxuICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgIHJvdXRlcjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIGhhbmRsZUZpbHRlckNsaWNrID0gKGV2dCwgeyB2YWx1ZSB9KSA9PiB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLnByb3BzLm9uVXBkYXRlRmlsdGVyKHsgZmlsdGVyOiB2YWx1ZSB9KTtcbiAgfTtcblxuICBoYW5kbGVTZWFyY2ggPSAoZXZ0LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBjb25zdCB7IGVudGl0eSwgb25GaWx0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyB0ZXh0IH0gPSBmaW5kKEZpbHRlci5PUFRJT05TLCB7IHZhbHVlOiBlbnRpdHkgfSk7XG4gICAgY29uc3Qgc2x1ZyA9IGxhdGluaXplKHRleHQpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIG9uRmlsdGVyKHsgcXVlcnkgfSk7XG5cbiAgICB0aGlzLmNvbnRleHQucm91dGVyLnRyYW5zaXRpb25Ubyh7XG4gICAgICBwYXRobmFtZTogJy9idXNjYXInLFxuICAgICAgcXVlcnk6IHsgZmlsdHJvOiBzbHVnIH0sXG4gICAgfSk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZW50aXR5LCBxdWVyeSwgaXNGaWx0ZXJpbmcgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBmaW5kKEZpbHRlci5PUFRJT05TLCB7IHZhbHVlOiBlbnRpdHkgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEZvcm0gY2xhc3NOYW1lPXtzdHlsZXMuc2VhcmNoRm9ybX0gb25TdWJtaXQ9e3RoaXMuaGFuZGxlU2VhcmNofT5cbiAgICAgICAgPElucHV0IGFjdGlvbiBmb2N1cz17ZmFsc2V9IGNsYXNzTmFtZT17c3R5bGVzLnNlYXJjaElucHV0fT5cbiAgICAgICAgICA8SWNvbiBuYW1lPXtzZWxlY3RlZC5pY29ufSAvPlxuICAgICAgICAgIDxpbnB1dCBuYW1lPVwicXVlcnlcIiBkZWZhdWx0VmFsdWU9e3F1ZXJ5fSBwbGFjZWhvbGRlcj17YEJ1c2NhciAke3NlbGVjdGVkLnRleHR9YH0gLz5cbiAgICAgICAgICA8RHJvcGRvd24gcG9pbnRpbmc9XCJ0b3AgbGVmdFwiIGljb249XCJzbGlkZXJzXCIgY2xhc3NOYW1lPXtzdHlsZXMuZmlsdGVyc30+XG4gICAgICAgICAgICA8RHJvcGRvd24uTWVudT5cbiAgICAgICAgICAgICAge0ZpbHRlci5PUFRJT05TLm1hcChvcHRpb24gPT5cbiAgICAgICAgICAgICAgICA8RHJvcGRvd24uSXRlbVxuICAgICAgICAgICAgICAgICAga2V5PXtvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICBzZWxlY3RlZD17ZW50aXR5ID09PSBvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICBpY29uPXtvcHRpb24uaWNvbn1cbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICB0ZXh0PXtvcHRpb24udGV4dH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlRmlsdGVyQ2xpY2t9XG4gICAgICAgICAgICAgICAgLz4sXG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L0Ryb3Bkb3duLk1lbnU+XG4gICAgICAgICAgPC9Ecm9wZG93bj5cbiAgICAgICAgICA8QnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzc05hbWU9e3N0eWxlcy5maWx0ZXJCdXR0b259IGRpc2FibGVkPXtpc0ZpbHRlcmluZ30+XG4gICAgICAgICAgICBCdXNjYXJcbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9JbnB1dD5cbiAgICAgIDwvRm9ybT5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gIGlzRmlsdGVyaW5nOiBzZWxlY3RvcnMuaXNGaWx0ZXJpbmcoc3RhdGUpLFxuICBlbnRpdHk6IHNlbGVjdG9ycy5nZXRFbnRpdHlGaWx0ZXIoc3RhdGUpLFxuICBxdWVyeTogc2VsZWN0b3JzLmdldFF1ZXJ5RmlsdGVyKHN0YXRlKSxcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoe1xuICBvbkZpbHRlcjogKCkgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvcnMuZmlsdGVyKCkpLFxuICBvblVwZGF0ZUZpbHRlcjogdXBkYXRlcyA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9ycy51cGRhdGVGaWx0ZXIodXBkYXRlcykpLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMpKFRvcEJhclNlYXJjaCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9EOi9yZXBvLmdpdC9kamFsbWFqci9hZ2VuY2lhLWFtaWdhL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9zZWFyY2guanN4IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3NlYXJjaC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vc2VhcmNoLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3NlYXJjaC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9zZWFyY2guc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29udGFpbmVycy90b3BiYXIvc2VhcmNoLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2VhcmNoX19zZWFyY2hGb3JtX19KcEhCeWZ0WWEzIHtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gICAgICAtbXMtZmxleDogMTtcXG4gICAgICAgICAgZmxleDogMTtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIG1hcmdpbjogMCAuNWVtOyB9XFxuXFxuLnNlYXJjaF9fc2VhcmNoSW5wdXRfXzF2Z09JZDNtOFQge1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IHN0cmV0Y2g7XFxuICAgICAgLW1zLWZsZXgtYWxpZ246IHN0cmV0Y2g7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4zKTtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgei1pbmRleDogMTsgfVxcbiAgLnNlYXJjaF9fc2VhcmNoSW5wdXRfXzF2Z09JZDNtOFQgPiBpIHtcXG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gICAgZm9udC1zaXplOiAwLjllbTtcXG4gICAgbWFyZ2luOiBhdXRvIC0yZW0gYXV0byBhdXRvO1xcbiAgICB6LWluZGV4OiAxOyB9XFxuICAuc2VhcmNoX19zZWFyY2hJbnB1dF9fMXZnT0lkM204VCA+IGlucHV0IHtcXG4gICAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlICFpbXBvcnRhbnQ7XFxuICAgIHBhZGRpbmctbGVmdDogMi40ZW0gIWltcG9ydGFudDtcXG4gICAgd2lkdGg6IDIwZW0gIWltcG9ydGFudDsgfVxcblxcbi5zZWFyY2hfX2ZpbHRlcnNfXzNZNWRYSGl6Qkgge1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICBwYWRkaW5nOiAuNWVtIC44ZW07XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDsgfVxcbiAgLnNlYXJjaF9fZmlsdGVyc19fM1k1ZFhIaXpCSCA+IGkge1xcbiAgICBtYXJnaW46IDAgIWltcG9ydGFudDsgfVxcblxcbi5zZWFyY2hfX2ZpbHRlckJ1dHRvbl9fMVJaNThLUkZoVyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWQ2MDkyICFpbXBvcnRhbnQ7XFxuICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDsgfVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvdmlld3MvY29udGFpbmVycy90b3BiYXIvc3JjL3ZpZXdzL2NvbnRhaW5lcnMvdG9wYmFyL3NlYXJjaC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UscUJBQWM7RUFBZCxxQkFBYztFQUFkLGNBQWM7RUFDZCxvQkFBUTtNQUFSLFlBQVE7VUFBUixRQUFRO0VBQ1IsZ0JBQWdCO0VBQ2hCLGVBQWUsRUFDaEI7O0FBRUQ7RUFDRSwyQkFBcUI7TUFBckIsd0JBQXFCO1VBQXJCLHFCQUFxQjtFQUNyQiwwQkFBVztFQUNYLHFCQUFjO0VBQWQscUJBQWM7RUFBZCxjQUFjO0VBQ2QsYUFBYTtFQUNiLFdBQVcsRUFlWjtFQXBCRDtJQVFJLDBCQUFXO0lBQ1gsaUJBQWlCO0lBQ2pCLDRCQUE0QjtJQUM1QixXQUFXLEVBQ1o7RUFaSDtJQWVJLHdCQUF3QjtJQUN4Qiw2QkFBNkI7SUFDN0IsK0JBQStCO0lBQy9CLHVCQUF1QixFQUN4Qjs7QUFHSDtFQUNFLDBCQUFvQjtNQUFwQix1QkFBb0I7VUFBcEIsb0JBQW9CO0VBQ3BCLHdCQUF3QjtFQUN4QixtQkFBbUI7RUFDbkIscUJBQWM7RUFBZCxxQkFBYztFQUFkLGNBQWMsRUFLZjtFQVREO0lBT0kscUJBQXFCLEVBQ3RCOztBQUdIO0VBQ0UscUNBQWlEO0VBQ2pELHdCQUF3QixFQUN6QlwiLFwiZmlsZVwiOlwic2VhcmNoLnNjc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnNlYXJjaEZvcm0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDE7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBtYXJnaW46IDAgLjVlbTtcXG59XFxuXFxuLnNlYXJjaElucHV0IHtcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgY29sb3I6IHJnYmEoMCwwLDAsMC4zKTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtYXJnaW46IGF1dG87XFxuICB6LWluZGV4OiAxO1xcblxcbiAgJiA+IGkge1xcbiAgICBjb2xvcjogcmdiYSgwLDAsMCwgMC40KTtcXG4gICAgZm9udC1zaXplOiAwLjllbTtcXG4gICAgbWFyZ2luOiBhdXRvIC0yZW0gYXV0byBhdXRvO1xcbiAgICB6LWluZGV4OiAxO1xcbiAgfVxcblxcbiAgJiA+IGlucHV0IHtcXG4gICAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlICFpbXBvcnRhbnQ7XFxuICAgIHBhZGRpbmctbGVmdDogMi40ZW0gIWltcG9ydGFudDtcXG4gICAgd2lkdGg6IDIwZW0gIWltcG9ydGFudDtcXG4gIH1cXG59XFxuXFxuLmZpbHRlcnMge1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgcGFkZGluZzogLjVlbSAuOGVtO1xcbiAgZGlzcGxheTogZmxleDtcXG5cXG4gICYgPiBpIHtcXG4gICAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XFxuICB9XFxufVxcblxcbi5maWx0ZXJCdXR0b24ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogZGFya2VuKCMyOTg3Q0QsIDE0JSkgIWltcG9ydGFudDtcXG4gIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcInNlYXJjaEZvcm1cIjogXCJzZWFyY2hfX3NlYXJjaEZvcm1fX0pwSEJ5ZnRZYTNcIixcblx0XCJzZWFyY2hJbnB1dFwiOiBcInNlYXJjaF9fc2VhcmNoSW5wdXRfXzF2Z09JZDNtOFRcIixcblx0XCJmaWx0ZXJzXCI6IFwic2VhcmNoX19maWx0ZXJzX18zWTVkWEhpekJIXCIsXG5cdFwiZmlsdGVyQnV0dG9uXCI6IFwic2VhcmNoX19maWx0ZXJCdXR0b25fXzFSWjU4S1JGaFdcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi9+L3Bvc3Rjc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlcj9zb3VyY2VNYXAhLi9zcmMvdmlld3MvY29udGFpbmVycy90b3BiYXIvc2VhcmNoLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci9zZWFyY2guc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNFbXB0eSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgRHJvcGRvd24sIEljb24sIEltYWdlIH0gZnJvbSAnc2VtYW50aWMtdWktcmVhY3QnO1xuaW1wb3J0ICogYXMgYWN0aW9uQ3JlYXRvcnMgZnJvbSAnfi9zdG9yZS9hY3Rpb25zJztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuaW1wb3J0IGRlZmF1bHRVc2VySW1hZ2UgZnJvbSAnLi91c2VyLnBuZyc7XG5pbXBvcnQgU2V0dGluZ3NNb2RhbCBmcm9tICcuL3NldHRpbmdzJztcblxuY2xhc3MgVG9wQmFyVXNlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWN0aW9uczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICB1c2VyOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGlzTW9kYWxWaXNpYmxlOiBmYWxzZSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVXNlckZpZWxkcyh0aGlzLnByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLnZhbGlkYXRlVXNlckZpZWxkcyhwcm9wcyk7XG4gIH1cblxuICBoYW5kbGVTZXR0aW5nc1RvZ2dsZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgaXNNb2RhbFZpc2libGU6ICF0aGlzLnN0YXRlLmlzTW9kYWxWaXNpYmxlIH0pO1xuICB9O1xuXG4gIGhhbmRsZUxvZ291dCA9IChldnQpID0+IHtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIHRoaXMucHJvcHMuYWN0aW9ucy5sb2dvdXQoKTtcbiAgfTtcblxuICB2YWxpZGF0ZVVzZXJGaWVsZHMocHJvcHMpIHtcbiAgICB0aGlzLnJlcXVpcmVkRmllbGRzID0gcHJvcHMudXNlci50eXBlID09PSAndm9sdW50ZWVyJyA/XG4gICAgICBbJ25hbWUnLCAnc3RhdGUnLCAnY2l0eScsICdza2lsbHMnXSA6XG4gICAgICBbJ25hbWUnLCAnc3RhdGUnLCAnY2l0eSddO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNNb2RhbFZpc2libGU6IHRoaXMucmVxdWlyZWRGaWVsZHNcbiAgICAgICAgICAubWFwKGF0dHIgPT4gcHJvcHMudXNlclthdHRyXSlcbiAgICAgICAgICAuc29tZSh2YWwgPT4gaXNFbXB0eSh2YWwpKSxcbiAgICAgIH0pO1xuICAgIH0sIDEpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHNldHRpbmdzUHJvcHMgPSB7XG4gICAgICB1c2VyOiB0aGlzLnByb3BzLnVzZXIsXG4gICAgICByZXF1aXJlZEZpZWxkczogdGhpcy5yZXF1aXJlZEZpZWxkcyxcbiAgICAgIGlzT3BlbjogdGhpcy5zdGF0ZS5pc01vZGFsVmlzaWJsZSxcbiAgICAgIG9uQ2xvc2U6IHRoaXMuaGFuZGxlU2V0dGluZ3NUb2dnbGUsXG4gICAgfTtcblxuICAgIGNvbnN0IHRyaWdnZXIgPSAoXG4gICAgICA8RmxleEVsZW1lbnQgYWxpZ249XCJjZW50ZXJcIiBqdXN0aWZ5PVwiY2VudGVyXCI+XG4gICAgICAgIDxJbWFnZSBhdmF0YXIgc3JjPXtkZWZhdWx0VXNlckltYWdlfSAvPlxuICAgICAgICA8SWNvbiBuYW1lPVwiY2FyZXQgZG93blwiIHN0eWxlPXt7IG1hcmdpbkxlZnQ6ICcwLjNlbScgfX0gLz5cbiAgICAgIDwvRmxleEVsZW1lbnQ+XG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8RmxleEVsZW1lbnQgYWxpZ249XCJjZW50ZXJcIiBqdXN0aWZ5PVwiZmxleC1lbmRcIiBzdHlsZT17eyBtYXJnaW5MZWZ0OiAnYXV0bycgfX0+XG4gICAgICAgIHsvKlxuICAgICAgICA8SWNvbiBuYW1lPVwiYWxhcm0gb3V0bGluZVwiIHN0eWxlPXt7IG1hcmdpblJpZ2h0OiAnMWVtJyB9fSAvPlxuICAgICAgICA8SWNvbiBuYW1lPVwibWFpbCBvdXRsaW5lXCIgc3R5bGU9e3sgbWFyZ2luUmlnaHQ6ICcxZW0nIH19IC8+XG4gICAgICAgICovfVxuICAgICAgICA8RHJvcGRvd24gaWNvbj17bnVsbH0gdHJpZ2dlcj17dHJpZ2dlcn0gcG9pbnRpbmc9XCJ0b3AgcmlnaHRcIj5cbiAgICAgICAgICA8RHJvcGRvd24uTWVudT5cbiAgICAgICAgICAgIDxEcm9wZG93bi5JdGVtIHRleHQ9XCJDb25maWd1cmHDp8O1ZXNcIiBpY29uPVwic2V0dGluZ3NcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZVNldHRpbmdzVG9nZ2xlfSAvPlxuICAgICAgICAgICAgPERyb3Bkb3duLkl0ZW0gdGV4dD1cIlNhaXJcIiBpY29uPVwic2lnbiBvdXRcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUxvZ291dH0gLz5cbiAgICAgICAgICA8L0Ryb3Bkb3duLk1lbnU+XG4gICAgICAgIDwvRHJvcGRvd24+XG4gICAgICAgIDxTZXR0aW5nc01vZGFsIHsuLi5zZXR0aW5nc1Byb3BzfSAvPlxuICAgICAgPC9GbGV4RWxlbWVudD5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gIHVzZXI6IHNlbGVjdG9ycy5nZXRVc2VyKHN0YXRlKSxcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBkaXNwYXRjaCA9PiAoe1xuICBhY3Rpb25zOiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzKShUb3BCYXJVc2VyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0Q6L3JlcG8uZ2l0L2RqYWxtYWpyL2FnZW5jaWEtYW1pZ2Evc3JjL3ZpZXdzL2NvbnRhaW5lcnMvdG9wYmFyL3VzZXIuanN4IiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwidXNlci5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb250YWluZXJzL3RvcGJhci91c2VyLnBuZ1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29udGFpbmVycy90b3BiYXIvdXNlci5wbmdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgQnV0dG9uLCBGb3JtLCBNb2RhbCB9IGZyb20gJ3NlbWFudGljLXVpLXJlYWN0JztcbmltcG9ydCBnZW5VSUQgZnJvbSAnfi9oZWxwZXJzL2dlbi11aWQnO1xuaW1wb3J0ICogYXMgYWN0aW9uQ3JlYXRvcnMgZnJvbSAnfi9zdG9yZS9hY3Rpb25zJztcbmltcG9ydCBzZWxlY3RvcnMgZnJvbSAnfi9zdG9yZS9zZWxlY3RvcnMnO1xuaW1wb3J0IEZsZXhFbGVtZW50IGZyb20gJ34vdmlld3MvY29tcG9uZW50cy9mbGV4LWVsZW1lbnQnO1xuXG5jbGFzcyBTZXR0aW5ncyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjdGlvbnM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgaXNPcGVuOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICBpc1VwZGF0aW5nOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICByZXF1aXJlZEZpZWxkczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LFxuICAgIHNraWxsczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCxcbiAgICB1c2VyOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2xvc2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnNraWxscyAhPT0gdGhpcy5zdGF0ZS5za2lsbHMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0NyZWF0aW5nU2tpbGw6IGZhbHNlLFxuICAgICAgICBza2lsbHM6IF8ubWVyZ2Uoe30sIG5leHRQcm9wcy5za2lsbHMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluaXRpYWxTdGF0ZSgpIHtcbiAgICBjb25zdCB7IHNraWxscywgdXNlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiB7XG4gICAgICBpc0NyZWF0aW5nU2tpbGw6IGZhbHNlLFxuICAgICAgc2tpbGxzOiBfLm1lcmdlKHt9LCBza2lsbHMpLFxuICAgICAgZm9ybURhdGE6IHtcbiAgICAgICAgbmFtZTogdXNlci5uYW1lIHx8ICcnLFxuICAgICAgICBzdGF0ZTogdXNlci5zdGF0ZSB8fCAnJyxcbiAgICAgICAgY2l0eTogdXNlci5jaXR5IHx8ICcnLFxuICAgICAgICBza2lsbHM6IHVzZXIuc2tpbGxzIHx8IFtdLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGUsIHsgbmFtZSwgdmFsdWUgfSkgPT4ge1xuICAgIGNvbnN0IHsgc2tpbGxzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGZvcm1EYXRhID0gXy5tZXJnZSh7fSwgdGhpcy5zdGF0ZS5mb3JtRGF0YSk7XG5cbiAgICBpZiAobmFtZSA9PT0gJ3NraWxscycpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0ge307XG4gICAgICBjb25zdCBuZXdTa2lsbCA9IF8ucmVtb3ZlKHZhbHVlLCBhdHRyID0+ICFza2lsbHNbYXR0cl0pWzBdO1xuXG4gICAgICBpZiAobmV3U2tpbGwpIHtcbiAgICAgICAgY29uc3QgdWlkID0gZ2VuVUlEKCdza2lsbHMnKTtcblxuICAgICAgICBza2lsbHNbdWlkXSA9IHsgdWlkLCBuYW1lOiBuZXdTa2lsbCB9O1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBza2lsbHMgfSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvcHMuYWN0aW9ucy5zYXZlKCdza2lsbHMnLCBza2lsbHNbdWlkXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5ld1ZhbHVlW3VpZF0gPSB1aWQ7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlLmZvckVhY2godWlkID0+IChuZXdWYWx1ZVt1aWRdID0gdWlkKSk7XG4gICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cblxuICAgIGZvcm1EYXRhW25hbWVdID0gdmFsdWU7XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgZm9ybURhdGEgfSk7XG4gIH07XG5cbiAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB1c2VyLCBvbkNsb3NlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKHRoaXMuaXNWYWxpZCh1c2VyKSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmluaXRpYWxTdGF0ZSwgb25DbG9zZSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVN1Ym1pdCA9IChldnQpID0+IHtcbiAgICBjb25zdCB7IGZvcm1EYXRhIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgYWN0aW9ucywgdXNlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKHRoaXMuaXNWYWxpZChmb3JtRGF0YSkpIHtcbiAgICAgIGFjdGlvbnMudXBkYXRlUHJvZmlsZShfLm1lcmdlKHt9LCB1c2VyLCBmb3JtRGF0YSkpO1xuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWQoZGF0YSkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSAhdGhpcy5wcm9wcy5yZXF1aXJlZEZpZWxkc1xuICAgICAgLm1hcChhdHRyID0+IGRhdGFbYXR0cl0pXG4gICAgICAuc29tZSh2YWwgPT4gXy5pc0VtcHR5KHZhbCkpO1xuXG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB0aGlzLnByb3BzLmFjdGlvbnMubm90aWZ5RXJyb3IoZGF0YS51aWQgP1xuICAgICAgICAnw4kgbmVjZXNzw6FyaW8gY29tcGxldGFyIG9zIHNldXMgZGFkb3MgYW50ZXMgZGUgY29udGludWFyJyA6XG4gICAgICAgICfDiSBuZWNlc3PDoXJpbyBwcmVlbmNoZXIgb3MgY2FtcG9zIG9icmlnYXTDs3Jpb3MnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5wYXNzd29yZCAmJiBkYXRhLnBhc3N3b3JkICE9PSBkYXRhLnBhc3N3b3JkMikge1xuICAgICAgdGhpcy5wcm9wcy5hY3Rpb25zLm5vdGlmeUVycm9yKCdBcyBzZW5oYXMgbsOjbyBjb25mZXJlbS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNWYWxpZDtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlzT3BlbiwgaXNVcGRhdGluZywgdXNlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZvcm1EYXRhLCBza2lsbHMsIGlzQ3JlYXRpbmdTa2lsbCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBvcHRpb25zID0gXy52YWx1ZXMoc2tpbGxzKS5tYXAoKHsgdWlkLCBuYW1lIH0pID0+ICh7IHRleHQ6IG5hbWUsIHZhbHVlOiB1aWQgfSkpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNb2RhbCBvcGVuPXtpc09wZW59IGNsb3NlT25Sb290Tm9kZUNsaWNrPXtmYWxzZX0gb25DbG9zZT17dGhpcy5oYW5kbGVDbG9zZX0+XG4gICAgICAgIDxNb2RhbC5IZWFkZXI+XG4gICAgICAgICAgQ29uZmlndXJhw6fDtWVzXG4gICAgICAgIDwvTW9kYWwuSGVhZGVyPlxuICAgICAgICA8TW9kYWwuQ29udGVudFxuICAgICAgICAgIGFzPXtGb3JtfVxuICAgICAgICAgIHJlZj17ZWwgPT4gKHRoaXMuZm9ybSA9IGVsKX1cbiAgICAgICAgICBvblN1Ym1pdD17dGhpcy5oYW5kbGVTdWJtaXR9XG4gICAgICAgID5cbiAgICAgICAgICA8Rm9ybS5JbnB1dFxuICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgIG5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgIGxhYmVsPVwiTm9tZSBDb21wbGV0b1wiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4LjogSm9zw6kgQ8OtY2Vyb1wiXG4gICAgICAgICAgICBkaXNhYmxlZD17aXNVcGRhdGluZ31cbiAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YS5uYW1lfVxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIC8+XG4gICAgICAgICAge3VzZXIudHlwZSA9PT0gJ3ZvbHVudGVlcicgJiYgKFxuICAgICAgICAgICAgPEZvcm0uU2VsZWN0XG4gICAgICAgICAgICAgIGZsdWlkXG4gICAgICAgICAgICAgIHNlYXJjaFxuICAgICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgICBtdWx0aXBsZVxuICAgICAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgYWxsb3dBZGRpdGlvbnNcbiAgICAgICAgICAgICAgbmFtZT1cInNraWxsc1wiXG4gICAgICAgICAgICAgIGxhYmVsPVwiSGFiaWxpZGFkZXNcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkRpZ2l0ZSBzdWFzIGhhYmlsaWRhZGVzXCJcbiAgICAgICAgICAgICAgbm9SZXN1bHRzTWVzc2FnZT1cIk5lbmh1bSByZXN1bHRhZG8gZW5jb250cmFkb1wiXG4gICAgICAgICAgICAgIGRpc2FibGVkPXtpc1VwZGF0aW5nfVxuICAgICAgICAgICAgICBsb2FkaW5nPXtpc0NyZWF0aW5nU2tpbGx9XG4gICAgICAgICAgICAgIHZhbHVlPXtfLmtleXMoZm9ybURhdGEuc2tpbGxzKX1cbiAgICAgICAgICAgICAgb3B0aW9ucz17b3B0aW9uc31cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAgIDxGb3JtLkdyb3VwIHdpZHRocz1cImVxdWFsXCI+XG4gICAgICAgICAgICA8Rm9ybS5JbnB1dFxuICAgICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgICBuYW1lPVwic3RhdGVcIlxuICAgICAgICAgICAgICBsYWJlbD1cIkVzdGFkb1wiXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRXguOiBBbGFnb2FzXCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzVXBkYXRpbmd9XG4gICAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YS5zdGF0ZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxGb3JtLklucHV0XG4gICAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICAgIG5hbWU9XCJjaXR5XCJcbiAgICAgICAgICAgICAgbGFiZWw9XCJDaWRhZGVcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkV4LjogTWFjZWnDs1wiXG4gICAgICAgICAgICAgIGRpc2FibGVkPXtpc1VwZGF0aW5nfVxuICAgICAgICAgICAgICB2YWx1ZT17Zm9ybURhdGEuY2l0eX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L0Zvcm0uR3JvdXA+XG4gICAgICAgICAgey8qXG4gICAgICAgICAgICA8Rm9ybS5Hcm91cCB3aWR0aHM9XCJlcXVhbFwiPlxuICAgICAgICAgICAgICA8Rm9ybS5GaWVsZCBkaXNhYmxlZD17aXNVcGRhdGluZ30+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I+U2VuaGEgQXR1YWw8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDxGb3JtLklucHV0IG5hbWU9XCJwYXNzd29yZFwiIHR5cGU9XCJwYXNzd29yZFwiIHBsYWNlaG9sZGVyPVwiKioqKioqXCIgLz5cbiAgICAgICAgICAgICAgICA8c21hbGw+T2JzLjogRGVpeGUgZW0gYnJhbmNvIHBhcmEgbsOjbyBhbHRlcmFyPC9zbWFsbD5cbiAgICAgICAgICAgICAgPC9Gb3JtLkZpZWxkPlxuICAgICAgICAgICAgICA8Rm9ybS5JbnB1dFxuICAgICAgICAgICAgICAgIG5hbWU9XCJwYXNzd29yZDJcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgICAgICAgICAgICAgbGFiZWw9XCJOb3ZhIFNlbmhhXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIioqKioqKlwiXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzVXBkYXRpbmd9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L0Zvcm0uR3JvdXA+XG4gICAgICAgICAgKi99XG4gICAgICAgIDwvTW9kYWwuQ29udGVudD5cbiAgICAgICAgPE1vZGFsLkFjdGlvbnMgYXM9e0ZsZXhFbGVtZW50fSBqdXN0aWZ5PVwiZmxleC1lbmRcIj5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBjb250ZW50PVwiRmVjaGFyXCJcbiAgICAgICAgICAgIGRpc2FibGVkPXtpc1VwZGF0aW5nfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIHByaW1hcnlcbiAgICAgICAgICAgIGNvbnRlbnQ9XCJTYWx2YXJcIlxuICAgICAgICAgICAgaWNvbj1cInNhdmVcIlxuICAgICAgICAgICAgbG9hZGluZz17aXNVcGRhdGluZ31cbiAgICAgICAgICAgIGRpc2FibGVkPXtpc1VwZGF0aW5nfVxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVTdWJtaXR9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Nb2RhbC5BY3Rpb25zPlxuICAgICAgPC9Nb2RhbD5cbiAgICApO1xuICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gIGlzVXBkYXRpbmc6IHNlbGVjdG9ycy5pc1VwZGF0aW5nUHJvZmlsZShzdGF0ZSksXG4gIHNraWxsczogc2VsZWN0b3JzLmdldEVudGl0aWVzKHN0YXRlLCAnc2tpbGxzJyksXG59KTtcblxuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gZGlzcGF0Y2ggPT4gKHtcbiAgYWN0aW9uczogYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCksXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcykoU2V0dGluZ3MpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRDovcmVwby5naXQvZGphbG1hanIvYWdlbmNpYS1hbWlnYS9zcmMvdmlld3MvY29udGFpbmVycy90b3BiYXIvc2V0dGluZ3MuanN4IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL21haW4uc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwJm1vZHVsZXMmbG9jYWxJZGVudE5hbWU9W25hbWVdX19bbG9jYWxdX19baGFzaDpiYXNlNjQ6MTBdIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAmbW9kdWxlcyZsb2NhbElkZW50TmFtZT1bbmFtZV1fX1tsb2NhbF1fX1toYXNoOmJhc2U2NDoxMF0hLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92aWV3cy9jb250YWluZXJzL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvdmlld3MvY29udGFpbmVycy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKSkoMTY1Mik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBfX19BR0VOQ0lBX0FNSUdBX19fXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9